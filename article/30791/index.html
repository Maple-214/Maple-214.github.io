<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"><title>1-5、基础篇：函数更多 | 澤楓の小屋</title><meta name="author" content="泽枫"><meta name="copyright" content="泽枫"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="五、函数更多函数是任何应用程序的基本构件，无论它们是本地函数，从另一个模块导入，还是一个类上的方法。它们也是值，就像其他值一样，TypeScript有很多方法来描述如何调用函数。让我们来学习一下如何编写描述函数的类型。 5.1 函数类型表达式描述一个函数的最简单方法是用一个函数类型表达式。这些类型在语法上类似于箭头函数。 function greeter(fn: (a: string) &#x3D;&gt;"><meta property="og:type" content="article"><meta property="og:title" content="1-5、基础篇：函数更多"><meta property="og:url" content="https://maple-214.cn/article/30791/index.html"><meta property="og:site_name" content="澤楓の小屋"><meta property="og:description" content="五、函数更多函数是任何应用程序的基本构件，无论它们是本地函数，从另一个模块导入，还是一个类上的方法。它们也是值，就像其他值一样，TypeScript有很多方法来描述如何调用函数。让我们来学习一下如何编写描述函数的类型。 5.1 函数类型表达式描述一个函数的最简单方法是用一个函数类型表达式。这些类型在语法上类似于箭头函数。 function greeter(fn: (a: string) &#x3D;&gt;"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://maple-214.cn/img/cover/cover_03.jpg"><meta property="article:published_time" content="2024-01-26T12:10:16.000Z"><meta property="article:modified_time" content="2024-01-26T15:44:01.790Z"><meta property="article:author" content="泽枫"><meta property="article:tag" content="前端"><meta property="article:tag" content="TypeScript"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://maple-214.cn/img/cover/cover_03.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://maple-214.cn/article/30791/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//www.google-analytics.com" crossorigin=""><link rel="preconnect" href="//hm.baidu.com"><link rel="preconnect" href="//busuanzi.ibruce.info"><meta name="google-site-verification" content="OAauFcQX49kS2UGN9SShSqwNxfrsByxSVXRfNyc"><meta name="baidu-site-verification" content="codeva-JddVaE5CKl"><link rel="stylesheet" href="/css/index.css?v=4.12.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.32/dist/fancybox/fancybox.min.css" media="print" onload='this.media="all"'><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(adsbygoogle=window.adsbygoogle||[]).push({google_ad_client:"ca-pub-4229599433514996",enable_page_level_ads:"true"})</script><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script"),t=(e.src="https://hm.baidu.com/hm.js?6df43866b91212ab3dbadbcfd5966f6c",document.getElementsByTagName("script")[0]);t.parentNode.insertBefore(e,t)}()</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-FZNMK725WD"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-FZNMK725WD")</script><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"/search.xml",preload:!0,top_n_per_article:1,unescape:!1,languages:{hits_empty:"找不到您查询的内容：${query}",hits_stats:"共找到 ${hits} 篇文章"}},translate:{defaultEncoding:2,translateDelay:0,msgToTraditionalChinese:"繁体",msgToSimplifiedChinese:"简体"},noticeOutdate:void 0,highlight:{plugin:"highlight.js",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:150},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"",dateSuffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:{limitCount:50,languages:{author:"作者: 泽枫",link:"链接: ",source:"来源: 澤楓の小屋",info:"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},lightbox:"fancybox",Snackbar:{chs_to_cht:"你已切换为繁体中文",cht_to_chs:"你已切换为简体中文",day_to_night:"你已切换为深色模式",night_to_day:"你已切换为浅色模式",bgLight:"#49b1f5",bgDark:"#1f1f1f",position:"bottom-left"},infinitegrid:{js:"https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.0/dist/infinitegrid.min.js",buttonText:"加载更多"},isPhotoFigcaption:!0,islazyload:!1,isAnchor:!1,percent:{toc:!0,rightside:!0},autoDarkmode:!1}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"1-5、基础篇：函数更多",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2024-01-26 23:44:01"}</script><script>(e=>{e.saveToLocal={set:(e,t,a)=>{var o;0!==a&&(o=Date.now(),localStorage.setItem(e,JSON.stringify({value:t,expiry:o+864e5*a})))},get:e=>{var t=localStorage.getItem(e);if(t){t=JSON.parse(t);if(!(Date.now()>t.expiry))return t.value;localStorage.removeItem(e)}}},e.getScript=(o,n={})=>new Promise((t,e)=>{const a=document.createElement("script");a.src=o,a.async=!0,a.onerror=e,a.onload=a.onreadystatechange=function(){var e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(a.onload=a.onreadystatechange=null,t())},Object.keys(n).forEach(e=>{a.setAttribute(e,n[e])}),document.head.appendChild(a)}),e.getCSS=(o,n=!1)=>new Promise((t,e)=>{const a=document.createElement("link");a.rel="stylesheet",a.href=o,n&&(a.id=n),a.onerror=e,a.onload=a.onreadystatechange=function(){var e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(a.onload=a.onreadystatechange=null,t())},document.head.appendChild(a)}),e.activateDarkMode=()=>{document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=()=>{document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};e=saveToLocal.get("theme"),"dark"===e?activateDarkMode():"light"===e&&activateLightMode(),e=saveToLocal.get("aside-status");void 0!==e&&("hide"===e?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"));/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})(window)</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-swiper/swiper/swiper.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-swiper/swiper/swiperstyle.css"><meta name="generator" content="Hexo 7.1.1"><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head><body><script async src="/js/src/sakura.js"></script><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{const d=document.getElementById("loading-box"),e=document.body,o={endLoading:()=>{e.style.overflow="",d.classList.add("loaded")},initLoading:()=>{e.style.overflow="hidden",d.classList.remove("loaded")}};o.initLoading(),window.addEventListener("load",()=>{o.endLoading()})})()</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">26</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">3</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><hr class="custom-hr"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image:url(/img/cover/cover_03.jpg)"><nav id="nav"><span id="blog-info"><a href="/" title="澤楓の小屋">澤楓の小屋</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div></div><center id="name-container"><a id="page-name" href="javascript:scrollToTop()">PAGE_NAME</a></center></div><div id="nav-right"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">1-5、基础篇：函数更多</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-01-26T12:10:16.000Z" title="发表于 2024-01-26 20:10:16">2024-01-26</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-01-26T15:44:01.790Z" title="更新于 2024-01-26 23:44:01">2024-01-26</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/TypeScript/">TypeScript</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title="1-5、基础篇：函数更多"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="五、函数更多"><a href="#五、函数更多" class="headerlink" title="五、函数更多"></a>五、函数更多</h1><p>函数是任何应用程序的基本构件，无论它们是本地函数，从另一个模块导入，还是一个类上的方法。它们也是值，就像其他值一样，TypeScript有很多方法来描述如何调用函数。让我们来学习一下如何编写描述函数的类型。</p><h2 id="5-1-函数类型表达式"><a href="#5-1-函数类型表达式" class="headerlink" title="5.1 函数类型表达式"></a>5.1 函数类型表达式</h2><p>描述一个函数的最简单方法是用一个函数类型表达式。这些类型在语法上类似于箭头函数。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">greeter</span>(<span class="params">fn: (a: <span class="built_in">string</span>) =&gt; <span class="built_in">void</span></span>) &#123;</span><br><span class="line">  <span class="title function_">fn</span>(<span class="string">&quot;Hello, World&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">printToConsole</span>(<span class="params">s: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">greeter</span>(printToConsole);</span><br></pre></td></tr></table></figure><p>语法<code>(a: string) =&gt; void</code>意味着 “有一个参数的函数，名为 <code>a</code>，类型为字符串，没有返回值”。就像函数声明一样，如果没有指定参数类型，它就隐含为 <code>any</code> 类型。</p><p>当然，我们可以用一个类型别名来命名一个函数类型。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">GreetFunction</span> = <span class="function">(<span class="params">a: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">greeter</span>(<span class="params">fn: GreetFunction</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-2-调用签名"><a href="#5-2-调用签名" class="headerlink" title="5.2 调用签名"></a>5.2 调用签名</h2><p>在JavaScript中，除了可调用之外，函数还可以有属性。然而，函数类型表达式的语法不允许声明属性。如果我们想用属性来描述可调用的东西，我们可以在一个对象类型中写一个<em>调用签名</em>。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">DescribableFunction</span> = &#123;</span><br><span class="line">  <span class="attr">description</span>: <span class="built_in">string</span>;</span><br><span class="line">  (<span class="attr">someArg</span>: <span class="built_in">number</span>): <span class="built_in">boolean</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">doSomething</span>(<span class="params">fn: DescribableFunction</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(fn.<span class="property">description</span> + <span class="string">&quot; returned &quot;</span> + <span class="title function_">fn</span>(<span class="number">6</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">fn1.<span class="property">description</span> = <span class="string">&quot;balabala...&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">doSomething</span>(fn1);</span><br></pre></td></tr></table></figure><p>注意，与函数类型表达式相比，语法略有不同：在参数列表和返回类型之间使用<code>:</code>而不是<code>=&gt;</code>。</p><h2 id="5-3-构造签名"><a href="#5-3-构造签名" class="headerlink" title="5.3 构造签名"></a>5.3 构造签名</h2><p>JavaScript函数也可以用 <code>new</code> 操作符来调用。TypeScript将这些称为构造函数，因为它们通常会创建一个新的对象。你可以通过在调用签名前面添加 <code>new</code> 关键字来写一个构造签名。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Ctor</span> &#123;</span><br><span class="line">  <span class="attr">s</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">s: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">s</span> = s;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">SomeConstructor</span> = &#123;</span><br><span class="line">  <span class="keyword">new</span> (<span class="attr">s</span>: <span class="built_in">string</span>): <span class="title class_">Ctor</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">ctor: SomeConstructor</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">ctor</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> f = <span class="title function_">fn</span>(<span class="title class_">Ctor</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(f.<span class="property">s</span>);</span><br></pre></td></tr></table></figure><p>有些对象，如 JavaScript 的 <code>Date</code> 对象，可以在有 <code>new</code> 或没有 <code>new</code> 的情况下被调用。你可以在同一类型中任意地结合调用和构造签名。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">CallOrConstruct</span> &#123;</span><br><span class="line">  <span class="keyword">new</span> (<span class="attr">s</span>: <span class="built_in">string</span>): <span class="title class_">Date</span>;</span><br><span class="line">  (n?: <span class="built_in">number</span>): <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">date: CallOrConstruct</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> d = <span class="keyword">new</span> <span class="title function_">date</span>(<span class="string">&quot;2021-11-20&quot;</span>);</span><br><span class="line">  <span class="keyword">let</span> n = <span class="title function_">date</span>(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再举一个例子：</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">ClockConstructor</span> &#123;</span><br><span class="line">  <span class="keyword">new</span> (<span class="attr">hour</span>: <span class="built_in">number</span>, <span class="attr">minute</span>: <span class="built_in">number</span>): <span class="title class_">ClockInterface</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ClockInterface</span> &#123;</span><br><span class="line">  <span class="title function_">tick</span>(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createClock</span>(<span class="params"></span></span><br><span class="line"><span class="params">  ctor: ClockConstructor,</span></span><br><span class="line"><span class="params">  hour: <span class="built_in">number</span>,</span></span><br><span class="line"><span class="params">  minute: <span class="built_in">number</span>,</span></span><br><span class="line"><span class="params"></span>): <span class="title class_">ClockInterface</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">ctor</span>(hour, minute);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DigitalClock</span> <span class="keyword">implements</span> <span class="title class_">ClockInterface</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">h: <span class="built_in">number</span>, m: <span class="built_in">number</span></span>) &#123;&#125;</span><br><span class="line">  <span class="title function_">tick</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;beep beep&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AnalogClock</span> <span class="keyword">implements</span> <span class="title class_">ClockInterface</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">h: <span class="built_in">number</span>, m: <span class="built_in">number</span></span>) &#123;&#125;</span><br><span class="line">  <span class="title function_">tick</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;tick tock&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> digital = <span class="title function_">createClock</span>(<span class="title class_">DigitalClock</span>, <span class="number">12</span>, <span class="number">17</span>);</span><br><span class="line"><span class="keyword">let</span> analog = <span class="title function_">createClock</span>(<span class="title class_">AnalogClock</span>, <span class="number">7</span>, <span class="number">32</span>);</span><br></pre></td></tr></table></figure><h2 id="5-4-泛型函数"><a href="#5-4-泛型函数" class="headerlink" title="5.4 泛型函数"></a>5.4 泛型函数</h2><p>在写一个函数时，输入的类型与输出的类型有关，或者两个输入的类型以某种方式相关，这是常见的。让我们考虑一下一个返回数组中第一个元素的函数。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">firstElement</span>(<span class="params">arr: <span class="built_in">any</span>[]</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> arr[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数完成了它的工作，但不幸的是它的返回类型是 <code>any</code>。如果该函数返回数组元素的类型会更好。</p><p>在TypeScript中，当我们想描述两个值之间的对应关系时，会使用泛型。我们通过在函数签名中声明一个类型参数来做到这一点：</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> firstElement&lt;<span class="title class_">Type</span>&gt;(<span class="attr">arr</span>: <span class="title class_">Type</span>[]): <span class="title class_">Type</span> | <span class="literal">undefined</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> arr[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过给这个函数添加一个类型参数 <code>Type</code>，并在两个地方使用它，我们已经在函数的输入（数组）和输出（返回值）之间建立了一个联系。现在当我们调用它时，一个更具体的类型就出来了：</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// s 是 &#x27;string&#x27; 类型</span></span><br><span class="line"><span class="keyword">const</span> s = <span class="title function_">firstElement</span>([<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>]);</span><br><span class="line"><span class="comment">// n 是 &#x27;number&#x27; 类型</span></span><br><span class="line"><span class="keyword">const</span> n = <span class="title function_">firstElement</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"><span class="comment">// u 是 undefined 类型</span></span><br><span class="line"><span class="keyword">const</span> u = <span class="title function_">firstElement</span>([]);</span><br></pre></td></tr></table></figure><h3 id="5-4-1-类型推断"><a href="#5-4-1-类型推断" class="headerlink" title="5.4.1 类型推断"></a>5.4.1 类型推断</h3><p>请注意，在这个例子中，我们没有必要指定类型。类型是由TypeScript推断出来的–自动选择。</p><p>我们也可以使用多个类型参数。例如，一个独立版本的map看起来是这样的。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> map&lt;<span class="title class_">Input</span>, <span class="title class_">Output</span>&gt;(</span><br><span class="line">  <span class="attr">arr</span>: <span class="title class_">Input</span>[],</span><br><span class="line">  <span class="attr">func</span>: <span class="function">(<span class="params">arg: Input</span>) =&gt;</span> <span class="title class_">Output</span>,</span><br><span class="line">): <span class="title class_">Output</span>[] &#123;</span><br><span class="line">  <span class="keyword">return</span> arr.<span class="title function_">map</span>(func);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数&#x27;n&#x27;是&#x27;字符串&#x27;类型。</span></span><br><span class="line"><span class="comment">// &#x27;parsed&#x27;是&#x27;number[]&#x27;类型。</span></span><br><span class="line"><span class="keyword">const</span> parsed = <span class="title function_">map</span>([<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>], <span class="function">(<span class="params">n</span>) =&gt;</span> <span class="built_in">parseInt</span>(n));</span><br></pre></td></tr></table></figure><p>请注意，在这个例子中，TypeScript可以推断出输入类型参数的类型（从给定的字符串数组），以及基于函数表达式的返回值（数字）的输出类型参数。</p><h3 id="5-4-2-限制条件"><a href="#5-4-2-限制条件" class="headerlink" title="5.4.2 限制条件"></a>5.4.2 限制条件</h3><p>我们已经写了一些通用函数，可以对任何类型的值进行操作。有时我们想把两个值联系起来，但只能对某个值的子集进行操作。在这种情况下，我们可以使用一个约束条件来限制一个类型参数可以接受的类型。</p><p>让我们写一个函数，返回两个值中较长的值。要做到这一点，我们需要一个长度属性，是一个数字。我们通过写一个扩展子句将类型参数限制在这个类型上。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> longest&lt;<span class="title class_">Type</span> <span class="keyword">extends</span> &#123; <span class="attr">length</span>: <span class="built_in">number</span> &#125;&gt;(<span class="attr">a</span>: <span class="title class_">Type</span>, <span class="attr">b</span>: <span class="title class_">Type</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (a.<span class="property">length</span> &gt;= b.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// longerArray 的类型是 &#x27;number[]&#x27;</span></span><br><span class="line"><span class="keyword">const</span> longerArray = <span class="title function_">longest</span>([<span class="number">1</span>, <span class="number">2</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"><span class="comment">// longerString 是 &#x27;alice&#x27;|&#x27;bob&#x27; 的类型。</span></span><br><span class="line"><span class="keyword">const</span> longerString = <span class="title function_">longest</span>(<span class="string">&quot;alice&quot;</span>, <span class="string">&quot;bob&quot;</span>);</span><br><span class="line"><span class="comment">// 错误! 数字没有&#x27;长度&#x27;属性</span></span><br><span class="line"><span class="keyword">const</span> notOK = <span class="title function_">longest</span>(<span class="number">10</span>, <span class="number">100</span>);</span><br></pre></td></tr></table></figure><img src="https://s2.loli.net/2022/02/22/WjBVzACtyJ87q1H.png" alt="image-20211121103833933" style="zoom:50%"><p>在这个例子中，有一些有趣的事情需要注意。我们允许TypeScript推断 <code>longest</code> 的返回类型。返回类型推断也适用于通用函数。</p><p>因为我们将 Type 约束为<code>&#123; length: number &#125;</code>，所以我们被允许访问 <code>a</code> 和 <code>b</code> 参数的 <code>.length</code> 属性。如果没有类型约束，我们就不能访问这些属性，因为这些值可能是一些没有长度属性的其他类型。</p><p><code>longerArray</code> 和 <code>longerString</code> 的类型是根据参数推断出来的。记住，泛型就是把两个或多个具有相同类型的值联系起来。</p><p>最后，正如我们所希望的，对 <code>longest(10, 100)</code> 的调用被拒绝了，因为数字类型没有一个<code>.length</code>属性。</p><h3 id="5-4-3-使用受限值"><a href="#5-4-3-使用受限值" class="headerlink" title="5.4.3 使用受限值"></a>5.4.3 使用受限值</h3><p>这里有一个使用通用约束条件时的常见错误。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> minimumLength&lt;<span class="title class_">Type</span> <span class="keyword">extends</span> &#123; <span class="attr">length</span>: <span class="built_in">number</span> &#125;&gt;(</span><br><span class="line">  <span class="attr">obj</span>: <span class="title class_">Type</span>,</span><br><span class="line">  <span class="attr">minimum</span>: <span class="built_in">number</span>,</span><br><span class="line">): <span class="title class_">Type</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (obj.<span class="property">length</span> &gt;= minimum) &#123;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">length</span>: minimum &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/img/TypeScript/04-12.png" alt="image-20211121104538424" style="zoom:40%"><p>看起来这个函数没有问题–Type被限制为{ length: number }，而且这个函数要么返回Type，要么返回一个与该限制相匹配的值。问题是，该函数承诺返回与传入的对象相同的类型，而不仅仅是与约束条件相匹配的一些对象。如果这段代码是合法的，你可以写出肯定无法工作的代码。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// &#x27;arr&#x27; 获得值： &#123; length: 6 &#125;</span></span><br><span class="line"><span class="keyword">const</span> arr = <span class="title function_">minimumLength</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="number">6</span>);</span><br><span class="line"><span class="comment">//在此崩溃，因为数组有一个&#x27;切片&#x27;方法，但没有返回对象!</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="title function_">slice</span>(<span class="number">0</span>));</span><br></pre></td></tr></table></figure><p>![image-20211121105340359](Users&#x2F;felix&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20211121105340359.png)</p><h3 id="5-4-4-指定类型参数"><a href="#5-4-4-指定类型参数" class="headerlink" title="5.4.4 指定类型参数"></a>5.4.4 指定类型参数</h3><p>TypeScript 通常可以推断出通用调用中的预期类型参数，但并非总是如此。例如，假设你写了一个函数来合并两个数组：</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> combine&lt;<span class="title class_">Type</span>&gt;(<span class="attr">arr1</span>: <span class="title class_">Type</span>[], <span class="attr">arr2</span>: <span class="title class_">Type</span>[]): <span class="title class_">Type</span>[] &#123;</span><br><span class="line">  <span class="keyword">return</span> arr1.<span class="title function_">concat</span>(arr2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通常情况下，用不匹配的数组调用这个函数是一个错误：</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = <span class="title function_">combine</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="string">&quot;hello&quot;</span>]);</span><br></pre></td></tr></table></figure><img src="https://s2.loli.net/2022/02/22/a7IfnzN9h3mAHKk.png" alt="image-20211121110056686" style="zoom:40%"><p>然而，如果你打算这样做，你可以手动指定类型：</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = combine&lt;<span class="built_in">string</span> | <span class="built_in">number</span>&gt;([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="string">&quot;hello&quot;</span>]);</span><br></pre></td></tr></table></figure><h3 id="5-4-5-编写优秀通用函数的准则"><a href="#5-4-5-编写优秀通用函数的准则" class="headerlink" title="5.4.5 编写优秀通用函数的准则"></a>5.4.5 编写优秀通用函数的准则</h3><p>编写泛型函数很有趣，而且很容易被类型参数所迷惑。有太多的类型参数或在不需要的地方使用约束，会使推理不那么成功，使你的函数的调用者感到沮丧。</p><ul><li><strong>类型参数下推</strong></li></ul><p>下面是两种看似相似的函数写法。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> firstElement1&lt;<span class="title class_">Type</span>&gt;(<span class="attr">arr</span>: <span class="title class_">Type</span>[]) &#123;</span><br><span class="line">  <span class="keyword">return</span> arr[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> firstElement2&lt;<span class="title class_">Type</span> <span class="keyword">extends</span> <span class="built_in">any</span>[]&gt;(<span class="attr">arr</span>: <span class="title class_">Type</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> arr[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// a: number (推荐)</span></span><br><span class="line"><span class="keyword">const</span> a = <span class="title function_">firstElement1</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"><span class="comment">// b: any (不推荐)</span></span><br><span class="line"><span class="keyword">const</span> b = <span class="title function_">firstElement2</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br></pre></td></tr></table></figure><p>乍一看，这些可能是相同的，但 <code>firstElement1</code> 是写这个函数的一个更好的方法。它的推断返回类型是Type，但 <code>firstElement2</code> 的推断返回类型是 <code>any</code>，因为TypeScript必须使用约束类型来解析<code>arr[0]</code>表达式，而不是在调用期间 “等待 “解析该元素。</p><blockquote><p><strong>规则：</strong>在可能的情况下，使用类型参数本身，而不是对其进行约束</p></blockquote><ul><li><strong>使用更少的类型参数</strong></li></ul><p>下面是另一对类似的函数。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> filter1&lt;<span class="title class_">Type</span>&gt;(<span class="attr">arr</span>: <span class="title class_">Type</span>[], <span class="attr">func</span>: <span class="function">(<span class="params">arg: Type</span>) =&gt;</span> <span class="built_in">boolean</span>): <span class="title class_">Type</span>[] &#123;</span><br><span class="line">  <span class="keyword">return</span> arr.<span class="title function_">filter</span>(func);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> filter2&lt;<span class="title class_">Type</span>, <span class="title class_">Func</span> <span class="keyword">extends</span> (<span class="attr">arg</span>: <span class="title class_">Type</span>) =&gt; <span class="built_in">boolean</span>&gt;(</span><br><span class="line">  <span class="attr">arr</span>: <span class="title class_">Type</span>[],</span><br><span class="line">  <span class="attr">func</span>: <span class="title class_">Func</span>,</span><br><span class="line">): <span class="title class_">Type</span>[] &#123;</span><br><span class="line">  <span class="keyword">return</span> arr.<span class="title function_">filter</span>(func);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们已经创建了一个类型参数 <code>Func</code>，它并不涉及两个值。这总是一个值得标记的坏习惯，因为它意味着想要指定类型参数的调用者必须无缘无故地手动指定一个额外的类型参数。<code>Func</code>除了使函数更难阅读和推理外，什么也没做。</p><blockquote><p><strong>规则：</strong>总是尽可能少地使用类型参数</p></blockquote><ul><li><strong>类型参数应出现两次</strong></li></ul><p>有时我们会忘记，一个函数可能不需要是通用的：</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> greet&lt;<span class="title class_">Str</span> <span class="keyword">extends</span> <span class="built_in">string</span>&gt;(<span class="attr">s</span>: <span class="title class_">Str</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello, &quot;</span> + s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">greet</span>(<span class="string">&quot;world&quot;</span>);</span><br></pre></td></tr></table></figure><p>我们完全可以写一个更简单的版本：</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">greet</span>(<span class="params">s: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello, &quot;</span> + s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>记住，类型参数是用来关联多个值的类型的。如果一个类型参数在函数签名中只使用一次，那么它就没有任何关系。</p><blockquote><p><strong>规则：</strong>如果一个类型的参数只出现在一个地方，请重新考虑你是否真的需要它</p></blockquote><h2 id="5-5-可选参数"><a href="#5-5-可选参数" class="headerlink" title="5.5 可选参数"></a>5.5 可选参数</h2><p>JavaScript中的函数经常需要一个可变数量的参数。例如，<code>number</code> 的 <code>toFixed</code>方法需要一个可选的数字计数。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">n: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(n.<span class="title function_">toFixed</span>()); <span class="comment">// 0 个参数</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(n.<span class="title function_">toFixed</span>(<span class="number">3</span>)); <span class="comment">// 1 个参数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以在TypeScript中通过将参数用 <code>?</code>标记：</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">x?: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">f</span>(); <span class="comment">// 正确</span></span><br><span class="line"><span class="title function_">f</span>(<span class="number">10</span>); <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure><p>虽然参数被指定为 <code>number</code> 类型，但 <code>x</code> 参数实际上将具有 <code>number | undefined</code> 类型，因为在JavaScript中未指定的参数会得到 <code>undefined</code> 的值。</p><p>你也可以提供一个参数默认值。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">x = <span class="number">10</span></span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在在 <code>f</code> 的主体中，<code>x</code> 将具有 <code>number</code> 类型，因为任何 <code>undefined</code> 的参数将被替换为 <code>10</code>。请注意，当一个参数是可选的，调用者总是可以传递未定义的参数，因为这只是模拟一个 “丢失 “的参数：</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">x?: <span class="built_in">number</span></span>): <span class="built_in">void</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下调用都是正确的</span></span><br><span class="line"><span class="title function_">f</span>();</span><br><span class="line"><span class="title function_">f</span>(<span class="number">10</span>);</span><br><span class="line"><span class="title function_">f</span>(<span class="literal">undefined</span>);</span><br></pre></td></tr></table></figure><h3 id="5-5-1-回调中的可选参数"><a href="#5-5-1-回调中的可选参数" class="headerlink" title="5.5.1 回调中的可选参数"></a>5.5.1 回调中的可选参数</h3><p>一旦你了解了可选参数和函数类型表达式，在编写调用回调的函数时就很容易犯以下错误：</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myForEach</span>(<span class="params">arr: <span class="built_in">any</span>[], callback: (arg: <span class="built_in">any</span>, index?: <span class="built_in">number</span>) =&gt; <span class="built_in">void</span></span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="title function_">callback</span>(arr[i], i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在写 <code>index?</code> 作为一个可选参数时，通常是想让这些调用都是合法的：</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="title function_">myForEach</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="function">(<span class="params">a</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(a));</span><br><span class="line"><span class="title function_">myForEach</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="function">(<span class="params">a, i</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(a, i));</span><br></pre></td></tr></table></figure><p>这实际上意味着回调可能会被调用，只有一个参数。换句话说，该函数定义说，实现可能是这样的：</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myForEach</span>(<span class="params">arr: <span class="built_in">any</span>[], callback: (arg: <span class="built_in">any</span>, index?: <span class="built_in">number</span>) =&gt; <span class="built_in">void</span></span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 我现在不想提供索引</span></span><br><span class="line">    <span class="title function_">callback</span>(arr[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反过来，TypeScript会强制执行这个意思，并发出实际上不可能的错误：</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="title function_">myForEach</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="function">(<span class="params">a, i</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i.<span class="title function_">toFixed</span>());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><img src="/img/TypeScript/04-14.png" alt="image-20211121151911039" style="zoom:40%"><p>在JavaScript中，如果你调用一个形参多于实参的函数，额外的参数会被简单地忽略。TypeScript的行为也是如此。参数较少的函数（相同的类型）总是可以取代参数较多的函数的位置。</p><blockquote><p>当为回调写一个函数类型时，永远不要写一个可选参数，除非你打算在不传递该参数的情况下调用函数。</p></blockquote><h2 id="5-6-函数重载"><a href="#5-6-函数重载" class="headerlink" title="5.6 函数重载"></a>5.6 函数重载</h2><p>一些 JavaScript 函数可以在不同的参数数量和类型中被调用。例如，你可能会写一个函数来产生一个Date，它需要一个时间戳（一个参数）或一个月&#x2F;日&#x2F;年规格（三个参数）。</p><p>在TypeScript中，我们可以通过编写重载签名来指定一个可以以不同方式调用的函数。要做到这一点，要写一些数量的函数签名（通常是两个或更多），然后是函数的主体：</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">makeDate</span>(<span class="params">timestamp: <span class="built_in">number</span></span>): <span class="title class_">Date</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">makeDate</span>(<span class="params">m: <span class="built_in">number</span>, d: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="title class_">Date</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">makeDate</span>(<span class="params">mOrTimestamp: <span class="built_in">number</span>, d?: <span class="built_in">number</span>, y?: <span class="built_in">number</span></span>): <span class="title class_">Date</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (d !== <span class="literal">undefined</span> &amp;&amp; y !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Date</span>(y, mOrTimestamp, d);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Date</span>(mOrTimestamp);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> d1 = <span class="title function_">makeDate</span>(<span class="number">12345678</span>);</span><br><span class="line"><span class="keyword">const</span> d2 = <span class="title function_">makeDate</span>(<span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>);</span><br><span class="line"><span class="keyword">const</span> d3 = <span class="title function_">makeDate</span>(<span class="number">1</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure><img src="/img/TypeScript/04-15.png" alt="image-20211121153802236" style="zoom:42%"><p>在这个例子中，我们写了两个重载：一个接受一个参数，另一个接受三个参数。这前两个签名被称为重载签名。</p><p>然后，我们写了一个具有兼容签名的函数实现。函数有一个实现签名，但这个签名不能被直接调用。即使我们写了一个在所需参数之后有两个可选参数的函数，它也不能以两个参数被调用！</p><h3 id="5-6-1-重载签名和实现签名"><a href="#5-6-1-重载签名和实现签名" class="headerlink" title="5.6.1 重载签名和实现签名"></a>5.6.1 重载签名和实现签名</h3><p>这是一个常见的混乱来源。通常我们会写这样的代码，却不明白为什么会出现错误：</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">x: <span class="built_in">string</span></span>): <span class="built_in">void</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 期望能够以零参数调用</span></span><br><span class="line"><span class="title function_">fn</span>();</span><br></pre></td></tr></table></figure><img src="https://s2.loli.net/2022/02/22/2PbtdUgEz5Ts3Dr.png" alt="image-20211121154720160" style="zoom:50%"><p>同样，用于编写函数体的签名不能从外面 “看到”。</p><blockquote><p>实现的签名从外面是看不到的。在编写重载函数时，你应该总是在函数的实现上面有两个或多个签名。</p></blockquote><p>实现签名也必须与重载签名兼容。例如，这些函数有错误，因为实现签名没有以正确的方式匹配重载：</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">x: <span class="built_in">boolean</span></span>): <span class="built_in">void</span>;</span><br><span class="line"><span class="comment">// 参数类型不正确</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">x: <span class="built_in">string</span></span>): <span class="built_in">void</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">x: <span class="built_in">boolean</span></span>) &#123;&#125;</span><br></pre></td></tr></table></figure><img src="https://s2.loli.net/2022/02/22/saCfOyHuShpilg3.png" alt="image-20211121160302934" style="zoom:50%"><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">x: <span class="built_in">string</span></span>): <span class="built_in">string</span>;</span><br><span class="line"><span class="comment">// 返回类型不正确</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">x: <span class="built_in">number</span></span>): <span class="built_in">boolean</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">x: <span class="built_in">string</span> | <span class="built_in">number</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;oops&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://s2.loli.net/2022/02/22/4OAqJInZEdRftuv.png" alt="image-20211121160413329" style="zoom:50%"><h3 id="5-6-2-编写好的重载"><a href="#5-6-2-编写好的重载" class="headerlink" title="5.6.2 编写好的重载"></a>5.6.2 编写好的重载</h3><p>和泛型一样，在使用函数重载时，有一些准则是你应该遵循的。遵循这些原则将使你的函数更容易调用，更容易理解，更容易实现。</p><p>让我们考虑一个返回字符串或数组长度的函数：</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">len</span>(<span class="params">s: <span class="built_in">string</span></span>): <span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">len</span>(<span class="params">arr: <span class="built_in">any</span>[]</span>): <span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">len</span>(<span class="params">x: <span class="built_in">any</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x.<span class="property">length</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数是好的；我们可以用字符串或数组来调用它。然而，我们不能用一个可能是字符串或数组的值来调用它，因为TypeScript只能将一个函数调用解析为一个重载：</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="title function_">len</span>(<span class="string">&quot;&quot;</span>); <span class="comment">// OK</span></span><br><span class="line"><span class="title function_">len</span>([<span class="number">0</span>]); <span class="comment">// OK</span></span><br><span class="line"><span class="title function_">len</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() &gt; <span class="number">0.5</span> ? <span class="string">&quot;hello&quot;</span> : [<span class="number">0</span>]);</span><br></pre></td></tr></table></figure><img src="https://s2.loli.net/2022/02/22/6NRbiq5Dp3ulKhg.png" alt="image-20211121161500523" style="zoom:50%"><p>因为两个重载都有相同的参数数量和相同的返回类型，我们可以改写一个非重载版本的函数：</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">len</span>(<span class="params">x: <span class="built_in">any</span>[] | <span class="built_in">string</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x.<span class="property">length</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">len</span>(<span class="string">&quot;&quot;</span>); <span class="comment">// OK</span></span><br><span class="line"><span class="title function_">len</span>([<span class="number">0</span>]); <span class="comment">// OK</span></span><br><span class="line"><span class="title function_">len</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() &gt; <span class="number">0.5</span> ? <span class="string">&quot;hello&quot;</span> : [<span class="number">0</span>]); <span class="comment">// OK</span></span><br></pre></td></tr></table></figure><p>这就好得多了! 调用者可以用任何一种值来调用它，而且作为额外的奖励，我们不需要找出一个正确的实现签名。</p><blockquote><p>在可能的情况下，总是倾向于使用联合类型的参数而不是重载参数</p></blockquote><h3 id="5-6-3-函数内This的声明"><a href="#5-6-3-函数内This的声明" class="headerlink" title="5.6.3 函数内This的声明"></a>5.6.3 函数内<code>This</code>的声明</h3><p>TypeScript会通过代码流分析来推断函数中的 <code>this</code> 应该是什么，比如下面的例子：</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> user = &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="number">123</span>,</span><br><span class="line"></span><br><span class="line">  <span class="attr">admin</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">becomeAdmin</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">admin</span> = <span class="literal">true</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>TypeScript理解函数 <code>user.becomeAdmin</code> 有一个对应的 <code>this</code>，它是外部对象 <code>user</code>。这个对于很多情况来说已经足够了，但是有很多情况下你需要更多的控制 <code>this</code> 代表什么对象。JavaScript规范规定，你不能有一个叫 <code>this</code>的参数，所以TypeScript使用这个语法空间，让你在函数体中声明<code>this</code>的类型。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">User</span> &#123;</span><br><span class="line">  <span class="attr">admin</span>: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> DB &#123;</span><br><span class="line">  <span class="title function_">filterUsers</span>(<span class="attr">filter</span>: <span class="function">(<span class="params"><span class="variable language_">this</span>: User</span>) =&gt;</span> <span class="built_in">boolean</span>): <span class="title class_">User</span>[];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">db</span>: <span class="variable constant_">DB</span> = &#123;</span><br><span class="line">  <span class="attr">filterUsers</span>: <span class="function">(<span class="params">filter: (<span class="variable language_">this</span>: User) =&gt; <span class="built_in">boolean</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> user1 = &#123;</span><br><span class="line">      <span class="attr">admin</span>: <span class="literal">true</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> user2 = &#123;</span><br><span class="line">      <span class="attr">admin</span>: <span class="literal">false</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> [user1, user2];</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> admins = db.<span class="title function_">filterUsers</span>(<span class="keyword">function</span> (<span class="params"><span class="variable language_">this</span>: User</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">admin</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这种模式在回调式API中很常见，另一个对象通常控制你的函数何时被调用。注意，你需要使用函数而不是箭头函数来获得这种行为。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">User</span> &#123;</span><br><span class="line">  <span class="attr">admin</span>: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> DB &#123;</span><br><span class="line">  <span class="title function_">filterUsers</span>(<span class="attr">filter</span>: <span class="function">(<span class="params"><span class="variable language_">this</span>: User</span>) =&gt;</span> <span class="built_in">boolean</span>): <span class="title class_">User</span>[];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">db</span>: <span class="variable constant_">DB</span> = &#123;</span><br><span class="line">  <span class="attr">filterUsers</span>: <span class="function">(<span class="params">filter: (<span class="variable language_">this</span>: User) =&gt; <span class="built_in">boolean</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> user1 = &#123;</span><br><span class="line">      <span class="attr">admin</span>: <span class="literal">true</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> user2 = &#123;</span><br><span class="line">      <span class="attr">admin</span>: <span class="literal">false</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> [user1, user2];</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 不能为箭头函数</span></span><br><span class="line"><span class="keyword">const</span> admins = db.<span class="title function_">filterUsers</span>(<span class="function">() =&gt;</span> <span class="variable language_">this</span>.<span class="property">admin</span>);</span><br></pre></td></tr></table></figure><img src="https://s2.loli.net/2022/02/22/vYImhS8FQOHgJfT.png" alt="image-20211121164923229" style="zoom:40%"><h2 id="5-7-需要了解的其他类型"><a href="#5-7-需要了解的其他类型" class="headerlink" title="5.7 需要了解的其他类型"></a>5.7 需要了解的其他类型</h2><p>有一些额外的类型你会想要认识，它们在处理函数类型时经常出现。像所有的类型一样，你可以在任何地方使用它们，但这些类型在函数的上下文中特别相关。</p><h3 id="5-7-1-void"><a href="#5-7-1-void" class="headerlink" title="5.7.1 void"></a>5.7.1 <code>void</code></h3><p><code>void</code>表示没有返回值的函数的返回值。当一个函数没有任何返回语句，或者没有从这些返回语句中返回任何明确的值时，它都是推断出来的类型。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 推断出的返回类型是void</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">noop</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在JavaScript中，一个不返回任何值的函数将隐含地返回<code>undefinded</code>的值。然而，在TypeScript中，<code>void</code>和<code>undefined</code>是不一样的。在本章末尾有进一步的细节。</p><blockquote><p><code>void</code>与<code>undefined</code>不一样。</p></blockquote><h3 id="5-7-2-object"><a href="#5-7-2-object" class="headerlink" title="5.7.2 object"></a>5.7.2 <code>object</code></h3><p>特殊类型 <code>object</code> 指的是任何不是基元的值（<code>string</code>、<code>number</code>、<code>bigint</code>、<code>boolean</code>、<code>symbol</code>、<code>null</code>或 <code>undefined</code>）。这与空对象类型<code>&#123; &#125;</code>不同，也与全局类型 <code>Object</code> 不同。你很可能永远不会使用 <code>Object</code>。</p><blockquote><p><code>object</code>不是<code>Object</code>。始终使用<code>object</code>!</p></blockquote><p>请注意，在JavaScript中，函数值是对象。它们有属性，在它们的原型链中有<code>Object.prototype</code>，是 <code>Object</code>的实例，你可以对它们调用 <code>Object.key</code>，等等。由于这个原因，函数类型在TypeScript中被认为是<code>object</code>。</p><h3 id="5-7-3-unknown"><a href="#5-7-3-unknown" class="headerlink" title="5.7.3 unknown"></a>5.7.3 <code>unknown</code></h3><p><code>unknown</code>类型代表任何值。这与 <code>any</code> 类型类似，但更安全，因为对未知 <code>unknown</code> 值做任何事情都是不合法的。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f1</span>(<span class="params">a: <span class="built_in">any</span></span>) &#123;</span><br><span class="line">  a.<span class="title function_">b</span>(); <span class="comment">// 正确</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f2</span>(<span class="params">a: <span class="built_in">unknown</span></span>) &#123;</span><br><span class="line">  a.<span class="title function_">b</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://s2.loli.net/2022/02/22/pl7s6ZDr8QKAJgh.png" alt="image-20211121172520948" style="zoom:50%"><p>这在描述函数类型时很有用，因为你可以描述接受任何值的函数，而不需要在函数体中有 <code>any</code> 值。</p><p>反之，你可以描述一个返回未知类型的值的函数：</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">safeParse</span>(<span class="params">s: <span class="built_in">string</span></span>): <span class="built_in">unknown</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">JSON</span>.<span class="title function_">parse</span>(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要小心对待&#x27;obj&#x27;!</span></span><br><span class="line"><span class="keyword">const</span> obj = <span class="title function_">safeParse</span>(someRandomString);</span><br></pre></td></tr></table></figure><h3 id="5-7-4-never"><a href="#5-7-4-never" class="headerlink" title="5.7.4 never"></a>5.7.4 <code>never</code></h3><p>有些函数永远不会返回一个值：</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fail</span>(<span class="params">msg: <span class="built_in">string</span></span>): <span class="built_in">never</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>never</code>类型表示永远不会被观察到的值。在一个返回类型中，这意味着函数抛出一个异常或终止程序的执行。</p><p><code>never</code>也出现在TypeScript确定一个 <code>union</code> 中没有任何东西的时候。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">x: <span class="built_in">string</span> | <span class="built_in">number</span></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> x === <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line">    <span class="comment">// 做一些事</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> x === <span class="string">&quot;number&quot;</span>) &#123;</span><br><span class="line">    <span class="comment">// 再做一些事</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    x; <span class="comment">// &#x27;never&#x27;!</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-7-5-Function"><a href="#5-7-5-Function" class="headerlink" title="5.7.5 Function"></a>5.7.5 <code>Function</code></h3><p>全局性的 <code>Function</code> 类型描述了诸如 <code>bind</code>、<code>call</code>、<code>apply</code>和其他存在于JavaScript中所有函数值的属性。它还有一个特殊的属性，即 <code>Function</code> 类型的值总是可以被调用；这些调用返回 <code>any</code>。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">doSomething</span>(<span class="params">f: <span class="built_in">Function</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">f</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个无类型的函数调用，一般来说最好避免，因为 <code>any</code> 返回类型都不安全。</p><p>如果你需要接受一个任意的函数，但不打算调用它，一般来说，<code>() =&gt; void</code>的类型比较安全。</p><h2 id="5-8-参数展开运算符"><a href="#5-8-参数展开运算符" class="headerlink" title="5.8 参数展开运算符"></a>5.8 参数展开运算符</h2><h3 id="5-8-1-形参展开-Rest-Parameters"><a href="#5-8-1-形参展开-Rest-Parameters" class="headerlink" title="5.8.1 形参展开(Rest Parameters)"></a>5.8.1 形参展开(Rest Parameters)</h3><p>除了使用可选参数或重载来制作可以接受各种固定参数数量的函数之外，我们还可以使用休止参数来定义接受无限制数量的参数的函数。</p><p><code>rest</code>参数出现在所有其他参数之后，并使用<code>...</code>的语法：</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">multiply</span>(<span class="params">n: <span class="built_in">number</span>, ...m: <span class="built_in">number</span>[]</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> m.<span class="title function_">map</span>(<span class="function">(<span class="params">x</span>) =&gt;</span> n * x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &#x27;a&#x27; 获得的值 [10, 20, 30, 40]</span></span><br><span class="line"><span class="keyword">const</span> a = <span class="title function_">multiply</span>(<span class="number">10</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br></pre></td></tr></table></figure><p>在TypeScript中，这些参数的类型注解是隐含的 <code>any[]</code>，而不是<code>any</code>，任何给出的类型注解必须是<code>Array&lt;T&gt;</code>或<code>T[]</code>的形式，或一个元组类型（我们将在后面学习）。</p><h3 id="5-8-2-实参展开-Rest-Arguments"><a href="#5-8-2-实参展开-Rest-Arguments" class="headerlink" title="5.8.2 实参展开(Rest Arguments)"></a>5.8.2 实参展开(Rest Arguments)</h3><p>反之，我们可以使用 <code>spread</code> 语法从数组中提供可变数量的参数。例如，数组的 <code>push</code> 方法需要任意数量的参数。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> arr2 = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line">arr1.<span class="title function_">push</span>(...arr2);</span><br></pre></td></tr></table></figure><p>请注意，一般来说，TypeScript并不假定数组是不可变的。这可能会导致一些令人惊讶的行为。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 推断的类型是 number[] -- &quot;一个有零或多个数字的数组&quot;。</span></span><br><span class="line"><span class="comment">// 不专指两个数字</span></span><br><span class="line"><span class="keyword">const</span> args = [<span class="number">8</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">const</span> angle = <span class="title class_">Math</span>.<span class="title function_">atan2</span>(...args);</span><br></pre></td></tr></table></figure><img src="/img/TypeScript/05-06.png" alt="image-20211122191044837" style="zoom:50%"><p>这种情况的最佳解决方案取决于你的代码，但一般来说，<code>const context</code> 是最直接的解决方案。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 推断为2个长度的元组</span></span><br><span class="line"><span class="keyword">const</span> args = [<span class="number">8</span>, <span class="number">5</span>] <span class="keyword">as</span> <span class="keyword">const</span>;</span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">const</span> angle = <span class="title class_">Math</span>.<span class="title function_">atan2</span>(...args);</span><br></pre></td></tr></table></figure><h2 id="5-9-参数解构"><a href="#5-9-参数解构" class="headerlink" title="5.9 参数解构"></a>5.9 参数解构</h2><p>你可以使用参数重构来方便地将作为参数提供的对象，解压到函数主体的一个或多个局部变量中。在JavaScript中，它看起来像这样：</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">&#123; a, b, c &#125;</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a + b + c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">sum</span>(&#123; <span class="attr">a</span>: <span class="number">10</span>, <span class="attr">b</span>: <span class="number">3</span>, <span class="attr">c</span>: <span class="number">9</span> &#125;);</span><br></pre></td></tr></table></figure><p>对象的类型注解在解构的语法之后：</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">&#123; a, b, c &#125;: &#123; a: <span class="built_in">number</span>; b: <span class="built_in">number</span>; c: <span class="built_in">number</span> &#125;</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a + b + c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这看起来有点啰嗦，但你也可以在这里使用一个命名的类型：</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 与之前的例子相同</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">ABC</span> = &#123; <span class="attr">a</span>: <span class="built_in">number</span>; <span class="attr">b</span>: <span class="built_in">number</span>; <span class="attr">c</span>: <span class="built_in">number</span> &#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">&#123; a, b, c &#125;: ABC</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a + b + c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-10-函数的可分配性"><a href="#5-10-函数的可分配性" class="headerlink" title="5.10 函数的可分配性"></a>5.10 函数的可分配性</h2><h3 id="5-10-1-返回-void-类型"><a href="#5-10-1-返回-void-类型" class="headerlink" title="5.10.1 返回 void 类型"></a>5.10.1 返回 <code>void</code> 类型</h3><p>函数的 <code>void</code> 返回类型可以产生一些不寻常的，但却是预期的行为。</p><p>返回类型为 <code>void</code> 的上下文类型并不强迫函数不返回东西。另一种说法是，一个具有 <code>void</code>返回类型的上下文函数类型（<code>type vf = () =&gt; void</code>），在实现时，可以返回任何其他的值，但它会被忽略。</p><p>因此，以下<code>（）=&gt; void</code>类型的实现是有效的：</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> voidFunc = <span class="function">() =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">f1</span>: voidFunc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">f2</span>: voidFunc = <span class="function">() =&gt;</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">f3</span>: voidFunc = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>而当这些函数之一的返回值被分配给另一个变量时，它将保留 <code>void</code> 的类型：</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> v1 = <span class="title function_">f1</span>();</span><br><span class="line"><span class="keyword">const</span> v2 = <span class="title function_">f2</span>();</span><br><span class="line"><span class="keyword">const</span> v3 = <span class="title function_">f3</span>();</span><br></pre></td></tr></table></figure><p>这种行为的存在使得下面的代码是有效的，即使 <code>Array.prototype.push</code>返回一个数字，而<code>Array.prototype.forEach</code>方法期望一个返回类型为<code>void</code>的函数：</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> src = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> dst = [<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">src.<span class="title function_">forEach</span>(<span class="function">(<span class="params">el</span>) =&gt;</span> dst.<span class="title function_">push</span>(el));</span><br></pre></td></tr></table></figure><p>还有一个需要注意的特殊情况，当一个字面的函数定义有一个 <code>void</code> 的返回类型时，该函数必须不返回任何东西。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f2</span>(<span class="params"></span>): <span class="built_in">void</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> f3 = <span class="keyword">function</span> (<span class="params"></span>): <span class="built_in">void</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><img src="https://s2.loli.net/2022/02/22/t7q4nWcpJxZz12D.png" alt="image-20211122220703542" style="zoom:50%"><h3 id="特别声明-本文转自-古艺散人老师-，如有需要可前往原文预览查看。"><a href="#特别声明-本文转自-古艺散人老师-，如有需要可前往原文预览查看。" class="headerlink" title="特别声明: 本文转自  古艺散人老师 ，如有需要可前往原文预览查看。"></a>特别声明: 本文转自 <a target="_blank" rel="noopener" href="https://github.com/lurongtao/TypeScript">古艺散人老师 </a>，如有需要可前往原文预览查看。</h3></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://maple-214.cn">泽枫</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://maple-214.cn/article/30791/">https://maple-214.cn/article/30791/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://maple-214.cn" target="_blank">澤楓の小屋</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%89%8D%E7%AB%AF/">前端</a><a class="post-meta__tags" href="/tags/TypeScript/">TypeScript</a></div><div class="post_share"><div class="social-share" data-image="/img/cover/cover_03.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/qrCode/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/qrCode/wechat.jpg" alt="wechat"></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/qrCode/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/qrCode/alipay.jpg" alt="alipay"></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/article/59398/" title="1-6、基础篇：对象类型"><img class="cover" src="/img/cover/cover_03.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">1-6、基础篇：对象类型</div></div></a></div><div class="next-post pull-right"><a href="/article/23966/" title="1-4、基础篇：类型缩小"><img class="cover" src="/img/cover/cover_03.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">1-4、基础篇：类型缩小</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/article/8074/" title="1-1、基础篇：TypeScript介绍"><img class="cover" src="/img/cover/cover_02.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-26</div><div class="title">1-1、基础篇：TypeScript介绍</div></div></a></div><div><a href="/article/19978/" title="1-3、基础篇：常用类型"><img class="cover" src="/img/cover/cover_02.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-26</div><div class="title">1-3、基础篇：常用类型</div></div></a></div><div><a href="/article/20247/" title="1-2、基础篇：TypeScript入门"><img class="cover" src="/img/cover/cover_01.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-26</div><div class="title">1-2、基础篇：TypeScript入门</div></div></a></div><div><a href="/article/23966/" title="1-4、基础篇：类型缩小"><img class="cover" src="/img/cover/cover_03.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-26</div><div class="title">1-4、基础篇：类型缩小</div></div></a></div><div><a href="/article/59398/" title="1-6、基础篇：对象类型"><img class="cover" src="/img/cover/cover_03.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-26</div><div class="title">1-6、基础篇：对象类型</div></div></a></div><div><a href="/article/2401/" title="1-7、基础篇：类型操纵"><img class="cover" src="/img/cover/cover_03.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-26</div><div class="title">1-7、基础篇：类型操纵</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info__name">泽枫</div><div class="author-info__description">泽枫的小屋|泽枫的博客|maple|Maple|澤楓の博客|澤楓の小屋|前端</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">26</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">3</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E5%87%BD%E6%95%B0%E6%9B%B4%E5%A4%9A"><span class="toc-number">1.</span> <span class="toc-text">五、函数更多</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">1.1.</span> <span class="toc-text">5.1 函数类型表达式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-%E8%B0%83%E7%94%A8%E7%AD%BE%E5%90%8D"><span class="toc-number">1.2.</span> <span class="toc-text">5.2 调用签名</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-%E6%9E%84%E9%80%A0%E7%AD%BE%E5%90%8D"><span class="toc-number">1.3.</span> <span class="toc-text">5.3 构造签名</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-4-%E6%B3%9B%E5%9E%8B%E5%87%BD%E6%95%B0"><span class="toc-number">1.4.</span> <span class="toc-text">5.4 泛型函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-1-%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD"><span class="toc-number">1.4.1.</span> <span class="toc-text">5.4.1 类型推断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-2-%E9%99%90%E5%88%B6%E6%9D%A1%E4%BB%B6"><span class="toc-number">1.4.2.</span> <span class="toc-text">5.4.2 限制条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-3-%E4%BD%BF%E7%94%A8%E5%8F%97%E9%99%90%E5%80%BC"><span class="toc-number">1.4.3.</span> <span class="toc-text">5.4.3 使用受限值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-4-%E6%8C%87%E5%AE%9A%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0"><span class="toc-number">1.4.4.</span> <span class="toc-text">5.4.4 指定类型参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-5-%E7%BC%96%E5%86%99%E4%BC%98%E7%A7%80%E9%80%9A%E7%94%A8%E5%87%BD%E6%95%B0%E7%9A%84%E5%87%86%E5%88%99"><span class="toc-number">1.4.5.</span> <span class="toc-text">5.4.5 编写优秀通用函数的准则</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-5-%E5%8F%AF%E9%80%89%E5%8F%82%E6%95%B0"><span class="toc-number">1.5.</span> <span class="toc-text">5.5 可选参数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5-1-%E5%9B%9E%E8%B0%83%E4%B8%AD%E7%9A%84%E5%8F%AF%E9%80%89%E5%8F%82%E6%95%B0"><span class="toc-number">1.5.1.</span> <span class="toc-text">5.5.1 回调中的可选参数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-6-%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD"><span class="toc-number">1.6.</span> <span class="toc-text">5.6 函数重载</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-6-1-%E9%87%8D%E8%BD%BD%E7%AD%BE%E5%90%8D%E5%92%8C%E5%AE%9E%E7%8E%B0%E7%AD%BE%E5%90%8D"><span class="toc-number">1.6.1.</span> <span class="toc-text">5.6.1 重载签名和实现签名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-6-2-%E7%BC%96%E5%86%99%E5%A5%BD%E7%9A%84%E9%87%8D%E8%BD%BD"><span class="toc-number">1.6.2.</span> <span class="toc-text">5.6.2 编写好的重载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-6-3-%E5%87%BD%E6%95%B0%E5%86%85This%E7%9A%84%E5%A3%B0%E6%98%8E"><span class="toc-number">1.6.3.</span> <span class="toc-text">5.6.3 函数内This的声明</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-7-%E9%9C%80%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%84%E5%85%B6%E4%BB%96%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.7.</span> <span class="toc-text">5.7 需要了解的其他类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-7-1-void"><span class="toc-number">1.7.1.</span> <span class="toc-text">5.7.1 void</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-7-2-object"><span class="toc-number">1.7.2.</span> <span class="toc-text">5.7.2 object</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-7-3-unknown"><span class="toc-number">1.7.3.</span> <span class="toc-text">5.7.3 unknown</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-7-4-never"><span class="toc-number">1.7.4.</span> <span class="toc-text">5.7.4 never</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-7-5-Function"><span class="toc-number">1.7.5.</span> <span class="toc-text">5.7.5 Function</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-8-%E5%8F%82%E6%95%B0%E5%B1%95%E5%BC%80%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.8.</span> <span class="toc-text">5.8 参数展开运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-8-1-%E5%BD%A2%E5%8F%82%E5%B1%95%E5%BC%80-Rest-Parameters"><span class="toc-number">1.8.1.</span> <span class="toc-text">5.8.1 形参展开(Rest Parameters)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-8-2-%E5%AE%9E%E5%8F%82%E5%B1%95%E5%BC%80-Rest-Arguments"><span class="toc-number">1.8.2.</span> <span class="toc-text">5.8.2 实参展开(Rest Arguments)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-9-%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%84"><span class="toc-number">1.9.</span> <span class="toc-text">5.9 参数解构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-10-%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%AF%E5%88%86%E9%85%8D%E6%80%A7"><span class="toc-number">1.10.</span> <span class="toc-text">5.10 函数的可分配性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-10-1-%E8%BF%94%E5%9B%9E-void-%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.10.1.</span> <span class="toc-text">5.10.1 返回 void 类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E5%88%AB%E5%A3%B0%E6%98%8E-%E6%9C%AC%E6%96%87%E8%BD%AC%E8%87%AA-%E5%8F%A4%E8%89%BA%E6%95%A3%E4%BA%BA%E8%80%81%E5%B8%88-%EF%BC%8C%E5%A6%82%E6%9C%89%E9%9C%80%E8%A6%81%E5%8F%AF%E5%89%8D%E5%BE%80%E5%8E%9F%E6%96%87%E9%A2%84%E8%A7%88%E6%9F%A5%E7%9C%8B%E3%80%82"><span class="toc-number">1.10.2.</span> <span class="toc-text">特别声明: 本文转自 古艺散人老师 ，如有需要可前往原文预览查看。</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/article/16495/" title="1-1、CSS中hover时出现抖动的原因和解决方法"><img src="/img/cover/cover_02.jpeg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="1-1、CSS中hover时出现抖动的原因和解决方法"></a><div class="content"><a class="title" href="/article/16495/" title="1-1、CSS中hover时出现抖动的原因和解决方法">1-1、CSS中hover时出现抖动的原因和解决方法</a><time datetime="2024-01-26T12:30:06.000Z" title="发表于 2024-01-26 20:30:06">2024-01-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/article/43000/" title="3-7、高级篇：声明合并"><img src="/img/cover/cover_02.jpeg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="3-7、高级篇：声明合并"></a><div class="content"><a class="title" href="/article/43000/" title="3-7、高级篇：声明合并">3-7、高级篇：声明合并</a><time datetime="2024-01-26T12:24:54.000Z" title="发表于 2024-01-26 20:24:54">2024-01-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/article/19249/" title="3-6、高级篇：命名空间与模块"><img src="/img/cover/cover_02.jpeg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="3-6、高级篇：命名空间与模块"></a><div class="content"><a class="title" href="/article/19249/" title="3-6、高级篇：命名空间与模块">3-6、高级篇：命名空间与模块</a><time datetime="2024-01-26T12:23:45.000Z" title="发表于 2024-01-26 20:23:45">2024-01-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/article/52849/" title="3-5、高级篇：命名空间"><img src="/img/cover/cover_02.jpeg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="3-5、高级篇：命名空间"></a><div class="content"><a class="title" href="/article/52849/" title="3-5、高级篇：命名空间">3-5、高级篇：命名空间</a><time datetime="2024-01-26T12:23:06.000Z" title="发表于 2024-01-26 20:23:06">2024-01-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/article/3652/" title="3-4、高级篇：模块解析"><img src="/img/cover/cover_01.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="3-4、高级篇：模块解析"></a><div class="content"><a class="title" href="/article/3652/" title="3-4、高级篇：模块解析">3-4、高级篇：模块解析</a><time datetime="2024-01-26T12:22:08.000Z" title="发表于 2024-01-26 20:22:08">2024-01-26</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div id="ft"><img class="ft-img" src="/img/favicon.png" alt="" srcset=""></div><div class="copyright">&copy;2020 - 2024 <i id="heartbeat" class="fa fas fa-heartbeat"></i> 泽枫</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简体</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.12.0"></script><script src="/js/main.js?v=4.12.0"></script><script src="/js/tw_cn.js?v=4.12.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.32/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.js"></script><script>function panguFn(){"object"==typeof pangu?pangu.autoSpacingPage():getScript("https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js").then(()=>{pangu.autoSpacingPage()})}function panguInit(){GLOBAL_CONFIG_SITE.isPost&&panguFn()}document.addEventListener("DOMContentLoaded",panguInit)</script><div class="js-pjax"></div><script type="text/javascript" src="/js/src/jquery.js"></script><script type="text/javascript" src="/js/src/vue.js"></script><script type="text/javascript" src="/js/src/vue_js.js"></script><script type="text/javascript" src="/js/src/nav.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/fireworks.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span> 数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.12.0"></script></div></div><script data-pjax>var parent,child;document.getElementById("recent-posts")&&"/"==location.pathname&&(parent=document.getElementById("recent-posts")).insertAdjacentHTML("afterbegin",child='<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms"><div class="blog-slider__img blog-slider__custom_img"><img src="/img/recommend/recommend_06.jpg" alt="/img/recommend/recommend_06.jpg"/></div><div class="blog-slider__content"><span class="blog-slider__code">2024-01-26</span><a class="blog-slider__title" href="article/8074/">1-1、基础篇：TypeScript介绍</a><div class="blog-slider__text">1-1、基础篇：TypeScript介绍</div><a class="blog-slider__button" href="article/8074/">详情</a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms"><div class="blog-slider__img blog-slider__custom_img"><img src="/img/recommend/recommend_05.jpg" alt="/img/recommend/recommend_05.jpg"/></div><div class="blog-slider__content"><span class="blog-slider__code">2024-01-26</span><a class="blog-slider__title" href="article/20247/">1-2、基础篇：TypeScript入门</a><div class="blog-slider__text">1-2、基础篇：TypeScript入门</div><a class="blog-slider__button" href="article/20247/">详情</a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms"><div class="blog-slider__img blog-slider__custom_img"><img src="/img/recommend/recommend_04.jpg" alt="/img/recommend/recommend_04.jpg"/></div><div class="blog-slider__content"><span class="blog-slider__code">2024-01-26</span><a class="blog-slider__title" href="article/19978/">1-3、基础篇：常用类型</a><div class="blog-slider__text">1-3、基础篇：常用类型</div><a class="blog-slider__button" href="article/19978/">详情</a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms"><div class="blog-slider__img blog-slider__custom_img"><img src="/img/recommend/recommend_03.jpg" alt="/img/recommend/recommend_03.jpg"/></div><div class="blog-slider__content"><span class="blog-slider__code">2024-01-26</span><a class="blog-slider__title" href="article/23966/">1-4、基础篇：类型缩小</a><div class="blog-slider__text">1-4、基础篇：类型缩小</div><a class="blog-slider__button" href="article/23966/">详情</a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms"><div class="blog-slider__img blog-slider__custom_img"><img src="/img/recommend/recommend_02.jpg" alt="/img/recommend/recommend_02.jpg"/></div><div class="blog-slider__content"><span class="blog-slider__code">2024-01-26</span><a class="blog-slider__title" href="article/30791/">1-5、基础篇：函数更多</a><div class="blog-slider__text">1-5、基础篇：函数更多</div><a class="blog-slider__button" href="article/30791/">详情</a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms"><div class="blog-slider__img blog-slider__custom_img"><img src="/img/recommend/recommend_01.jpg" alt="/img/recommend/recommend_01.jpg"/></div><div class="blog-slider__content"><span class="blog-slider__code">2024-01-26</span><a class="blog-slider__title" href="article/59398/">1-6、基础篇：对象类型</a><div class="blog-slider__text">1-6、基础篇：对象类型</div><a class="blog-slider__button" href="article/59398/">详情</a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>')</script><script data-pjax src="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-swiper/swiper/swiper.min.js"></script><script data-pjax src="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-swiper@0.18/swiper/swiperindex.js"></script><style></style></body></html>