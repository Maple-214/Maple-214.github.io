<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"><title>1-4、基本：TypeScriptの型削減.md | 澤楓の小屋</title><meta name="author" content="泽枫"><meta name="copyright" content="泽枫"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="四、類型縮小padLeft という関数があるとします： function padLeft(padding: number | string, input: string): string &#123;  throw new Error(&quot;まだ実装されていません！&quot;);&#125;  機能を拡張してみましょう。 padding が number の場合、 input に追加するス"><meta property="og:type" content="article"><meta property="og:title" content="1-4、基本：TypeScriptの型削減.md"><meta property="og:url" content="https://maple-214.cn/article/53859/index.html"><meta property="og:site_name" content="澤楓の小屋"><meta property="og:description" content="四、類型縮小padLeft という関数があるとします： function padLeft(padding: number | string, input: string): string &#123;  throw new Error(&quot;まだ実装されていません！&quot;);&#125;  機能を拡張してみましょう。 padding が number の場合、 input に追加するス"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://maple-214.cn/img/cover/cover_03.jpg"><meta property="article:published_time" content="2024-02-15T07:49:54.000Z"><meta property="article:modified_time" content="2024-02-15T08:09:07.372Z"><meta property="article:author" content="泽枫"><meta property="article:tag" content="フロントエンド"><meta property="article:tag" content="TypeScript"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://maple-214.cn/img/cover/cover_03.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://maple-214.cn/article/53859/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//www.google-analytics.com" crossorigin=""><link rel="preconnect" href="//hm.baidu.com"><link rel="preconnect" href="//busuanzi.ibruce.info"><meta name="google-site-verification" content="OAauFcQX49kS2UGN9SShSqwNxfrsByxSVXRfNyc"><meta name="baidu-site-verification" content="codeva-sqk4wSuGXc"><link rel="stylesheet" href="/css/index.css?v=4.12.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.32/dist/fancybox/fancybox.min.css" media="print" onload='this.media="all"'><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script"),t=(e.src="https://hm.baidu.com/hm.js?6df43866b91212ab3dbadbcfd5966f6c",document.getElementsByTagName("script")[0]);t.parentNode.insertBefore(e,t)}()</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-FZNMK725WD"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-FZNMK725WD")</script><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"/search.xml",preload:!0,top_n_per_article:1,unescape:!1,languages:{hits_empty:"找不到您查询的内容：${query}",hits_stats:"共找到 ${hits} 篇文章"}},translate:void 0,noticeOutdate:void 0,highlight:{plugin:"highlight.js",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:150},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"",dateSuffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:{limitCount:50,languages:{author:"作者: 泽枫",link:"链接: ",source:"来源: 澤楓の小屋",info:"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},lightbox:"fancybox",Snackbar:{chs_to_cht:"你已切换为繁体中文",cht_to_chs:"你已切换为简体中文",day_to_night:"你已切换为深色模式",night_to_day:"你已切换为浅色模式",bgLight:"#49b1f5",bgDark:"#1f1f1f",position:"top-center"},infinitegrid:{js:"https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.0/dist/infinitegrid.min.js",buttonText:"加载更多"},isPhotoFigcaption:!0,islazyload:!1,isAnchor:!1,percent:{toc:!0,rightside:!0},autoDarkmode:!1}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"1-4、基本：TypeScriptの型削減.md",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2024-02-15 16:09:07"}</script><script>(e=>{e.saveToLocal={set:(e,t,a)=>{var o;0!==a&&(o=Date.now(),localStorage.setItem(e,JSON.stringify({value:t,expiry:o+864e5*a})))},get:e=>{var t=localStorage.getItem(e);if(t){t=JSON.parse(t);if(!(Date.now()>t.expiry))return t.value;localStorage.removeItem(e)}}},e.getScript=(o,n={})=>new Promise((t,e)=>{const a=document.createElement("script");a.src=o,a.async=!0,a.onerror=e,a.onload=a.onreadystatechange=function(){var e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(a.onload=a.onreadystatechange=null,t())},Object.keys(n).forEach(e=>{a.setAttribute(e,n[e])}),document.head.appendChild(a)}),e.getCSS=(o,n=!1)=>new Promise((t,e)=>{const a=document.createElement("link");a.rel="stylesheet",a.href=o,n&&(a.id=n),a.onerror=e,a.onload=a.onreadystatechange=function(){var e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(a.onload=a.onreadystatechange=null,t())},document.head.appendChild(a)}),e.activateDarkMode=()=>{document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=()=>{document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};e=saveToLocal.get("theme"),"dark"===e?activateDarkMode():"light"===e&&activateLightMode(),e=saveToLocal.get("aside-status");void 0!==e&&("hide"===e?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"));/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})(window)</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-swiper/swiper/swiper.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-swiper/swiper/swiperstyle.css"><meta name="generator" content="Hexo 7.1.1"><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head><body><script async src="/js/src/sakura.js"></script><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{const d=document.getElementById("loading-box"),e=document.body,n={endLoading:()=>{e.style.overflow="",d.classList.add("loaded")},initLoading:()=>{e.style.overflow="hidden",d.classList.remove("loaded")}};n.initLoading(),window.addEventListener("load",()=>{n.endLoading()}),document.addEventListener("pjax:send",()=>{n.initLoading()}),document.addEventListener("pjax:complete",()=>{n.endLoading()})})()</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">31</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">4</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><hr class="custom-hr"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-language"></i><span> Language</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="javascript:CustomEvent.selectLangHandler('/')"><i class="fa-fw fas fa-e"></i><span> English</span></a></li><li><a class="site-page child" href="javascript:CustomEvent.selectLangHandler('/categories/日本語/')"><i class="fa-fw fas fa-j"></i><span> 日本語</span></a></li></ul></div></div></div></div><div id="root"><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image:url(/img/cover/cover_03.jpg)"><nav id="nav"><span id="blog-info"><a href="/" title="澤楓の小屋">澤楓の小屋</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-language"></i><span> Language</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="javascript:CustomEvent.selectLangHandler('/')"><i class="fa-fw fas fa-e"></i><span> English</span></a></li><li><a class="site-page child" href="javascript:CustomEvent.selectLangHandler('/categories/日本語/')"><i class="fa-fw fas fa-j"></i><span> 日本語</span></a></li></ul></div></div><center id="name-container"><a id="page-name" href="javascript:CustomEvent.scrollToTop()">PAGE_NAME</a></center></div><div id="nav-right"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">1-4、基本：TypeScriptの型削減.md</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-02-15T07:49:54.000Z" title="发表于 2024-02-15 15:49:54">2024-02-15</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-02-15T08:09:07.372Z" title="更新于 2024-02-15 16:09:07">2024-02-15</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%97%A5%E6%9C%AC%E8%AA%9E/">日本語</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%97%A5%E6%9C%AC%E8%AA%9E/TypeScript/">TypeScript</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title="1-4、基本：TypeScriptの型削減.md"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="四、類型縮小"><a href="#四、類型縮小" class="headerlink" title="四、類型縮小"></a>四、類型縮小</h1><p><code>padLeft</code> という関数があるとします：</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">padLeft</span>(<span class="params">padding: <span class="built_in">number</span> | <span class="built_in">string</span>, input: <span class="built_in">string</span></span>): <span class="built_in">string</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;まだ実装されていません！&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>機能を拡張してみましょう。 <code>padding</code> が <code>number</code> の場合、 <code>input</code> に追加するスペースの数として扱われます、 <code>padding</code> が <code>string</code> であれば、 <code>input</code> 上にのみ <code>padding</code> を実行する。次のことを実現してみましょう：</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">padLeft</span>(<span class="params">padding: <span class="built_in">number</span> | <span class="built_in">string</span>, input: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Array</span>(padding + <span class="number">1</span>).<span class="title function_">join</span>(<span class="string">&quot; &quot;</span>) + input;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/img/TypeScript/04-01.png" alt="image-20211114161343249"></p><p>ああ、 <code>padding + 1</code> でエラーが発生しました。TypeScriptは、演算子 <code>+</code> をタイプ <code>string | number</code> および <code>number</code> に適用できないことを警告していますが、これは正しいです。言い換えれば、 <code>padding</code> が <code>number</code> であるかどうかを明確にチェックしたり、 <code>string</code> である場合に対処したりしていないので、このようにします：</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">padLeft</span>(<span class="params">padding: <span class="built_in">number</span> | <span class="built_in">string</span>, input: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> padding === <span class="string">&quot;number&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Array</span>(padding + <span class="number">1</span>).<span class="title function_">join</span>(<span class="string">&quot; &quot;</span>) + input;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> padding + input;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>このほとんどが面白くないJavaScriptコードのように見えるなら、これもポイントになるでしょう。設定した注釈を除けば、このTypeScriptコードはJavaScriptのように見えます。私たちの考えでは、TypeScriptの型システムは、型セキュリティを獲得するために身をかがめる必要がなく、典型的なJavaScriptコードをできるだけ簡単に記述できるように設計されています。</p><p>あまり多くないように見えますが、実はたくさんのものがここにあります。TypeScriptが静的型を使用して実行時の値を分析するのと同様に、JavaScriptの実行時制御フロー構造に、if&#x2F;else、条件トリプル、ループ、信頼性チェックなどの型の分析を重ねます。</p><p>私たちのifチェックでは、TypeScriptは <code>typeof padding ===&quot;number&quot;</code> と認識し、タイプ保護と呼ばれる特殊な形式のコードとして認識します。TypeScriptは、特定の場所にある値の最も具体的な型を分析するために、プログラムが取り得る実行パスに従います。これらの特殊なチェック(型保護と呼ばれる)と代入を見て、宣言された型よりも具体的な型に型を細分化するプロセスを絞り込みと呼びます。多くのエディタでは、これらの種類の変化を見ることができますし、私たちの例でもそうします。</p><p>TypeScriptは、いくつかの異なる縮小構造を理解することができます。</p><h2 id="4-1-typeof-タイプガード"><a href="#4-1-typeof-タイプガード" class="headerlink" title="4.1 typeof タイプガード"></a>4.1 <code>typeof</code> タイプガード</h2><p>ここまで見てきたように、JavaScriptは <code>typeof</code> 演算子をサポートしています。この演算子は、実行時に所有する値の種類に関する非常に基本的な情報を提供します。TypeScriptは、特定の文字列のセットを返すことを期待します：</p><ul><li><code>&quot;string&quot;</code></li><li><code>&quot;number&quot;</code></li><li><code>&quot;bigint&quot;</code></li><li><code>&quot;boolean&quot;</code></li><li><code>&quot;symbol&quot;</code></li><li><code>&quot;undefined&quot;</code></li><li><code>&quot;object&quot;</code></li><li><code>&quot;function&quot;</code></li></ul><p><code>padLeft</code> に見られるように、この演算子は多くのJavaScriptライブラリによく登場します。TypeScriptは、さまざまな分岐にある型を絞り込むものとして理解できます。</p><p>TypeScriptでは、 <code>typeof</code> の戻り値をチェックすることが保護型です。TypeScriptは、 <code>typeof</code> アクションをエンコードして異なる値を返すので、JavaScriptに何が行われたかを知っています。たとえば、上のリストでは、 <code>typeof</code> はstring <code>null</code> を返さないことに注意してください。次の例を参照してください：</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">printAll</span>(<span class="params">strs: <span class="built_in">string</span> | <span class="built_in">string</span>[] | <span class="literal">null</span></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> strs === <span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> s <span class="keyword">of</span> strs) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(s);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> strs === <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(strs);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://s2.loli.net/2022/02/22/vqyDfKRPZkdzX7j.png" alt="image-20211114164143361" style="zoom:50%"><p>関数 <code>printAll</code> では、配列型であるかどうかを調べる代わりに、 <code>strs</code> がオブジェクトであるかどうかを調べてみます(配列がJavaScriptのオブジェクト型であることを強調するのに適したタイミングかもしれません)。しかし、JavaScriptでは、 <code>typeof null</code> も実際には <code>&quot;object&quot;</code> であることが判明しました。歴史上の不幸な事故の一つだ。</p><p>十分な経験を持つユーザーは驚かないかもしれませんが、誰もがJavaScriptでこのような状況に遭遇したことがあるわけではありません。幸いなことに、typescriptは、 <code>strs</code> が <code>string[]</code> だけではなく、 <code>string[] | null</code> に縮小されることを示しています。</p><p>これは、いわゆる「真正性」チェックへの良い移行といえるかもしれません。</p><h2 id="4-2真理値の縮小"><a href="#4-2真理値の縮小" class="headerlink" title="4.2真理値の縮小"></a>4.2真理値の縮小</h2><p>真理値チェックはJavaScriptでよくやっていることです。JavaScriptでは、条件、 <code>&amp;&amp;</code>、 <code>||</code>、 <code>if</code> ステートメント、ブール否定( <code>!</code>)などの任意の式を使用できます。たとえば、 <code>if</code> ステートメントでは、条件が常に <code>boolean</code> 型になることは想定していません。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getUsersOnlineMessage</span>(<span class="params">numUsersOnline: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (numUsersOnline) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`「合計 <span class="subst">$&#123;numUsersOnline&#125;</span> 人が現在オンラインです!」`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;今は誰もオンラインにいません. :(&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JavaScriptでは、このような <code>if</code> 条件ステートメントは、まず条件「強制」を <code>boolean</code> に変換して意味を持たせ、その結果が <code>true</code> であるか <code>false</code> であるかによって分岐を選択します。このような面の値は次のようになります：</p><ul><li><code>0</code></li><li><code>NaN</code></li><li><code>&quot;&quot;</code> (空の文字列)</li><li><code>0n</code> ( <code>bigint</code> ゼロのバージョン)</li><li><code>null</code></li><li><code>undefined</code></li></ul><p>これらの値は強制的に <code>false</code> に変換され、その他の値は強制的に <code>true</code> に変換されます。関数 <code>Boolean</code> で値を実行して <code>boolean</code> を取得するか、短い二重ブール否定を使用して値を強制的に <code>boolean</code> に変換することができます。(後者の利点は、TypeScriptが狭いリテラルのboolean型 <code>true</code> を推定し、最初の型を <code>boolean</code> と推定することです)。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// どちらの結果も true を返します</span></span><br><span class="line"><span class="title class_">Boolean</span>(<span class="string">&quot;hello&quot;</span>); <span class="comment">// type: boolean, value: true</span></span><br><span class="line">!!<span class="string">&quot;world&quot;</span>; <span class="comment">// type: true, value: true</span></span><br></pre></td></tr></table></figure><p>この動作を利用することは、特に <code>null</code> や <code>undefined</code> などの値を防ぐ場合には、非常に一般的である。たとえば、この関数を <code>printAll</code> 関数で使用してみましょう。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">printAll</span>(<span class="params">strs: <span class="built_in">string</span> | <span class="built_in">string</span>[] | <span class="literal">null</span></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (strs &amp;&amp; <span class="keyword">typeof</span> strs === <span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> s <span class="keyword">of</span> strs) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(s);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> strs === <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(strs);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>strs</code> が真であるかどうかをチェックすることで、上記のエラーを解消したことにお気づきでしょう。これにより、コードの実行時に次のような恐ろしいエラーが発生するのを防ぐことができます：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">TypeError: null is not iterable</span><br></pre></td></tr></table></figure><p>ただし、プリミティブの真理値チェックはしばしば誤りやすいことを覚えておいてください。たとえば、 <code>printAll</code> を上書きすることを考えてみましょう。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">printAll</span>(<span class="params">strs: <span class="built_in">string</span> | <span class="built_in">string</span>[] | <span class="literal">null</span></span>) &#123;</span><br><span class="line">  <span class="comment">// !!!!!!!!!!!!!!!!</span></span><br><span class="line">  <span class="comment">// そんなことしたらダメ！</span></span><br><span class="line">  <span class="comment">// 理由は以下の通り</span></span><br><span class="line">  <span class="comment">// !!!!!!!!!!!!!!!!</span></span><br><span class="line">  <span class="keyword">if</span> (strs) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> strs === <span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> s <span class="keyword">of</span> strs) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(s);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> strs === <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(strs);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>関数本体全体を実際の検査でラッピングしましたが、空の文字列を正しく処理できなくなるという小さな欠点があります。</p><p>TypeScriptはここではまったく間違いを報告しませんが、JavaScriptに詳しくない方は注意すべき行動です。TypeScriptは通常、エラーを早期に発見するのに役立ちますが、ある値を<em>任意</em>処理しないように選択した場合には、論理的な問題をあまり考慮することなく、これだけのことができます。必要に応じて、linter(プログラムの正規化)を使用してこのような状況に対処することができます。</p><p>真正性による絞り込みの最後の点については、論理を否定枝からブール否定 <code>!</code> でフィルタリングすることである。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">multiplyAll</span>(<span class="params"></span></span><br><span class="line"><span class="params">  values: <span class="built_in">number</span>[] | <span class="literal">undefined</span>,</span></span><br><span class="line"><span class="params">  factor: <span class="built_in">number</span>,</span></span><br><span class="line"><span class="params"></span>): <span class="built_in">number</span>[] | <span class="literal">undefined</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!values) &#123;</span><br><span class="line">    <span class="keyword">return</span> values;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> values.<span class="title function_">map</span>(<span class="function">(<span class="params">x</span>) =&gt;</span> x * factor);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-3等価縮小"><a href="#4-3等価縮小" class="headerlink" title="4.3等価縮小"></a>4.3等価縮小</h2><p>typescriptも分岐文を用いて <code>===</code>、 <code>!==</code>、 <code>==</code>、および <code>!=</code> などの値検査を行い、型の絞り込みを実現している。例：</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">example</span>(<span class="params">x: <span class="built_in">string</span> | <span class="built_in">number</span>, y: <span class="built_in">string</span> | <span class="built_in">boolean</span></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (x === y) &#123;</span><br><span class="line">    <span class="comment">// これで、x、y で文字列型のメソッドを呼び出すことができます。</span></span><br><span class="line">    x.<span class="title function_">toUpperCase</span>();</span><br><span class="line">    y.<span class="title function_">toLowerCase</span>();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(x);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(y);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上記の例で <code>x</code> と <code>y</code> が等しいかどうかを調べたとき、TypeScriptはそれらの型も等しくなければならないことを認識しています。 <code>string</code> は、 <code>x</code> と <code>y</code> の両方で使用できる唯一の一般的な型なので、TypeScriptは、 <code>x</code> と <code>y</code> がいずれも <code>string</code> の場合、プログラムは最初の分岐に進みます。</p><p>変数ではなく、特定のリテラル値をチェックすることも有効です。真理値の絞り込みについてのセクションでは、空の文字列を正しく処理していないため、エラーが発生しやすい関数 <code>printAll</code> を書きました。代わりに、特定のチェックをして <code>null</code> をブロックし、TypeScriptが <code>strs</code> から <code>null</code> を正しく削除したままにすることができます。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">printAll</span>(<span class="params">strs: <span class="built_in">string</span> | <span class="built_in">string</span>[] | <span class="literal">null</span></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (strs !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> strs === <span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> s <span class="keyword">of</span> strs) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(s);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> strs === <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(strs);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JavaScriptのより緩やかな同等性チェック <code>==</code> および <code>!=</code> も、適切に縮小されます。変数が <code>== null</code> であるかどうかを調べる方法に慣れていない場合は、それが特定の値 <code>null</code> であるかどうかだけでなく、 <code>undefined</code> であるかもしれないかどうかも調べる必要があるので、どのようにして <code>== null</code> であるかどうかを調べる必要があります。これは <code>== undefined</code> にも当てはまります。値が <code>null</code> または <code>undefined</code> であるかどうかがチェックされます。ここでは、この <code>==</code> と <code>!=</code> だけで済ませることができます。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Container</span> &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="built_in">number</span> | <span class="literal">null</span> | <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">multiplyValue</span>(<span class="params">container: Container, factor: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">  <span class="comment">// 未定義と null を型から除外しました</span></span><br><span class="line">  <span class="keyword">if</span> (container.<span class="property">value</span> != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(container.<span class="property">value</span>);</span><br><span class="line">    <span class="comment">// これで、「container.value」を安全に乗算できるようになりました。</span></span><br><span class="line">    container.<span class="property">value</span> *= factor;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://s2.loli.net/2022/02/22/tkwKocVjWeRn3XN.png" alt="image-20211115154532180" style="zoom:50%"><p>最初の3つの印刷はパスしましたが、4番目に問題がありました。</p><h2 id="4-4-in-オペレータ縮小"><a href="#4-4-in-オペレータ縮小" class="headerlink" title="4.4 in オペレータ縮小"></a>4.4 <code>in</code> オペレータ縮小</h2><p>JavaScriptには、 <code>in</code> 演算子を使用して、オブジェクトに属性名があるかどうかを判断する演算子があります。TypeScriptはこの点を考慮して、潜在的なタイプを絞り込んでいます。</p><p>たとえば、コード <code>&quot;value&quot; in x</code> を使用します。ここで、 <code>&quot;value&quot;</code> は文字列リテラルであり、 <code>x</code> は結合型である。値が「true」の分岐は縮小されます。 <code>x</code> オプションまたは必須属性を持つタイプの値が必要です。値が「false」の分岐は縮小され、オプションまたは欠落した属性を持つタイプの値が必要になります。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Fish</span> = &#123; <span class="attr">swim</span>: <span class="function">() =&gt;</span> <span class="built_in">void</span> &#125;;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Bird</span> = &#123; <span class="attr">fly</span>: <span class="function">() =&gt;</span> <span class="built_in">void</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">move</span>(<span class="params">animal: Fish | Bird</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="string">&quot;swim&quot;</span> <span class="keyword">in</span> animal) &#123;</span><br><span class="line">    <span class="keyword">return</span> animal.<span class="title function_">swim</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> animal.<span class="title function_">fly</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>また、オプション属性は縮小の両側にも存在します。たとえば、人間は（適切な装置を使用して）泳いだり飛んだりできるため、 <code>in</code> チェックの両側に表示されます：</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Fish</span> = &#123; <span class="attr">swim</span>: <span class="function">() =&gt;</span> <span class="built_in">void</span> &#125;;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Bird</span> = &#123; <span class="attr">fly</span>: <span class="function">() =&gt;</span> <span class="built_in">void</span> &#125;;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Human</span> = &#123; swim?: <span class="function">() =&gt;</span> <span class="built_in">void</span>; fly?: <span class="function">() =&gt;</span> <span class="built_in">void</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">move</span>(<span class="params">animal: Fish | Bird | Human</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="string">&quot;swim&quot;</span> <span class="keyword">in</span> animal) &#123;</span><br><span class="line">    <span class="comment">// animal: Fish | Human</span></span><br><span class="line">    animal;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// animal: Bird | Human</span></span><br><span class="line">    animal;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-5-instanceof-オペレータ縮小"><a href="#4-5-instanceof-オペレータ縮小" class="headerlink" title="4.5 instanceof オペレータ縮小"></a>4.5 <code>instanceof</code> オペレータ縮小</h2><p>JavaScriptには、ある値が別の値の「インスタンス」であるかどうかをチェックする演算子 <code>instanceof</code> があります。具体的には、JavaScriptの <code>x instanceof Foo</code> で、 <code>x</code> の<em>プロトタイプチェーン</em>に <code>Foo.prototype</code> が含まれているかどうかをチェックします。ここでは詳しく説明しませんが、 <code>类(class)</code> の学習に入ると、その多くが <code>new</code> キーワードを使ってインスタンス化できることがわかります。すでにお気づきのように、 <code>instanceof</code> も型保護であり、TypeScriptは <code>instanceof</code> で保護されたブランチの縮小を実装します。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">logValue</span>(<span class="params">x: <span class="built_in">Date</span> | <span class="built_in">string</span></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (x <span class="keyword">instanceof</span> <span class="title class_">Date</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(x.<span class="title function_">toUTCString</span>());</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(x.<span class="title function_">toUpperCase</span>());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">logValue</span>(<span class="keyword">new</span> <span class="title class_">Date</span>()); <span class="comment">// Mon, 15 Nov 2021 22:34:37 GMT</span></span><br><span class="line"><span class="title function_">logValue</span>(<span class="string">&quot;hello ts&quot;</span>); <span class="comment">// HELLO TS</span></span><br></pre></td></tr></table></figure><h2 id="4-6配分の縮小"><a href="#4-6配分の縮小" class="headerlink" title="4.6配分の縮小"></a>4.6配分の縮小</h2><p>前述したように、任意の変数に値を割り当てると、TypeScriptは割り当てられた値の右側を確認し、左側を適切に縮小します。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// let x: string | number</span></span><br><span class="line"><span class="keyword">let</span> x = <span class="title class_">Math</span>.<span class="title function_">random</span>() &lt; <span class="number">0.5</span> ? <span class="number">10</span> : <span class="string">&quot;hello world!&quot;</span>;</span><br><span class="line"></span><br><span class="line">x = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// let x: number</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x);</span><br><span class="line"></span><br><span class="line">x = <span class="string">&quot;goodbye!&quot;</span>;</span><br><span class="line"><span class="comment">// let x: string</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x);</span><br></pre></td></tr></table></figure><p>これらの割り当てはそれぞれ有効であることに注意してください。最初の代入後に観測されたタイプ <code>x</code> が <code>number</code> に変更された場合でも、 <code>string</code> を <code>x</code> に代入することができます。これは、<em>宣言型</em>の <code>x</code> -このタイプ <code>x</code> は <code>string | number</code> で始まるためです。</p><p><code>x</code> に <code>boolean</code> を割り当てると、宣言型の一部ではないため、エラーが表示されます。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="title class_">Math</span>.<span class="title function_">random</span>() &lt; <span class="number">0.5</span> ? <span class="number">10</span> : <span class="string">&quot;hello world!&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// let x: string | number</span></span><br><span class="line">x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// let x: number</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x);</span><br><span class="line"></span><br><span class="line"><span class="comment">// エラー！</span></span><br><span class="line">x = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// let x: string | number</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x);</span><br></pre></td></tr></table></figure><img src="https://s2.loli.net/2022/02/22/iZFWjN4BkfKbdr2.png" alt="image-20211116065026159" style="zoom:50%"><h2 id="4-7制御フロー解析"><a href="#4-7制御フロー解析" class="headerlink" title="4.7制御フロー解析"></a>4.7制御フロー解析</h2><p>ここまで、いくつかの基本的な例を使って、TypeScriptが特定のブランチでどのように絞り込むかを説明してきました。しかし、各変数から出てきて、 <code>if</code>、 <code>while</code>、条件などで型保護を探す以外にも、やるべきことはたくさんあります。例：</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">padLeft</span>(<span class="params">padding: <span class="built_in">number</span> | <span class="built_in">string</span>, input: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> padding === <span class="string">&quot;number&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Array</span>(padding + <span class="number">1</span>).<span class="title function_">join</span>(<span class="string">&quot; &quot;</span>) + input;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> padding + input;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>padLeft</code> は、その最初の <code>if</code> ブロックから返されます。TypeScriptはこのコードを解析し、paddingが数値の場合、ボディの残りの部分( <code>return padding + input;</code>)が到達不可能であることを確認します。このため、関数の残りの部分で使用される <code>padding</code> 型から数値を削除(文字列数値から文字列に絞り込む)できます。</p><p>この到達可能性ベースのコード解析は制御フロー解析と呼ばれ、TypeScriptはタイプガードと代入に遭遇するため、このフロー解析を使用してタイプを絞り込みます。各点で異なる型が観察され得る変数を解析すると、制御フローを何度も分割して再結合することができる。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">example</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="attr">x</span>: <span class="built_in">string</span> | <span class="built_in">number</span> | <span class="built_in">boolean</span>;</span><br><span class="line"></span><br><span class="line">  x = <span class="title class_">Math</span>.<span class="title function_">random</span>() &lt; <span class="number">0.5</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// let x: boolean</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="title class_">Math</span>.<span class="title function_">random</span>() &lt; <span class="number">0.5</span>) &#123;</span><br><span class="line">    x = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="comment">// let x: string</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(x);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    x = <span class="number">100</span>;</span><br><span class="line">    <span class="comment">// let x: number</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(x);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// let x: string | number</span></span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> x = <span class="title function_">example</span>();</span><br><span class="line">x = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">x = <span class="number">100</span>;</span><br><span class="line">x = <span class="literal">true</span>; <span class="comment">// error</span></span><br></pre></td></tr></table></figure><img src="https://s2.loli.net/2022/02/22/hA2aRrP93TIBuOG.png" alt="image-20211117203742503" style="zoom:50%"><h2 id="4-8型述語の使用"><a href="#4-8型述語の使用" class="headerlink" title="4.8型述語の使用"></a>4.8型述語の使用</h2><p>ここまで、我々は既存のJavaScript構造体を用いてナローディングの問題に対処してきましたが、時にはコード全体の型の変化をより直接的に制御したいと思うことがあります。</p><p>ユーザ定義型保護を定義するには、戻り型が型述語である関数を定義するだけです。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Fish</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">swim</span>: <span class="function">() =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Bird</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">fly</span>: <span class="function">() =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isFish</span>(<span class="params">pet: Fish | Bird</span>): pet is <span class="title class_">Fish</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (pet <span class="keyword">as</span> <span class="title class_">Fish</span>).<span class="property">swim</span> !== <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>この例では、 <code>pet is Fish</code> が型述語です。述語の形式は <code>parameterName is Type</code> です。 <code>parameterName</code> は、現在の関数のシグネチャ内のパラメータ名である必要があります。</p><p><code>isFish</code> が呼び出されるたびに、TypeScriptは元の型が互換性を持っている場合、その変数を特定の型に絞り込みます。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getSmallPet</span>(<span class="params"></span>): <span class="title class_">Fish</span> | <span class="title class_">Bird</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="attr">fish</span>: <span class="title class_">Fish</span> = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;gold fish&quot;</span>,</span><br><span class="line">    <span class="attr">swim</span>: <span class="function">() =&gt;</span> &#123;&#125;,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> <span class="attr">bird</span>: <span class="title class_">Bird</span> = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;sparrow&quot;</span>,</span><br><span class="line">    <span class="attr">fly</span>: <span class="function">() =&gt;</span> &#123;&#125;,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span> ? bird : fish;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ペットのスイムとフライの両方にアクセスできます。</span></span><br><span class="line"><span class="keyword">let</span> pet = <span class="title function_">getSmallPet</span>();</span><br><span class="line"><span class="keyword">if</span> (<span class="title function_">isFish</span>(pet)) &#123;</span><br><span class="line">  pet.<span class="title function_">swim</span>();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  pet.<span class="title function_">fly</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TypeScriptは、 <code>pet</code> が <code>if</code> 分岐で魚であることを知っているだけではないことに注意してください。また、 <code>else</code> 枝に <code>Fish</code> がないことも知っているので、 <code>Bird</code> があるはずです。</p><p>型ガード <code>isFish</code> を使用して、 <code>Fish | Bird</code> の配列をフィルタリングし、 <code>Fish</code> の配列を得ることができます。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">zoo</span>: (<span class="title class_">Fish</span> | <span class="title class_">Bird</span>)[] = [<span class="title function_">getSmallPet</span>(), <span class="title function_">getSmallPet</span>(), <span class="title function_">getSmallPet</span>()];</span><br><span class="line"><span class="keyword">const</span> <span class="attr">underWater1</span>: <span class="title class_">Fish</span>[] = zoo.<span class="title function_">filter</span>(isFish);</span><br><span class="line"><span class="comment">// または、以下と同等</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">underWater2</span>: <span class="title class_">Fish</span>[] = zoo.<span class="title function_">filter</span>(isFish) <span class="keyword">as</span> <span class="title class_">Fish</span>[];</span><br><span class="line"></span><br><span class="line"><span class="comment">// より複雑な例では、述語を再利用する必要がある場合があります。</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">underWatch3</span>: <span class="title class_">Fish</span>[] = zoo.<span class="title function_">filter</span>((pet): pet is <span class="title class_">Fish</span> =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (pet.<span class="property">name</span> === <span class="string">&quot;frog&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">isFish</span>(pet);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="4-9差別された-unions"><a href="#4-9差別された-unions" class="headerlink" title="4.9差別された unions"></a>4.9差別された <code>unions</code></h2><p>これまで見てきた例のほとんどは、単純な型( <code>string</code>、 <code>boolean</code>、 <code>number</code> など)を使って個々の変数を絞り込むことを中心にしています。よくあることですが、JavaScriptでは少し複雑な構造体を扱うことが多いです。</p><p>インスピレーションを引き出すために、円形や四角などの形をコード化しようとしていると想像してみましょう。円は半径を表し、四角形は辺の長さを表します。 <code>kind</code> というフィールドを使用して、どの形状を扱っているかを示します。ここでは、 <code>Shape</code> を定義する最初の試みを行います。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">  <span class="attr">kind</span>: <span class="string">&quot;circle&quot;</span> | <span class="string">&quot;square&quot;</span>;</span><br><span class="line">  radius?: <span class="built_in">number</span>;</span><br><span class="line">  sideLength?: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>文字列リテラル型の結合を使用していることに注意してください。 <code>&quot;circle &quot;</code> と <code>&quot;square &quot;</code> はそれぞれ、この形状を円形とみなすべきか正方形とみなすべきかを示しています。 <code>string</code> ではなく <code>&quot;circle&quot; | &quot;square &quot;</code> を使用することで、スペルミスの問題を回避できます。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">handleShape</span>(<span class="params">shape: Shape</span>) &#123;</span><br><span class="line">  <span class="comment">// oops!</span></span><br><span class="line">  <span class="keyword">if</span> (shape.<span class="property">kind</span> === <span class="string">&quot;rect&quot;</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://s2.loli.net/2022/02/22/gN6Arztw5S2kFJm.png" alt="image-20211118090404099" style="zoom:50%"><p>関数 <code>getArea</code> を書いて、それが円か正方形かに応じて正しい論理を適用することができます。まず円形を試してみましょう。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getArea</span>(<span class="params">shape: Shape</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="property">PI</span> * shape.<span class="property">radius</span> ** <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://s2.loli.net/2022/02/22/fNEWpy8i3GdxTLO.png" alt="image-20211118091637002" style="zoom:50%"><p><code>strictNullChecks</code> では、これは私たちに間違いを与えます。 <code>radius</code> が定義されていない可能性があるので、これは適切です。しかし、 <code>kind</code> 属性を適切にチェックしたらどうでしょうか。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getArea</span>(<span class="params">shape: Shape</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (shape.<span class="property">kind</span> === <span class="string">&quot;circle&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="property">PI</span> * shape.<span class="property">radius</span> ** <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://s2.loli.net/2022/02/22/T76rqcQbF2utN4U.png" alt="image-20211118093134890" style="zoom:50%"><p>まあ、TypeScriptはまだどうすればいいのかわかりません。私たちは、タイプチェッカーが知っている以上に値を知っているという問題に直面しました。空ではないアサーション( <code>radius</code> の後にある感嘆符 <code>!</code>)を使用して、 <code>radius</code> が存在することを示すことができます。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getArea</span>(<span class="params">shape: Shape</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (shape.<span class="property">kind</span> === <span class="string">&quot;circle&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="property">PI</span> * shape.<span class="property">radius</span>! ** <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>しかしこの感じは理想的ではありません。空ではないアサーションを使用して、型チェッカーに感嘆符( <code>！</code>)を宣言し、 <code>shape.radius</code> が定義されていることを納得させる必要がありますが、コードを動かし始めると、これらのアサーションは間違いやすいでしょう。また、 <code>strictNullChecks</code> 以外では、これらのフィールドに誤ってアクセスすることもできます(これらのフィールドが読み込まれると、オプション属性が常に存在すると見なされるからです)。私たちは絶対にもっとうまくやることができます。</p><p>このような <code>Shape</code> のエンコーディングの問題は、タイプチェッカーが、クラス属性に基づいて <code>radius</code> または <code>sideLength</code> の存在を知る方法がないことです。私たちが知っていることをタイプチェッカーに伝える必要があります。そのことを考えて、Shapeをもう一度定義してみましょう。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Circle</span> &#123;</span><br><span class="line">  <span class="attr">kind</span>: <span class="string">&quot;circle&quot;</span>;</span><br><span class="line">  <span class="attr">radius</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Square</span> &#123;</span><br><span class="line">  <span class="attr">kind</span>: <span class="string">&quot;square&quot;</span>;</span><br><span class="line">  <span class="attr">sideLength</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Shape</span> = <span class="title class_">Circle</span> | <span class="title class_">Square</span>;</span><br></pre></td></tr></table></figure><p>ここでは、 <code>Shape</code> を2つのタイプに正しく分類し、 <code>kind</code> 属性に異なる値を設定していますが、 <code>radius</code> と <code>sideLength</code> はそれぞれのタイプで必須属性として宣言されています。</p><p>半径 <code>Shape</code> にアクセスしようとするとどうなるか見てみましょう。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getArea</span>(<span class="params">shape: Shape</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="property">PI</span> * shape.<span class="property">radius</span> ** <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://s2.loli.net/2022/02/22/ws1RYKDjvnQNxlC.png" alt="image-20211118180452972" style="zoom:50%"><p>最初に定義した <code>Shape</code> と同様に、これはまだ間違いです。半径がオプションの場合、TypeScriptではこのアトリビュートが存在するかどうかを判断できないため、エラーが発生しました( <code>strictNullChecks</code> のみ)。これで <code>Shape</code> がコンソーシアムになり、TypeScriptは <code>shape</code> が <code>Square</code> である可能性があることを示していますが、Squareは半径 <code>radius</code> を定義していません。どちらの解釈も正しいのですが、 <code>Shape</code> の新しいエンコーディングだけが、まだ <code>strictNullChecks</code> の外側でエラーが発生しています。</p><p>しかし、もう一度kind属性をチェックしてみたらどうでしょうか。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getArea</span>(<span class="params">shape: Shape</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (shape.<span class="property">kind</span> === <span class="string">&quot;circle&quot;</span>) &#123;</span><br><span class="line">    <span class="comment">// shape: Circle</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="property">PI</span> * shape.<span class="property">radius</span> ** <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>これで間違いから脱した！ <code>union</code> の各型にリテラル型と同じプロパティが含まれている場合、TypeScriptはそれを <code>union</code> と見なし、 <code>union</code> のメンバーを絞り込むことができます。</p><p>この場合、 <code>kind</code> がその共通属性である（これが <code>Shape</code> の判別属性である）。 <code>kind</code> 属性が <code>&quot;circle&quot;</code> であることを確認すると、 <code>Shape</code> 内の <code>&quot;circle&quot;</code> 型属性を持たないすべての型を除外できます。これにより、 <code>Shape</code> の範囲は <code>Circle</code> というタイプに絞られる。</p><p><code>switch</code> 文にも同じチェック方法が適用されます。ここでは、 <code>！</code> 空でないアサーションという嫌な感嘆符を付けずに、完全な <code>getArea</code> を書いてみましょう。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getArea</span>(<span class="params">shape: Shape</span>) &#123;</span><br><span class="line">  <span class="keyword">switch</span> (shape.<span class="property">kind</span>) &#123;</span><br><span class="line">    <span class="comment">// shape: Circle</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;circle&quot;</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="property">PI</span> * shape.<span class="property">radius</span> ** <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// shape: Square</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;square&quot;</span>:</span><br><span class="line">      <span class="keyword">return</span> shape.<span class="property">sideLength</span> ** <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ここで最も重要なのは、 <code>Shape</code> のエンコーディングである。 <code>Circle</code> と <code>Square</code> は、実際には特定の種類のフィールドを持つ2つの独立したタイプであるという正しい情報をTypeScriptに伝えることが重要です。このようにすることで、本来書くJavaScriptと変わらないように見えるタイプ安全なTypeScriptコードを書き出すことができます。そこから、型システムは「正しい」ことを行い、私たちの <code>switch</code> 文の各分岐内の型を見つけることができます。</p><blockquote><p>傍観者として、上記の例をプレイして、リターンキーワードをいくつか外してみてください。型チェックは、switchステートメントの中で誤って別の節に落とし込まれるバグを回避するのに役立ちます。</p></blockquote><p>弁証法的な連合体は、円形と四角の話をするだけではありません。ネットワーク上でメッセージを送信したり( <code>client/server</code> トラフィック)、状態管理フレームワークで突然変異をエンコードしたりするなど、JavaScriptであらゆるタイプのメッセージングスキームを表現するのに適しています。</p><h2 id="4-10-never-タイプおよび網羅性チェック"><a href="#4-10-never-タイプおよび網羅性チェック" class="headerlink" title="4.10 never タイプおよび網羅性チェック"></a>4.10 <code>never</code> タイプおよび網羅性チェック</h2><p>絞り込む際には、コンソーシアムの選択肢を、すべての可能性を削除して何も残らない程度に減らすことができます。このような場合、TypeScriptは <code>never</code> 型を使用して、存在してはならない状態を表します。</p><p><code>never</code> 型は各型に割り当てることができます。ただし、neverに割り当てることができる型はありません(never自体を除く)。つまり、 <code>switch</code> 文では、縮小して <code>never</code> に依存する出現を使用して詳細なチェックを行うことができます。</p><p>たとえば、関数 <code>getArea</code> にデフォルト値を追加して、形状を <code>never</code> に割り当てようとすると、可能なすべての状況が処理されなかったときに送出されます。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Shape</span> = <span class="title class_">Circle</span> | <span class="title class_">Square</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getArea</span>(<span class="params">shape: Shape</span>) &#123;</span><br><span class="line">  <span class="keyword">switch</span> (shape.<span class="property">kind</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;circle&quot;</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="property">PI</span> * shape.<span class="property">radius</span> ** <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;square&quot;</span>:</span><br><span class="line">      <span class="keyword">return</span> shape.<span class="property">sideLength</span> ** <span class="number">2</span>;</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      <span class="keyword">const</span> <span class="attr">_exhaustiveCheck</span>: <span class="built_in">never</span> = shape;</span><br><span class="line">      <span class="keyword">return</span> _exhaustiveCheck;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Shape</code> フェデレーションに新しいメンバを追加すると、TypeScriptエラーが発生します。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Triangle</span> &#123;</span><br><span class="line">  <span class="attr">kind</span>: <span class="string">&quot;triangle&quot;</span>;</span><br><span class="line">  <span class="attr">sideLength</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Shape</span> = <span class="title class_">Circle</span> | <span class="title class_">Square</span> | <span class="title class_">Triangle</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getArea</span>(<span class="params">shape: Shape</span>) &#123;</span><br><span class="line">  <span class="keyword">switch</span> (shape.<span class="property">kind</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;circle&quot;</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="property">PI</span> * shape.<span class="property">radius</span> ** <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;square&quot;</span>:</span><br><span class="line">      <span class="keyword">return</span> shape.<span class="property">sideLength</span> ** <span class="number">2</span>;</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      <span class="keyword">const</span> <span class="attr">_exhaustiveCheck</span>: <span class="built_in">never</span> = shape;</span><br><span class="line">      <span class="keyword">return</span> _exhaustiveCheck;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://s2.loli.net/2022/02/22/mPEYDNGbXZxzIy9.png" alt="image-20211118183410201" style="zoom:50%"><h3 id="特別声明：この記事は古艺散人先生から転自し、必要があれば原文のプレビューで閲覧することができます。"><a href="#特別声明：この記事は古艺散人先生から転自し、必要があれば原文のプレビューで閲覧することができます。" class="headerlink" title="特別声明：この記事は古艺散人先生から転自し、必要があれば原文のプレビューで閲覧することができます。"></a>特別声明：この記事は<a target="_blank" rel="noopener" href="https://github.com/lurongtao/TypeScript">古艺散人先生</a>から転自し、必要があれば原文のプレビューで閲覧することができます。</h3></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://maple-214.cn">泽枫</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://maple-214.cn/article/53859/">https://maple-214.cn/article/53859/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://maple-214.cn" target="_blank">澤楓の小屋</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89/">フロントエンド</a><a class="post-meta__tags" href="/tags/TypeScript/">TypeScript</a></div><div class="post_share"><div class="social-share" data-image="/img/cover/cover_03.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/qrCode/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/qrCode/wechat.jpg" alt="wechat"></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/qrCode/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/qrCode/alipay.jpg" alt="alipay"></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><div class="ads-wrap"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4229599433514996" crossorigin="anonymous"></script><ins class="adsbygoogle" style="display:block" data-ad-format="autorelaxed" data-ad-client="ca-pub-4229599433514996" data-ad-slot="8956902816"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/article/17422/" title="1-3、TypeScriptのよくある種類"><img class="cover" src="/img/cover/cover_01.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">1-3、TypeScriptのよくある種類</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/article/31375/" title="1-1、基本：TypeScriptの概要(1)"><img class="cover" src="/img/cover/cover_02.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-28</div><div class="title">1-1、基本：TypeScriptの概要(1)</div></div></a></div><div><a href="/article/17422/" title="1-3、TypeScriptのよくある種類"><img class="cover" src="/img/cover/cover_01.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-02-14</div><div class="title">1-3、TypeScriptのよくある種類</div></div></a></div><div><a href="/article/52879/" title="1-2、基本：TypeScriptの概要(2)"><img class="cover" src="/img/cover/cover_03.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-28</div><div class="title">1-2、基本：TypeScriptの概要(2)</div></div></a></div><div><a href="/article/6338/" title="ホバリング時のジッターの原因と解決策"><img class="cover" src="/img/cover/cover_02.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-28</div><div class="title">ホバリング時のジッターの原因と解決策</div></div></a></div><div><a href="/article/8074/" title="1-1、基础篇：TypeScript介绍"><img class="cover" src="/img/cover/cover_03.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-28</div><div class="title">1-1、基础篇：TypeScript介绍</div></div></a></div><div><a href="/article/19978/" title="1-3、基础篇：常用类型"><img class="cover" src="/img/cover/cover_03.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-28</div><div class="title">1-3、基础篇：常用类型</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info__name">泽枫</div><div class="author-info__description">牛奶会有的，面包也会有的。</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">31</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">4</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><a id="card-info-btn"><i class="fab fa-github"></i><span>我是一个按钮</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">明天会更好。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E9%A1%9E%E5%9E%8B%E7%B8%AE%E5%B0%8F"><span class="toc-number">1.</span> <span class="toc-text">四、類型縮小</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-typeof-%E3%82%BF%E3%82%A4%E3%83%97%E3%82%AC%E3%83%BC%E3%83%89"><span class="toc-number">1.1.</span> <span class="toc-text">4.1 typeof タイプガード</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2%E7%9C%9F%E7%90%86%E5%80%A4%E3%81%AE%E7%B8%AE%E5%B0%8F"><span class="toc-number">1.2.</span> <span class="toc-text">4.2真理値の縮小</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3%E7%AD%89%E4%BE%A1%E7%B8%AE%E5%B0%8F"><span class="toc-number">1.3.</span> <span class="toc-text">4.3等価縮小</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-in-%E3%82%AA%E3%83%9A%E3%83%AC%E3%83%BC%E3%82%BF%E7%B8%AE%E5%B0%8F"><span class="toc-number">1.4.</span> <span class="toc-text">4.4 in オペレータ縮小</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-5-instanceof-%E3%82%AA%E3%83%9A%E3%83%AC%E3%83%BC%E3%82%BF%E7%B8%AE%E5%B0%8F"><span class="toc-number">1.5.</span> <span class="toc-text">4.5 instanceof オペレータ縮小</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-6%E9%85%8D%E5%88%86%E3%81%AE%E7%B8%AE%E5%B0%8F"><span class="toc-number">1.6.</span> <span class="toc-text">4.6配分の縮小</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-7%E5%88%B6%E5%BE%A1%E3%83%95%E3%83%AD%E3%83%BC%E8%A7%A3%E6%9E%90"><span class="toc-number">1.7.</span> <span class="toc-text">4.7制御フロー解析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-8%E5%9E%8B%E8%BF%B0%E8%AA%9E%E3%81%AE%E4%BD%BF%E7%94%A8"><span class="toc-number">1.8.</span> <span class="toc-text">4.8型述語の使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-9%E5%B7%AE%E5%88%A5%E3%81%95%E3%82%8C%E3%81%9F-unions"><span class="toc-number">1.9.</span> <span class="toc-text">4.9差別された unions</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-10-never-%E3%82%BF%E3%82%A4%E3%83%97%E3%81%8A%E3%82%88%E3%81%B3%E7%B6%B2%E7%BE%85%E6%80%A7%E3%83%81%E3%82%A7%E3%83%83%E3%82%AF"><span class="toc-number">1.10.</span> <span class="toc-text">4.10 never タイプおよび網羅性チェック</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E5%88%A5%E5%A3%B0%E6%98%8E%EF%BC%9A%E3%81%93%E3%81%AE%E8%A8%98%E4%BA%8B%E3%81%AF%E5%8F%A4%E8%89%BA%E6%95%A3%E4%BA%BA%E5%85%88%E7%94%9F%E3%81%8B%E3%82%89%E8%BB%A2%E8%87%AA%E3%81%97%E3%80%81%E5%BF%85%E8%A6%81%E3%81%8C%E3%81%82%E3%82%8C%E3%81%B0%E5%8E%9F%E6%96%87%E3%81%AE%E3%83%97%E3%83%AC%E3%83%93%E3%83%A5%E3%83%BC%E3%81%A7%E9%96%B2%E8%A6%A7%E3%81%99%E3%82%8B%E3%81%93%E3%81%A8%E3%81%8C%E3%81%A7%E3%81%8D%E3%81%BE%E3%81%99%E3%80%82"><span class="toc-number">1.10.1.</span> <span class="toc-text">特別声明：この記事は古艺散人先生から転自し、必要があれば原文のプレビューで閲覧することができます。</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/article/53859/" title="1-4、基本：TypeScriptの型削減.md"><img src="/img/cover/cover_03.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="1-4、基本：TypeScriptの型削減.md"></a><div class="content"><a class="title" href="/article/53859/" title="1-4、基本：TypeScriptの型削減.md">1-4、基本：TypeScriptの型削減.md</a><time datetime="2024-02-15T07:49:54.000Z" title="发表于 2024-02-15 15:49:54">2024-02-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/article/17422/" title="1-3、TypeScriptのよくある種類"><img src="/img/cover/cover_01.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="1-3、TypeScriptのよくある種類"></a><div class="content"><a class="title" href="/article/17422/" title="1-3、TypeScriptのよくある種類">1-3、TypeScriptのよくある種類</a><time datetime="2024-02-14T14:05:56.000Z" title="发表于 2024-02-14 22:05:56">2024-02-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/article/6338/" title="ホバリング時のジッターの原因と解決策"><img src="/img/cover/cover_02.jpeg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="ホバリング時のジッターの原因と解決策"></a><div class="content"><a class="title" href="/article/6338/" title="ホバリング時のジッターの原因と解決策">ホバリング時のジッターの原因と解決策</a><time datetime="2024-01-28T13:20:06.000Z" title="发表于 2024-01-28 21:20:06">2024-01-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/article/52879/" title="1-2、基本：TypeScriptの概要(2)"><img src="/img/cover/cover_03.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="1-2、基本：TypeScriptの概要(2)"></a><div class="content"><a class="title" href="/article/52879/" title="1-2、基本：TypeScriptの概要(2)">1-2、基本：TypeScriptの概要(2)</a><time datetime="2024-01-28T13:16:17.000Z" title="发表于 2024-01-28 21:16:17">2024-01-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/article/31375/" title="1-1、基本：TypeScriptの概要(1)"><img src="/img/cover/cover_02.jpeg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="1-1、基本：TypeScriptの概要(1)"></a><div class="content"><a class="title" href="/article/31375/" title="1-1、基本：TypeScriptの概要(1)">1-1、基本：TypeScriptの概要(1)</a><time datetime="2024-01-28T13:15:12.000Z" title="发表于 2024-01-28 21:15:12">2024-01-28</time></div></div></div></div><div class="card-widget ads-wrap"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4229599433514996" crossorigin="anonymous"></script><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4229599433514996" data-ad-slot="4923656014" data-ad-format="auto" data-full-width-responsive="true"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div></div></div></main><footer id="footer"><div id="footer-wrap"><div id="ft"><img class="ft-img" src="/img/favicon.png" alt="" srcset=""></div><div class="copyright">&copy;2020 - 2024 <i id="heartbeat" class="fa fas fa-heartbeat"></i> 泽枫</div></div></footer></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.12.0"></script><script src="/js/main.js?v=4.12.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.32/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.js"></script><script>function panguFn(){"object"==typeof pangu?pangu.autoSpacingPage():getScript("https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js").then(()=>{pangu.autoSpacingPage()})}function panguInit(){GLOBAL_CONFIG_SITE.isPost&&panguFn()}document.addEventListener("DOMContentLoaded",panguInit)</script><div class="js-pjax"></div><script type="text/javascript" src="/js/src/jquery.js"></script><script type="text/javascript" src="/js/src/vue.js"></script><script type="text/javascript" src="/js/src/vue_js.js"></script><script type="text/javascript" src="/js/src/nav.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/fireworks.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors=["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"];var pjax=new Pjax({elements:'a:not([target="_blank"])',selectors:pjaxSelectors,cacheBust:!1,analytics:!0,scrollRestoration:!1});document.addEventListener("pjax:send",function(){if(btf.removeGlobalFnEvent("pjax"),btf.removeGlobalFnEvent("themeChange"),document.getElementById("rightside").classList.remove("rightside-show"),window.aplayers)for(let e=0;e<window.aplayers.length;e++)window.aplayers[e].options.fixed||window.aplayers[e].destroy();"object"==typeof typed&&typed.destroy();var e=document.body.classList;e.contains("read-mode")&&e.remove("read-mode"),"object"==typeof disqusjs&&disqusjs.destroy()}),document.addEventListener("pjax:complete",function(){window.refreshFn(),document.querySelectorAll("script[data-pjax]").forEach(e=>{const t=document.createElement("script");var a=e.text||e.textContent||e.innerHTML||"";Array.from(e.attributes).forEach(e=>t.setAttribute(e.name,e.value)),t.appendChild(document.createTextNode(a)),e.parentNode.replaceChild(t,e)}),GLOBAL_CONFIG.islazyload&&window.lazyLoadInstance.update(),"function"==typeof panguInit&&panguInit(),"function"==typeof gtag&&gtag("config","G-FZNMK725WD",{page_path:window.location.pathname}),"object"==typeof _hmt&&_hmt.push(["_trackPageview",window.location.pathname]),"function"==typeof loadMeting&&document.getElementsByClassName("aplayer").length&&loadMeting(),"object"==typeof Prism&&Prism.highlightAll()}),document.addEventListener("pjax:error",e=>{404===e.request.status&&pjax.loadUrl("/404.html")})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span> 数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.12.0"></script></div></div><script data-pjax>var parent,child;document.getElementById("recent-posts")&&"/"==location.pathname&&(parent=document.getElementById("recent-posts"),child='<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms"><div class="blog-slider__img"><img src="/img/recommend/recommend_06.jpg" alt="/img/recommend/recommend_06.jpg"/></div><div class="blog-slider__content"><span class="blog-slider__code">2024-01-28</span><a class="blog-slider__title" href="article/59398/">1-6、基础篇：对象类型</a><div class="blog-slider__text">1-6、基础篇：对象类型</div><a class="blog-slider__button" href="article/59398/">详情</a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms"><div class="blog-slider__img"><img src="/img/recommend/recommend_05.jpg" alt="/img/recommend/recommend_05.jpg"/></div><div class="blog-slider__content"><span class="blog-slider__code">2024-01-28</span><a class="blog-slider__title" href="article/30791/">1-5、基础篇：函数更多</a><div class="blog-slider__text">1-5、基础篇：函数更多</div><a class="blog-slider__button" href="article/30791/">详情</a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms"><div class="blog-slider__img"><img src="/img/recommend/recommend_04.jpg" alt="/img/recommend/recommend_04.jpg"/></div><div class="blog-slider__content"><span class="blog-slider__code">2024-01-28</span><a class="blog-slider__title" href="article/23966/">1-4、基础篇：类型缩小</a><div class="blog-slider__text">1-4、基础篇：类型缩小</div><a class="blog-slider__button" href="article/23966/">详情</a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms"><div class="blog-slider__img"><img src="/img/recommend/recommend_03.jpg" alt="/img/recommend/recommend_03.jpg"/></div><div class="blog-slider__content"><span class="blog-slider__code">2024-01-28</span><a class="blog-slider__title" href="article/19978/">1-3、基础篇：常用类型</a><div class="blog-slider__text">1-3、基础篇：常用类型</div><a class="blog-slider__button" href="article/19978/">详情</a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms"><div class="blog-slider__img"><img src="/img/recommend/recommend_02.jpg" alt="/img/recommend/recommend_02.jpg"/></div><div class="blog-slider__content"><span class="blog-slider__code">2024-01-28</span><a class="blog-slider__title" href="article/20247/">1-2、基础篇：TypeScript入门</a><div class="blog-slider__text">1-2、基础篇：TypeScript入门</div><a class="blog-slider__button" href="article/20247/">详情</a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms"><div class="blog-slider__img"><img src="/img/recommend/recommend_01.jpg" alt="/img/recommend/recommend_01.jpg"/></div><div class="blog-slider__content"><span class="blog-slider__code">2024-01-28</span><a class="blog-slider__title" href="article/8074/">1-1、基础篇：TypeScript介绍</a><div class="blog-slider__text">1-1、基础篇：TypeScript介绍</div><a class="blog-slider__button" href="article/8074/">详情</a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>',console.log("已挂载swiper"),parent.insertAdjacentHTML("afterbegin",child))</script><script data-pjax src="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-swiper/swiper/swiper.min.js"></script><script data-pjax src="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-swiper@0.18/swiper/swiperindex.js"></script><style></style></body></html>