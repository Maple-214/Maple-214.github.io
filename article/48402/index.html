<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"><title>2-1、高级篇：变量声明 | 澤楓の小屋</title><meta name="author" content="泽枫"><meta name="copyright" content="泽枫"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="一、变量声明let和const是JavaScript中变量声明的两个相对较新的概念。正如我们前面提到的，let在某些方面与var相似，但允许用户避免在JavaScript中遇到的一些常见的 “麻烦”。 const是let的一个扩展，它可以防止重新赋值给一个变量。 由于TypeScript是JavaScript的扩展，该语言自然支持let和const。在这里，我们将进一步阐述这些新的声明，以及为什么"><meta property="og:type" content="article"><meta property="og:title" content="2-1、高级篇：变量声明"><meta property="og:url" content="https://maple-214.cn/article/48402/index.html"><meta property="og:site_name" content="澤楓の小屋"><meta property="og:description" content="一、变量声明let和const是JavaScript中变量声明的两个相对较新的概念。正如我们前面提到的，let在某些方面与var相似，但允许用户避免在JavaScript中遇到的一些常见的 “麻烦”。 const是let的一个扩展，它可以防止重新赋值给一个变量。 由于TypeScript是JavaScript的扩展，该语言自然支持let和const。在这里，我们将进一步阐述这些新的声明，以及为什么"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://maple-214.cn/img/cover/cover_03.jpg"><meta property="article:published_time" content="2024-01-26T12:13:42.000Z"><meta property="article:modified_time" content="2024-01-26T12:25:37.743Z"><meta property="article:author" content="泽枫"><meta property="article:tag" content="前端"><meta property="article:tag" content="TypeScript"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://maple-214.cn/img/cover/cover_03.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://maple-214.cn/article/48402/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//www.google-analytics.com" crossorigin=""><link rel="preconnect" href="//hm.baidu.com"><link rel="preconnect" href="//busuanzi.ibruce.info"><meta name="google-site-verification" content="OAauFcQX49kS2UGN9SShSqwNxfrsByxSVXRfNyc"><meta name="baidu-site-verification" content="codeva-JddVaE5CKl"><link rel="stylesheet" href="/css/index.css?v=4.12.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.32/dist/fancybox/fancybox.min.css" media="print" onload='this.media="all"'><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(adsbygoogle=window.adsbygoogle||[]).push({google_ad_client:"ca-pub-4229599433514996",enable_page_level_ads:"true"})</script><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script"),t=(e.src="https://hm.baidu.com/hm.js?6df43866b91212ab3dbadbcfd5966f6c",document.getElementsByTagName("script")[0]);t.parentNode.insertBefore(e,t)}()</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-FZNMK725WD"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-FZNMK725WD")</script><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"/search.xml",preload:!0,top_n_per_article:1,unescape:!1,languages:{hits_empty:"找不到您查询的内容：${query}",hits_stats:"共找到 ${hits} 篇文章"}},translate:{defaultEncoding:2,translateDelay:0,msgToTraditionalChinese:"繁体",msgToSimplifiedChinese:"简体"},noticeOutdate:void 0,highlight:{plugin:"highlight.js",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:150},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"",dateSuffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:{limitCount:50,languages:{author:"作者: 泽枫",link:"链接: ",source:"来源: 澤楓の小屋",info:"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},lightbox:"fancybox",Snackbar:{chs_to_cht:"你已切换为繁体中文",cht_to_chs:"你已切换为简体中文",day_to_night:"你已切换为深色模式",night_to_day:"你已切换为浅色模式",bgLight:"#49b1f5",bgDark:"#1f1f1f",position:"bottom-left"},infinitegrid:{js:"https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.0/dist/infinitegrid.min.js",buttonText:"加载更多"},isPhotoFigcaption:!0,islazyload:!1,isAnchor:!1,percent:{toc:!0,rightside:!0},autoDarkmode:!1}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"2-1、高级篇：变量声明",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2024-01-26 20:25:37"}</script><script>(e=>{e.saveToLocal={set:(e,t,a)=>{var o;0!==a&&(o=Date.now(),localStorage.setItem(e,JSON.stringify({value:t,expiry:o+864e5*a})))},get:e=>{var t=localStorage.getItem(e);if(t){t=JSON.parse(t);if(!(Date.now()>t.expiry))return t.value;localStorage.removeItem(e)}}},e.getScript=(o,n={})=>new Promise((t,e)=>{const a=document.createElement("script");a.src=o,a.async=!0,a.onerror=e,a.onload=a.onreadystatechange=function(){var e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(a.onload=a.onreadystatechange=null,t())},Object.keys(n).forEach(e=>{a.setAttribute(e,n[e])}),document.head.appendChild(a)}),e.getCSS=(o,n=!1)=>new Promise((t,e)=>{const a=document.createElement("link");a.rel="stylesheet",a.href=o,n&&(a.id=n),a.onerror=e,a.onload=a.onreadystatechange=function(){var e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(a.onload=a.onreadystatechange=null,t())},document.head.appendChild(a)}),e.activateDarkMode=()=>{document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=()=>{document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};e=saveToLocal.get("theme"),"dark"===e?activateDarkMode():"light"===e&&activateLightMode(),e=saveToLocal.get("aside-status");void 0!==e&&("hide"===e?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"));/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})(window)</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-swiper/swiper/swiper.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-swiper/swiper/swiperstyle.css"><meta name="generator" content="Hexo 7.1.1"><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head><body><script async src="/js/src/sakura.js"></script><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{const d=document.getElementById("loading-box"),e=document.body,n={endLoading:()=>{e.style.overflow="",d.classList.add("loaded")},initLoading:()=>{e.style.overflow="hidden",d.classList.remove("loaded")}};n.initLoading(),window.addEventListener("load",()=>{n.endLoading()}),document.addEventListener("pjax:send",()=>{n.initLoading()}),document.addEventListener("pjax:complete",()=>{n.endLoading()})})()</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">26</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">3</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><hr class="custom-hr"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div></div></div></div><div id="root"><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image:url(/img/cover/cover_03.jpg)"><nav id="nav"><span id="blog-info"><a href="/" title="澤楓の小屋">澤楓の小屋</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div></div><center id="name-container"><a id="page-name" href="javascript:scrollToTop()">PAGE_NAME</a></center></div><div id="nav-right"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">2-1、高级篇：变量声明</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-01-26T12:13:42.000Z" title="发表于 2024-01-26 20:13:42">2024-01-26</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-01-26T12:25:37.743Z" title="更新于 2024-01-26 20:25:37">2024-01-26</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/TypeScript/">TypeScript</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title="2-1、高级篇：变量声明"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="一、变量声明"><a href="#一、变量声明" class="headerlink" title="一、变量声明"></a>一、变量声明</h1><p><code>let</code>和<code>const</code>是JavaScript中变量声明的两个相对较新的概念。正如我们前面提到的，<code>let</code>在某些方面与<code>var</code>相似，但允许用户避免在JavaScript中遇到的一些常见的 “麻烦”。</p><p><code>const</code>是<code>let</code>的一个扩展，它可以防止重新赋值给一个变量。</p><p>由于TypeScript是JavaScript的扩展，该语言自然支持<code>let</code>和<code>const</code>。在这里，我们将进一步阐述这些新的声明，以及为什么它们比<code>var</code>更适合。</p><p>如果你已经不经意地使用了JavaScript，那么下一节可能是刷新你记忆的一个好方法。如果你对JavaScript中<code>var</code>声明的所有怪癖非常熟悉，你可能会发现跳过前面会更容易。</p><h2 id="1-1-var-变量声明"><a href="#1-1-var-变量声明" class="headerlink" title="1.1 var 变量声明"></a>1.1 var 变量声明</h2><p>在JavaScript中声明一个变量，传统上都是用<code>var</code>关键字来完成。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>正如你可能已经发现的，我们刚刚声明了一个名为<code>a</code>的变量，其值为<code>10</code>。</p><p>我们也可以在一个函数中声明一个变量：</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> message = <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> message;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而我们也可以在其他函数中访问这些相同的变量：</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">g</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> b = a + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> g = <span class="title function_">f</span>();</span><br><span class="line"><span class="title function_">g</span>(); <span class="comment">// returns &#x27;11&#x27;</span></span><br></pre></td></tr></table></figure><p>在上面这个例子中，<code>g</code>捕获了<code>f</code>中声明的变量<code>a</code>。在<code>g</code>被调用的任何时候，<code>a</code>的值都将与<code>f</code>中<code>a</code>的值相联系。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">  a = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="title function_">g</span>();</span><br><span class="line">  a = <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">return</span> b;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">g</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">f</span>(); <span class="comment">// returns &#x27;2&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="1-2-作用域规则"><a href="#1-2-作用域规则" class="headerlink" title="1.2 作用域规则"></a>1.2 作用域规则</h2><p>对于那些习惯于其他语言的人来说，<code>var</code>声明有一些奇怪的作用域范围规则。以下面的例子为例：</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">shouldInitialize: <span class="built_in">boolean</span></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (shouldInitialize) &#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">f</span>(<span class="literal">true</span>); <span class="comment">// 返回 &#x27;10&#x27;</span></span><br><span class="line"><span class="title function_">f</span>(<span class="literal">false</span>); <span class="comment">// 返回 &#x27;undefined&#x27;</span></span><br></pre></td></tr></table></figure><p>有些读者可能会对这个例子产生怀疑。变量<code>x</code>是在<code>if</code>块中声明的，但我们却能从该块之外访问它。这是因为<code>var</code>声明可以在其包含的函数、模块、命名空间或全局范围内的任何地方访问（所有这些我们将在后面讨论），而不考虑包含的块。有些人把这称为<code>var</code>作用域或函数作用域。参数也是函数作用域。</p><p>这些作用域规则会导致几种类型的错误。它们加剧的一个问题是，多次声明同一个变量并不是一个错误。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sumMatrix</span>(<span class="params">matrix: <span class="built_in">number</span>[][]</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; matrix.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> currentRow = matrix[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; currentRow.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      sum += currentRow[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也许对于一些有经验的JavaScript开发者来说，这很容易被发现，但是内部<code>for-loop</code>会意外地覆盖变量<code>i</code>，因为<code>i</code>指的是同一个函数范围的变量。正如有经验的开发者现在所知道的，类似的各种bug会在代码审查中溜走，并会成为无尽的挫折来源。</p><h2 id="1-3-变量捕获的怪癖"><a href="#1-3-变量捕获的怪癖" class="headerlink" title="1.3 变量捕获的怪癖"></a>1.3 变量捕获的怪癖</h2><p>花点时间猜一猜下面这段话的输出是什么：</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">  &#125;, <span class="number">100</span> * i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于那些不熟悉的人来说，<code>setTimeout</code>将尝试在一定数量的毫秒后执行一个函数（尽管要等待其他东西停止运行）。</p><p>准备好了吗？看看吧。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">10</span><br><span class="line">10</span><br><span class="line">10</span><br><span class="line">10</span><br><span class="line">10</span><br><span class="line">10</span><br><span class="line">10</span><br><span class="line">10</span><br><span class="line">10</span><br><span class="line">10</span><br></pre></td></tr></table></figure><p>许多JavaScript开发人员对这种行为非常熟悉，但如果你感到惊讶，你肯定不是一个人。大多数人都希望输出的结果是：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td></tr></table></figure><p>还记得我们前面提到的关于变量捕获的问题吗？我们传递给<code>setTimeout</code>的每个函数表达式实际上都是指同一范围内的同一个<code>i</code>。</p><p>让我们花点时间考虑一下这意味着什么。 <code>setTimeout</code>将在若干毫秒之后运行一个函数，但只有在<code>for</code>循环停止执行之后；当<code>for</code>循环停止执行时，<code>i</code>的值是<code>10</code>。因此，每次给定的函数被调用时，它将打印出<code>10</code>!</p><p>一个常见的解决方法是使用IIFE–一个立即调用的函数表达式–来捕获每次迭代的<code>i</code>。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  <span class="comment">// 通过调用一个带有其当前值的函数</span></span><br><span class="line">  <span class="comment">// 捕捉&#x27;i&#x27;的当前状态</span></span><br><span class="line">  (<span class="keyword">function</span> (<span class="params">i</span>) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">    &#125;, <span class="number">100</span> * i);</span><br><span class="line">  &#125;)(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种看起来很奇怪的模式其实是很常见的。参数列表中的 <code>i</code> 实际上是对 <code>for</code> 循环中声明的 <code>i</code> 的影子，但由于我们对它们的命名相同，所以我们不必对循环体进行过多的修改。</p><h2 id="1-4-let-变量声明"><a href="#1-4-let-变量声明" class="headerlink" title="1.4 let 变量声明"></a>1.4 let 变量声明</h2><p>现在你已经发现<code>var</code>有一些问题，这正是<code>let</code>语句被引入的原因。除了使用的关键字外，<code>let</code>语句的写法与<code>var</code>语句相同。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> hello = <span class="string">&quot;Hello!&quot;</span>;</span><br></pre></td></tr></table></figure><p>关键的区别不在语法上，而在语义上，我们现在要深入研究。</p><h2 id="1-5-块级作用域"><a href="#1-5-块级作用域" class="headerlink" title="1.5 块级作用域"></a>1.5 块级作用域</h2><p>当一个变量使用<code>let</code>声明时，它使用了一些人所说的词法范围或块法范围。与用<code>var</code>声明的变量不同，<code>block-scope</code>变量的作用域会泄露给其包含的函数，而在其最近的包含块或<code>for-loop</code>之外是不可见的。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">input: <span class="built_in">boolean</span></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">100</span>;</span><br><span class="line">  <span class="keyword">if</span> (input) &#123;</span><br><span class="line">    <span class="comment">// 引用&#x27;a&#x27;仍然可以</span></span><br><span class="line">    <span class="keyword">let</span> b = a + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 错误：这里不存在&#x27;b&#x27;。</span></span><br><span class="line">  <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里，我们有两个局部变量<code>a</code>和<code>b</code>。<code>a</code>的作用域仅限于<code>f</code>的主体，而<code>b</code>的作用域仅限于包含<code>if</code>语句的块。</p><p>在<code>catch</code>子句中声明的变量也有类似的作用域规则。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="string">&quot;oh no!&quot;</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Oh well.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Error: 这里不存在&#x27;e&#x27;。</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(e);</span><br></pre></td></tr></table></figure><p>块级作用域变量的另一个属性是，在它们被实际声明之前，它们不能被读或写到。虽然这些变量在它们的整个作用域中都是 “存在 “的，但是直到它们被声明之前的所有点都是它们的时间死角的一部分。这只是一种复杂的说法，你不能在<code>let</code>语句之前访问它们，幸运的是TypeScript会让你知道这一点。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line">a++; <span class="comment">// 在声明之前使用&#x27;a&#x27;是非法的。</span></span><br><span class="line"><span class="keyword">let</span> a;</span><br></pre></td></tr></table></figure><p>需要注意的是，你仍然可以在声明之前<em>捕获</em>一个块范围的变量。唯一的问题是，在声明之前调用该函数是非法的。如果以ES2015为目标，现代运行时将抛出一个错误；然而，现在TypeScript是允许的，不会将此作为一个错误报告。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 可以捕捉到 &quot;a&quot;。</span></span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在声明&#x27;a&#x27;之前非法调用&#x27;foo&#x27;。</span></span><br><span class="line"><span class="comment">// runtimes应该在这里抛出一个错误</span></span><br><span class="line"><span class="title function_">foo</span>();</span><br><span class="line"><span class="keyword">let</span> a;</span><br></pre></td></tr></table></figure><p>For more information on temporal dead zones, see relevant content on the <a target="_blank" rel="noopener" href="https://developer.mozilla.org/docs/Web/JavaScript/Reference/Statements/let#Temporal_dead_zone_and_errors_with_let">Mozilla Developer Network</a>.</p><p>关于时空死角的更多信息，请看 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/docs/Web/JavaScript/Reference/Statements/let#Temporal_dead_zone_and_errors_with_let">Mozilla开发者网络</a>上的相关内容。</p><h2 id="1-6-重复声明和投影"><a href="#1-6-重复声明和投影" class="headerlink" title="1.6 重复声明和投影"></a>1.6 重复声明和投影</h2><p>对于var声明，我们提到，你声明了多少次变量并不重要，你只是得到了一个。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">x</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> x;</span><br><span class="line">  <span class="keyword">var</span> x;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的例子中，所有关于<code>x</code>的声明实际上指的是同一个<code>x</code>，这是完全有效的。这往往会成为错误的根源。值得庆幸的是，<code>let</code>的声明并不那么宽容。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">let</span> x = <span class="number">20</span>; <span class="comment">// 错误：不能在同一范围内重新声明&#x27;x&#x27;。</span></span><br></pre></td></tr></table></figure><p>变量不一定要都是块范围的，TypeScript才会告诉我们有一个问题。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">x</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> x = <span class="number">100</span>; <span class="comment">// 错误：干扰了参数声明</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">g</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> x = <span class="number">100</span>;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">100</span>; <span class="comment">// 错误：不能同时有&#x27;x&#x27;的声明</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这并不是说一个块作用域变量永远不能和一个函数作用域变量一起声明。区块作用域变量只是需要在一个明显不同的区块中声明。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">condition, x</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (condition) &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">f</span>(<span class="literal">false</span>, <span class="number">0</span>); <span class="comment">// 返回 &#x27;0&#x27;</span></span><br><span class="line"><span class="title function_">f</span>(<span class="literal">true</span>, <span class="number">0</span>); <span class="comment">// 返回 &#x27;100&#x27;</span></span><br></pre></td></tr></table></figure><p>在一个更加嵌套的作用域中引入一个新名字的行为被称为投影。这是一把双刃剑，因为它可以在意外影射的情况下自行引入某些错误，同时也可以防止某些错误。例如，想象一下我们之前用<code>let</code>变量编写的<code>sumMatrix函</code>数：</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sumMatrix</span>(<span class="params">matrix: <span class="built_in">number</span>[][]</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; matrix.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> currentRow = matrix[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; currentRow.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      sum += currentRow[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个版本的循环实际上会正确地执行求和，因为内循环的 <code>i</code> 会对外循环的 <code>i</code> 产生阴影。</p><p>为了写出更清晰的代码，通常应避免使用投影。虽然在某些情况下，利用它可能是合适的，但你应该使用你的最佳判断。</p><h2 id="1-7-块级作用域变量捕获"><a href="#1-7-块级作用域变量捕获" class="headerlink" title="1.7 块级作用域变量捕获"></a>1.7 块级作用域变量捕获</h2><p>当我们第一次触及用<code>var</code>声明捕获变量的想法时，我们简要地讨论了变量一旦被捕获是如何行动的。为了给大家一个更好的直观印象，每次运行一个作用域时，它都会创建一个变量的 “环境”。这个环境和它捕获的变量甚至在它的作用域内的所有东西都执行完毕后仍然存在。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">theCityThatAlwaysSleeps</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> getCity;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> city = <span class="string">&quot;Seattle&quot;</span>;</span><br><span class="line">    getCity = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> city;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">getCity</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为我们已经从它的环境中捕获了<code>city</code>，所以尽管 <code>if</code> 块已经执行完毕，我们仍然能够访问它。</p><p>回想一下，在我们之前的<code>setTimeout</code>例子中，我们最终需要使用IIFE来捕获<code>for</code>循环的每个迭代中的变量状态。实际上，我们所做的是为我们捕获的变量创建一个新的变量环境。这有点麻烦，但幸运的是，在TypeScript中你再也不用这么做了。</p><p>当声明为循环的一部分时，<code>let</code>声明的行为有很大的不同。这些声明并不只是给循环本身引入一个新的环境，而是在每个迭代中创建一个新的范围。因为这就是我们在IIFE中所做的事情，我们可以改变我们以前的<code>setTimeout</code>的例子，只使用<code>let</code>声明。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">  &#125;, <span class="number">100</span> * i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和预期的一样，这将打印出：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td></tr></table></figure><h2 id="1-8-const声明"><a href="#1-8-const声明" class="headerlink" title="1.8 const声明"></a>1.8 <code>const</code>声明</h2><p><code>const</code>声明是声明变量的另一种方式。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> numLivesForCat = <span class="number">9</span>;</span><br></pre></td></tr></table></figure><p>它们就像<code>let</code>声明一样，但正如它们的名字所暗示的，一旦它们被绑定，它们的值就不能被改变。换句话说，它们有和<code>let</code>一样的范围规则，但你不能重新赋值给它们。</p><p>这不应该与它们所指的值是不可改变的想法相混淆。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> numLivesForCat = <span class="number">9</span>;</span><br><span class="line"><span class="keyword">const</span> kitty = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;Aurora&quot;</span>,</span><br><span class="line">  <span class="attr">numLives</span>: numLivesForCat,</span><br><span class="line">&#125;; <span class="comment">// 错误</span></span><br><span class="line">kitty = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;Danielle&quot;</span>,</span><br><span class="line">  <span class="attr">numLives</span>: numLivesForCat,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 以下都正确</span></span><br><span class="line">kitty.<span class="property">name</span> = <span class="string">&quot;Rory&quot;</span>;</span><br><span class="line">kitty.<span class="property">name</span> = <span class="string">&quot;Kitty&quot;</span>;</span><br><span class="line">kitty.<span class="property">name</span> = <span class="string">&quot;Cat&quot;</span>;</span><br><span class="line">kitty.<span class="property">numLives</span>--;</span><br></pre></td></tr></table></figure><p>除非你采取特定的措施来避免它，否则常量变量的内部状态仍然是可以修改的。幸运的是，TypeScript允许你指定一个对象的成员是 <code>readonly</code> 的。</p><h2 id="1-9-let与const比较"><a href="#1-9-let与const比较" class="headerlink" title="1.9 let与const比较"></a>1.9 <code>let</code>与<code>const</code>比较</h2><p>鉴于我们有两种具有类似范围语义的声明，我们很自然地会问自己应该使用哪一种。像大多数广泛的问题一样，答案是：这取决于。</p><p>根据最小特权原则，除了那些你打算修改的声明外，所有的声明都应该使用 const。其理由是，如果一个变量不需要被写入，那么在同一个代码库中工作的其他人就不应该自动能够写入该对象，他们需要考虑是否真的需要重新赋值给该变量。在推理数据流时，使用<code>const</code>也会使代码更可预测。</p><p>使用你的最佳判断，如果适用的话，请与你的团队其他成员协商此事。</p><p>本教程的大部分内容都使用<code>let</code>声明。</p><h2 id="1-10-解构"><a href="#1-10-解构" class="headerlink" title="1.10 解构"></a>1.10 解构</h2><p>TypeScript拥有的另一个ECMAScript 2015特性是解构。关于完整的参考资料，请看<a target="_blank" rel="noopener" href="https://developer.mozilla.org/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment">Mozilla开发者网络上的文章</a>。在本节中，我们将做一个简短的概述。</p><h2 id="1-11-数组析构"><a href="#1-11-数组析构" class="headerlink" title="1.11 数组析构"></a>1.11 数组析构</h2><p>最简单的解构形式是数组解构赋值。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> input = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">let</span> [first, second] = input;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(first); <span class="comment">// 输出 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(second); <span class="comment">// 输出 2</span></span><br></pre></td></tr></table></figure><p>这将创建两个新的变量，命名为 <code>first</code> 和 <code>second</code>。这等同于使用索引，但要方便得多。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line">first = input[<span class="number">0</span>];</span><br><span class="line">second = input[<span class="number">1</span>];</span><br></pre></td></tr></table></figure><p>解构也适用于已经声明的变量。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 交换变量</span></span><br><span class="line">[first, second] = [second, first];</span><br></pre></td></tr></table></figure><p>而且是带参数的函数：</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">[first, second]: [<span class="built_in">number</span>, <span class="built_in">number</span>]</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(first);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(second);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">f</span>([<span class="number">1</span>, <span class="number">2</span>]);</span><br></pre></td></tr></table></figure><p>你可以使用语法 <code>...</code> 为列表中的剩余项目创建一个变量。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [first, ...rest] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(first); <span class="comment">// 输出 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(rest); <span class="comment">// 输出 [ 2, 3, 4 ]</span></span><br></pre></td></tr></table></figure><p>当然，由于这是JavaScript，你可以直接忽略你不关心的拖尾元素：</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [first] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(first); <span class="comment">// outputs 1</span></span><br></pre></td></tr></table></figure><p>或其他元素：</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [, second, , fourth] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(second); <span class="comment">// 输出 2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fourth); <span class="comment">// 输出 4</span></span><br></pre></td></tr></table></figure><h2 id="1-12-元组解构"><a href="#1-12-元组解构" class="headerlink" title="1.12 元组解构"></a>1.12 元组解构</h2><p>元组可以像数组一样被去结构化；去结构化的变量得到相应元组元素的类型：</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">tuple</span>: [<span class="built_in">number</span>, <span class="built_in">string</span>, <span class="built_in">boolean</span>] = [<span class="number">7</span>, <span class="string">&quot;hello&quot;</span>, <span class="literal">true</span>];</span><br><span class="line"><span class="keyword">let</span> [a, b, c] = tuple; <span class="comment">// a: number, b: string, c: boolean</span></span><br></pre></td></tr></table></figure><p>对一个元组进行解构，超出其元素的范围是一个错误：</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, b, c, d] = tuple; <span class="comment">// 错误，索引3处没有元素</span></span><br></pre></td></tr></table></figure><p>和数组一样，你可以用<code>...</code>对元组的其余部分进行解构，以得到一个更短的元组：</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, ...bc] = tuple; <span class="comment">// bc: [string, boolean]</span></span><br><span class="line"><span class="keyword">let</span> [a, b, c, ...d] = tuple; <span class="comment">// d: [], 空 tuple</span></span><br></pre></td></tr></table></figure><p>或者忽略尾部元素，或者忽略其他元素：</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [a] = tuple; <span class="comment">// a: number</span></span><br><span class="line"><span class="keyword">let</span> [, b] = tuple; <span class="comment">// b: string</span></span><br></pre></td></tr></table></figure><h2 id="1-13-对象解构"><a href="#1-13-对象解构" class="headerlink" title="1.13 对象解构"></a>1.13 对象解构</h2><p>你也可以做对象的结构：</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> o = &#123; <span class="attr">a</span>: <span class="string">&quot;foo&quot;</span>, <span class="attr">b</span>: <span class="number">12</span>, <span class="attr">c</span>: <span class="string">&quot;bar&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> &#123; a, b &#125; = o;</span><br></pre></td></tr></table></figure><p>这就从<code>o.a</code>和<code>o.b</code>中创建了新的变量<code>a</code>和<code>b</code>。注意，如果你不需要<code>c</code>，你可以跳过它。</p><p>就像数组去结构化一样，你可以不用声明就进行赋值：</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line">(&#123; a, b &#125; = &#123; <span class="attr">a</span>: <span class="string">&quot;baz&quot;</span>, <span class="attr">b</span>: <span class="number">101</span> &#125;);</span><br></pre></td></tr></table></figure><p>请注意，我们必须用圆括号包围这个语句。JavaScript通常将{作为块的开始来解析。</p><p>你可以使用语法<code>...</code>为对象中的剩余项目创建一个变量：</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; a, ...passthrough &#125; = o;</span><br><span class="line"><span class="keyword">let</span> total = passthrough.<span class="property">b</span> + passthrough.<span class="property">c</span>.<span class="property">length</span>;</span><br></pre></td></tr></table></figure><ol><li>属性重命名</li></ol><p>你也可以给属性起不同的名字：</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; <span class="attr">a</span>: newName1, <span class="attr">b</span>: newName2 &#125; = o;</span><br></pre></td></tr></table></figure><p>这里的语法开始变得混乱了。你可以把<code>a: newName1</code>读作 <code>&quot;a as newName1&quot;</code>。方向是从左到右，就像你写的一样：</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> newName1 = o.<span class="property">a</span>;</span><br><span class="line"><span class="keyword">let</span> newName2 = o.<span class="property">b</span>;</span><br></pre></td></tr></table></figure><p>令人困惑的是，这里的冒号并不表示类型。如果你指定了类型，仍然需要写在整个结构解构之后。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; a, b &#125;: &#123; <span class="attr">a</span>: <span class="built_in">string</span>; <span class="attr">b</span>: <span class="built_in">number</span> &#125; = o;</span><br></pre></td></tr></table></figure><ol><li>默认值</li></ol><p>默认值让你指定一个默认值，以防一个属性未被定义。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">keepWholeObject</span>(<span class="params">wholeObject: &#123; a: <span class="built_in">string</span>; b?: <span class="built_in">number</span> &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> &#123; a, b = <span class="number">1001</span> &#125; = wholeObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>b?</code> 表示<code>b</code>是可选的，所以它可能是未定义的。 <code>keepWholeObject</code>现在有一个<code>wholeObject</code>的变量，以及属性<code>a</code>和<code>b</code>，即使<code>b</code>是未定义的。</p><h2 id="1-14-Function-声明"><a href="#1-14-Function-声明" class="headerlink" title="1.14 Function 声明"></a>1.14 Function 声明</h2><p>去结构化在函数声明中也起作用。对于简单的情况，这是很直接的。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> C = &#123; <span class="attr">a</span>: <span class="built_in">string</span>; b?: <span class="built_in">number</span> &#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">&#123; a, b &#125;: C</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是对于参数来说，指定默认值是比较常见的，而用解构的方式来获得默认值是很棘手的。首先，你需要记住把模式放在默认值之前。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">&#123; a = <span class="string">&quot;&quot;</span>, b = <span class="number">0</span> &#125; = &#123;&#125;</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">f</span>();</span><br></pre></td></tr></table></figure><p>然后，你需要记住在<code>destructured</code>属性上给可选属性一个默认值，而不是主初始化器。记住，<code>C</code>的定义是<code>b</code>可选的。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">&#123; a, b = <span class="number">0</span> &#125; = &#123; a: <span class="string">&quot;&quot;</span> &#125;</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">f</span>(&#123; <span class="attr">a</span>: <span class="string">&quot;yes&quot;</span> &#125;); <span class="comment">// 正确，b = 0</span></span><br><span class="line"><span class="title function_">f</span>(); <span class="comment">// 正确, 默认 &#123; a: &quot;&quot; &#125;, 然后默认为 b = 0</span></span><br><span class="line"><span class="title function_">f</span>(&#123;&#125;); <span class="comment">// 错误，如果你提供一个参数，&#x27;a&#x27;是必须的</span></span><br></pre></td></tr></table></figure><p>小心使用解构。正如前面的例子所展示的，除了最简单的析构表达式之外，任何东西都会令人困惑。这在深度嵌套的结构化中尤其如此，即使不堆积重命名、默认值和类型注释，也会变得非常难以理解。尽量保持结构化表达式的小而简单。你总是可以自己写出解构会产生的赋值。</p><h2 id="1-15-展开"><a href="#1-15-展开" class="headerlink" title="1.15 展开"></a>1.15 展开</h2><p>展开操作符与解构相反。它允许你将一个数组分散到另一个数组中，或者将一个对象分散到另一个对象中。比如说：</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> first = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">let</span> second = [<span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> bothPlus = [<span class="number">0</span>, ...first, ...second, <span class="number">5</span>];</span><br></pre></td></tr></table></figure><p>这使<code>bothPlus</code>的值为<code>[0, 1, 2, 3, 4, 5]</code>。展开创建 <code>first</code> 和 <code>second</code> 的浅层拷贝。它们不会因为展开而改变。</p><p>你也可以展开对象。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> defaults = &#123;</span><br><span class="line">  <span class="attr">food</span>: <span class="string">&quot;spicy&quot;</span>,</span><br><span class="line">  <span class="attr">price</span>: <span class="string">&quot;$$&quot;</span>,</span><br><span class="line">  <span class="attr">ambiance</span>: <span class="string">&quot;noisy&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> search = &#123;</span><br><span class="line">  ...defaults,</span><br><span class="line">  <span class="attr">food</span>: <span class="string">&quot;rich&quot;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>现在的 <code>search</code> 是 <code>&#123; food: &quot;rich&quot;, price: &quot;$$&quot;, ambiance: &quot;noisy&quot; &#125;</code>。对象展开比数组展开更复杂。像数组展开一样，它从左到右进行，但结果仍然是一个对象。这意味着展开对象中较晚出现的属性会覆盖较早出现的属性。因此，如果我们修改前面的例子，在最后展开：</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> defaults = &#123;</span><br><span class="line">  <span class="attr">food</span>: <span class="string">&quot;spicy&quot;</span>,</span><br><span class="line">  <span class="attr">price</span>: <span class="string">&quot;$$&quot;</span>,</span><br><span class="line">  <span class="attr">ambiance</span>: <span class="string">&quot;noisy&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> search = &#123;</span><br><span class="line">  <span class="attr">food</span>: <span class="string">&quot;rich&quot;</span>,</span><br><span class="line">  ...defaults,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后，<code>defaults</code>中的食物属性覆盖了<code>food: &quot;rich&quot;</code>，这不是我们在这种情况下想要的。</p><p>对象传播也有其他一些令人惊讶的限制。首先，它只包括一个对象 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/docs/Web/JavaScript/Enumerability_and_ownership_of_properties">自己的、可列举的属性</a>。基本上，这意味着当你传播一个对象的实例时，你会失去方法。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">  p = <span class="number">12</span>;</span><br><span class="line">  <span class="title function_">m</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> c = <span class="keyword">new</span> <span class="title function_">C</span>();</span><br><span class="line"><span class="keyword">let</span> clone = &#123;</span><br><span class="line">  ...c,</span><br><span class="line">&#125;;</span><br><span class="line">clone.<span class="property">p</span>; <span class="comment">// 正确</span></span><br><span class="line">clone.<span class="title function_">m</span>(); <span class="comment">// 错误!</span></span><br></pre></td></tr></table></figure><p>TypeScript编译器不允许从通用函数中展开类型参数。该功能预计将在未来的语言版本中出现。</p><h3 id="特别声明-本文转自-古艺散人老师-，如有需要可前往原文预览查看。"><a href="#特别声明-本文转自-古艺散人老师-，如有需要可前往原文预览查看。" class="headerlink" title="特别声明: 本文转自  古艺散人老师 ，如有需要可前往原文预览查看。"></a>特别声明: 本文转自 <a target="_blank" rel="noopener" href="https://github.com/lurongtao/TypeScript">古艺散人老师 </a>，如有需要可前往原文预览查看。</h3></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://maple-214.cn">泽枫</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://maple-214.cn/article/48402/">https://maple-214.cn/article/48402/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://maple-214.cn" target="_blank">澤楓の小屋</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%89%8D%E7%AB%AF/">前端</a><a class="post-meta__tags" href="/tags/TypeScript/">TypeScript</a></div><div class="post_share"><div class="social-share" data-image="/img/cover/cover_03.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/qrCode/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/qrCode/wechat.jpg" alt="wechat"></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/qrCode/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/qrCode/alipay.jpg" alt="alipay"></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/article/48617/" title="2-2、高级篇：类型推断"><img class="cover" src="/img/cover/cover_03.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">2-2、高级篇：类型推断</div></div></a></div><div class="next-post pull-right"><a href="/article/40444/" title="1-9、基础篇：模块"><img class="cover" src="/img/cover/cover_02.jpeg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">1-9、基础篇：模块</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/article/8074/" title="1-1、基础篇：TypeScript介绍"><img class="cover" src="/img/cover/cover_03.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-26</div><div class="title">1-1、基础篇：TypeScript介绍</div></div></a></div><div><a href="/article/19978/" title="1-3、基础篇：常用类型"><img class="cover" src="/img/cover/cover_03.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-26</div><div class="title">1-3、基础篇：常用类型</div></div></a></div><div><a href="/article/23966/" title="1-4、基础篇：类型缩小"><img class="cover" src="/img/cover/cover_02.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-26</div><div class="title">1-4、基础篇：类型缩小</div></div></a></div><div><a href="/article/30791/" title="1-5、基础篇：函数更多"><img class="cover" src="/img/cover/cover_03.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-26</div><div class="title">1-5、基础篇：函数更多</div></div></a></div><div><a href="/article/59398/" title="1-6、基础篇：对象类型"><img class="cover" src="/img/cover/cover_02.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-26</div><div class="title">1-6、基础篇：对象类型</div></div></a></div><div><a href="/article/2401/" title="1-7、基础篇：类型操纵"><img class="cover" src="/img/cover/cover_02.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-26</div><div class="title">1-7、基础篇：类型操纵</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info__name">泽枫</div><div class="author-info__description">牛奶会有的，面包也会有的。</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">26</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">3</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><a id="card-info-btn"><i class="fab fa-github"></i><span>我是一个按钮</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">明天会更好。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E"><span class="toc-number">1.</span> <span class="toc-text">一、变量声明</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-var-%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E"><span class="toc-number">1.1.</span> <span class="toc-text">1.1 var 变量声明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E4%BD%9C%E7%94%A8%E5%9F%9F%E8%A7%84%E5%88%99"><span class="toc-number">1.2.</span> <span class="toc-text">1.2 作用域规则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-%E5%8F%98%E9%87%8F%E6%8D%95%E8%8E%B7%E7%9A%84%E6%80%AA%E7%99%96"><span class="toc-number">1.3.</span> <span class="toc-text">1.3 变量捕获的怪癖</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-let-%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E"><span class="toc-number">1.4.</span> <span class="toc-text">1.4 let 变量声明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-5-%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">1.5.</span> <span class="toc-text">1.5 块级作用域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-6-%E9%87%8D%E5%A4%8D%E5%A3%B0%E6%98%8E%E5%92%8C%E6%8A%95%E5%BD%B1"><span class="toc-number">1.6.</span> <span class="toc-text">1.6 重复声明和投影</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-7-%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%8F%98%E9%87%8F%E6%8D%95%E8%8E%B7"><span class="toc-number">1.7.</span> <span class="toc-text">1.7 块级作用域变量捕获</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-8-const%E5%A3%B0%E6%98%8E"><span class="toc-number">1.8.</span> <span class="toc-text">1.8 const声明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-9-let%E4%B8%8Econst%E6%AF%94%E8%BE%83"><span class="toc-number">1.9.</span> <span class="toc-text">1.9 let与const比较</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-10-%E8%A7%A3%E6%9E%84"><span class="toc-number">1.10.</span> <span class="toc-text">1.10 解构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-11-%E6%95%B0%E7%BB%84%E6%9E%90%E6%9E%84"><span class="toc-number">1.11.</span> <span class="toc-text">1.11 数组析构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-12-%E5%85%83%E7%BB%84%E8%A7%A3%E6%9E%84"><span class="toc-number">1.12.</span> <span class="toc-text">1.12 元组解构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-13-%E5%AF%B9%E8%B1%A1%E8%A7%A3%E6%9E%84"><span class="toc-number">1.13.</span> <span class="toc-text">1.13 对象解构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-14-Function-%E5%A3%B0%E6%98%8E"><span class="toc-number">1.14.</span> <span class="toc-text">1.14 Function 声明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-15-%E5%B1%95%E5%BC%80"><span class="toc-number">1.15.</span> <span class="toc-text">1.15 展开</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E5%88%AB%E5%A3%B0%E6%98%8E-%E6%9C%AC%E6%96%87%E8%BD%AC%E8%87%AA-%E5%8F%A4%E8%89%BA%E6%95%A3%E4%BA%BA%E8%80%81%E5%B8%88-%EF%BC%8C%E5%A6%82%E6%9C%89%E9%9C%80%E8%A6%81%E5%8F%AF%E5%89%8D%E5%BE%80%E5%8E%9F%E6%96%87%E9%A2%84%E8%A7%88%E6%9F%A5%E7%9C%8B%E3%80%82"><span class="toc-number">1.15.1.</span> <span class="toc-text">特别声明: 本文转自 古艺散人老师 ，如有需要可前往原文预览查看。</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/article/16495/" title="1-1、CSS中hover时出现抖动的原因和解决方法"><img src="/img/cover/cover_03.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="1-1、CSS中hover时出现抖动的原因和解决方法"></a><div class="content"><a class="title" href="/article/16495/" title="1-1、CSS中hover时出现抖动的原因和解决方法">1-1、CSS中hover时出现抖动的原因和解决方法</a><time datetime="2024-01-26T12:30:06.000Z" title="发表于 2024-01-26 20:30:06">2024-01-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/article/43000/" title="3-7、高级篇：声明合并"><img src="/img/cover/cover_01.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="3-7、高级篇：声明合并"></a><div class="content"><a class="title" href="/article/43000/" title="3-7、高级篇：声明合并">3-7、高级篇：声明合并</a><time datetime="2024-01-26T12:24:54.000Z" title="发表于 2024-01-26 20:24:54">2024-01-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/article/19249/" title="3-6、高级篇：命名空间与模块"><img src="/img/cover/cover_02.jpeg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="3-6、高级篇：命名空间与模块"></a><div class="content"><a class="title" href="/article/19249/" title="3-6、高级篇：命名空间与模块">3-6、高级篇：命名空间与模块</a><time datetime="2024-01-26T12:23:45.000Z" title="发表于 2024-01-26 20:23:45">2024-01-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/article/52849/" title="3-5、高级篇：命名空间"><img src="/img/cover/cover_01.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="3-5、高级篇：命名空间"></a><div class="content"><a class="title" href="/article/52849/" title="3-5、高级篇：命名空间">3-5、高级篇：命名空间</a><time datetime="2024-01-26T12:23:06.000Z" title="发表于 2024-01-26 20:23:06">2024-01-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/article/3652/" title="3-4、高级篇：模块解析"><img src="/img/cover/cover_02.jpeg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="3-4、高级篇：模块解析"></a><div class="content"><a class="title" href="/article/3652/" title="3-4、高级篇：模块解析">3-4、高级篇：模块解析</a><time datetime="2024-01-26T12:22:08.000Z" title="发表于 2024-01-26 20:22:08">2024-01-26</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div id="ft"><img class="ft-img" src="/img/favicon.png" alt="" srcset=""></div><div class="copyright">&copy;2020 - 2024 <i id="heartbeat" class="fa fas fa-heartbeat"></i> 泽枫</div></div></footer></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简体</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.12.0"></script><script src="/js/main.js?v=4.12.0"></script><script src="/js/tw_cn.js?v=4.12.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.32/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.js"></script><script>function panguFn(){"object"==typeof pangu?pangu.autoSpacingPage():getScript("https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js").then(()=>{pangu.autoSpacingPage()})}function panguInit(){GLOBAL_CONFIG_SITE.isPost&&panguFn()}document.addEventListener("DOMContentLoaded",panguInit)</script><div class="js-pjax"></div><script type="text/javascript" src="/js/src/jquery.js"></script><script type="text/javascript" src="/js/src/vue.js"></script><script type="text/javascript" src="/js/src/vue_js.js"></script><script type="text/javascript" src="/js/src/nav.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/fireworks.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors=["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"];var pjax=new Pjax({elements:'a:not([target="_blank"])',selectors:pjaxSelectors,cacheBust:!1,analytics:!0,scrollRestoration:!1});document.addEventListener("pjax:send",function(){if(btf.removeGlobalFnEvent("pjax"),btf.removeGlobalFnEvent("themeChange"),document.getElementById("rightside").classList.remove("rightside-show"),window.aplayers)for(let e=0;e<window.aplayers.length;e++)window.aplayers[e].options.fixed||window.aplayers[e].destroy();"object"==typeof typed&&typed.destroy();var e=document.body.classList;e.contains("read-mode")&&e.remove("read-mode"),"object"==typeof disqusjs&&disqusjs.destroy()}),document.addEventListener("pjax:complete",function(){window.refreshFn(),document.querySelectorAll("script[data-pjax]").forEach(e=>{const t=document.createElement("script");var a=e.text||e.textContent||e.innerHTML||"";Array.from(e.attributes).forEach(e=>t.setAttribute(e.name,e.value)),t.appendChild(document.createTextNode(a)),e.parentNode.replaceChild(t,e)}),GLOBAL_CONFIG.islazyload&&window.lazyLoadInstance.update(),"function"==typeof panguInit&&panguInit(),"function"==typeof gtag&&gtag("config","G-FZNMK725WD",{page_path:window.location.pathname}),"object"==typeof _hmt&&_hmt.push(["_trackPageview",window.location.pathname]),"function"==typeof loadMeting&&document.getElementsByClassName("aplayer").length&&loadMeting(),"object"==typeof Prism&&Prism.highlightAll()}),document.addEventListener("pjax:error",e=>{404===e.request.status&&pjax.loadUrl("/404.html")})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span> 数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.12.0"></script></div></div><script data-pjax>var parent,child;document.getElementById("recent-posts")&&"/"==location.pathname&&(parent=document.getElementById("recent-posts")).insertAdjacentHTML("afterbegin",child='<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms"><div class="blog-slider__img blog-slider__custom_img"><img src="/img/recommend/recommend_06.jpg" alt="/img/recommend/recommend_06.jpg"/></div><div class="blog-slider__content"><span class="blog-slider__code">2024-01-26</span><a class="blog-slider__title" href="article/8074/">1-1、基础篇：TypeScript介绍</a><div class="blog-slider__text">1-1、基础篇：TypeScript介绍</div><a class="blog-slider__button" href="article/8074/">详情</a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms"><div class="blog-slider__img blog-slider__custom_img"><img src="/img/recommend/recommend_05.jpg" alt="/img/recommend/recommend_05.jpg"/></div><div class="blog-slider__content"><span class="blog-slider__code">2024-01-26</span><a class="blog-slider__title" href="article/20247/">1-2、基础篇：TypeScript入门</a><div class="blog-slider__text">1-2、基础篇：TypeScript入门</div><a class="blog-slider__button" href="article/20247/">详情</a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms"><div class="blog-slider__img blog-slider__custom_img"><img src="/img/recommend/recommend_04.jpg" alt="/img/recommend/recommend_04.jpg"/></div><div class="blog-slider__content"><span class="blog-slider__code">2024-01-26</span><a class="blog-slider__title" href="article/19978/">1-3、基础篇：常用类型</a><div class="blog-slider__text">1-3、基础篇：常用类型</div><a class="blog-slider__button" href="article/19978/">详情</a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms"><div class="blog-slider__img blog-slider__custom_img"><img src="/img/recommend/recommend_03.jpg" alt="/img/recommend/recommend_03.jpg"/></div><div class="blog-slider__content"><span class="blog-slider__code">2024-01-26</span><a class="blog-slider__title" href="article/23966/">1-4、基础篇：类型缩小</a><div class="blog-slider__text">1-4、基础篇：类型缩小</div><a class="blog-slider__button" href="article/23966/">详情</a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms"><div class="blog-slider__img blog-slider__custom_img"><img src="/img/recommend/recommend_02.jpg" alt="/img/recommend/recommend_02.jpg"/></div><div class="blog-slider__content"><span class="blog-slider__code">2024-01-26</span><a class="blog-slider__title" href="article/30791/">1-5、基础篇：函数更多</a><div class="blog-slider__text">1-5、基础篇：函数更多</div><a class="blog-slider__button" href="article/30791/">详情</a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms"><div class="blog-slider__img blog-slider__custom_img"><img src="/img/recommend/recommend_01.jpg" alt="/img/recommend/recommend_01.jpg"/></div><div class="blog-slider__content"><span class="blog-slider__code">2024-01-26</span><a class="blog-slider__title" href="article/59398/">1-6、基础篇：对象类型</a><div class="blog-slider__text">1-6、基础篇：对象类型</div><a class="blog-slider__button" href="article/59398/">详情</a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>')</script><script data-pjax src="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-swiper/swiper/swiper.min.js"></script><script data-pjax src="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-swiper@0.18/swiper/swiperindex.js"></script><style></style></body></html>