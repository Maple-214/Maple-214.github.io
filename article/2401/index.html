<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"><title>1-7、基础篇：类型操纵 | 澤楓の小屋</title><meta name="author" content="泽枫"><meta name="copyright" content="泽枫"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="七、类型操纵7.0 从类型中创建类型TypeScript的类型系统非常强大，因为它允许用其他类型的术语来表达类型。 这个想法的最简单的形式是泛型，我们实际上有各种各样的类型操作符可以使用。也可以用我们已经有的值来表达类型。 通过结合各种类型操作符，我们可以用一种简洁、可维护的方式来表达复杂的操作和值。在本节中，我们将介绍用现有的类型或值来表达一个新类型的方法。  泛型型 - 带参数的类型  Key"><meta property="og:type" content="article"><meta property="og:title" content="1-7、基础篇：类型操纵"><meta property="og:url" content="https://maple-214.cn/article/2401/index.html"><meta property="og:site_name" content="澤楓の小屋"><meta property="og:description" content="七、类型操纵7.0 从类型中创建类型TypeScript的类型系统非常强大，因为它允许用其他类型的术语来表达类型。 这个想法的最简单的形式是泛型，我们实际上有各种各样的类型操作符可以使用。也可以用我们已经有的值来表达类型。 通过结合各种类型操作符，我们可以用一种简洁、可维护的方式来表达复杂的操作和值。在本节中，我们将介绍用现有的类型或值来表达一个新类型的方法。  泛型型 - 带参数的类型  Key"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://maple-214.cn/img/cover/cover_03.jpg"><meta property="article:published_time" content="2024-01-26T12:11:50.000Z"><meta property="article:modified_time" content="2024-01-26T12:25:37.733Z"><meta property="article:author" content="泽枫"><meta property="article:tag" content="前端"><meta property="article:tag" content="TypeScript"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://maple-214.cn/img/cover/cover_03.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://maple-214.cn/article/2401/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//www.google-analytics.com" crossorigin=""><link rel="preconnect" href="//hm.baidu.com"><link rel="preconnect" href="//busuanzi.ibruce.info"><meta name="google-site-verification" content="OAauFcQX49kS2UGN9SShSqwNxfrsByxSVXRfNyc"><meta name="baidu-site-verification" content="codeva-JddVaE5CKl"><link rel="stylesheet" href="/css/index.css?v=4.12.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.32/dist/fancybox/fancybox.min.css" media="print" onload='this.media="all"'><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(adsbygoogle=window.adsbygoogle||[]).push({google_ad_client:"ca-pub-4229599433514996",enable_page_level_ads:"true"})</script><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script"),t=(e.src="https://hm.baidu.com/hm.js?6df43866b91212ab3dbadbcfd5966f6c",document.getElementsByTagName("script")[0]);t.parentNode.insertBefore(e,t)}()</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-FZNMK725WD"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-FZNMK725WD")</script><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"/search.xml",preload:!0,top_n_per_article:1,unescape:!1,languages:{hits_empty:"找不到您查询的内容：${query}",hits_stats:"共找到 ${hits} 篇文章"}},translate:{defaultEncoding:2,translateDelay:0,msgToTraditionalChinese:"繁体",msgToSimplifiedChinese:"简体"},noticeOutdate:void 0,highlight:{plugin:"highlight.js",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:150},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"",dateSuffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:{limitCount:50,languages:{author:"作者: 泽枫",link:"链接: ",source:"来源: 澤楓の小屋",info:"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},lightbox:"fancybox",Snackbar:{chs_to_cht:"你已切换为繁体中文",cht_to_chs:"你已切换为简体中文",day_to_night:"你已切换为深色模式",night_to_day:"你已切换为浅色模式",bgLight:"#49b1f5",bgDark:"#1f1f1f",position:"bottom-left"},infinitegrid:{js:"https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.0/dist/infinitegrid.min.js",buttonText:"加载更多"},isPhotoFigcaption:!0,islazyload:!1,isAnchor:!1,percent:{toc:!0,rightside:!0},autoDarkmode:!1}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"1-7、基础篇：类型操纵",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2024-01-26 20:25:37"}</script><script>(e=>{e.saveToLocal={set:(e,t,a)=>{var o;0!==a&&(o=Date.now(),localStorage.setItem(e,JSON.stringify({value:t,expiry:o+864e5*a})))},get:e=>{var t=localStorage.getItem(e);if(t){t=JSON.parse(t);if(!(Date.now()>t.expiry))return t.value;localStorage.removeItem(e)}}},e.getScript=(o,n={})=>new Promise((t,e)=>{const a=document.createElement("script");a.src=o,a.async=!0,a.onerror=e,a.onload=a.onreadystatechange=function(){var e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(a.onload=a.onreadystatechange=null,t())},Object.keys(n).forEach(e=>{a.setAttribute(e,n[e])}),document.head.appendChild(a)}),e.getCSS=(o,n=!1)=>new Promise((t,e)=>{const a=document.createElement("link");a.rel="stylesheet",a.href=o,n&&(a.id=n),a.onerror=e,a.onload=a.onreadystatechange=function(){var e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(a.onload=a.onreadystatechange=null,t())},document.head.appendChild(a)}),e.activateDarkMode=()=>{document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=()=>{document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};e=saveToLocal.get("theme"),"dark"===e?activateDarkMode():"light"===e&&activateLightMode(),e=saveToLocal.get("aside-status");void 0!==e&&("hide"===e?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"));/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})(window)</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-swiper/swiper/swiper.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-swiper/swiper/swiperstyle.css"><meta name="generator" content="Hexo 7.1.1"><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head><body><script async src="/js/src/sakura.js"></script><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{const d=document.getElementById("loading-box"),e=document.body,o={endLoading:()=>{e.style.overflow="",d.classList.add("loaded")},initLoading:()=>{e.style.overflow="hidden",d.classList.remove("loaded")}};o.initLoading(),window.addEventListener("load",()=>{o.endLoading()})})()</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">26</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">3</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><hr class="custom-hr"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image:url(/img/cover/cover_03.jpg)"><nav id="nav"><span id="blog-info"><a href="/" title="澤楓の小屋">澤楓の小屋</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div></div><center id="name-container"><a id="page-name" href="javascript:scrollToTop()">PAGE_NAME</a></center></div><div id="nav-right"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">1-7、基础篇：类型操纵</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-01-26T12:11:50.000Z" title="发表于 2024-01-26 20:11:50">2024-01-26</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-01-26T12:25:37.733Z" title="更新于 2024-01-26 20:25:37">2024-01-26</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/TypeScript/">TypeScript</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title="1-7、基础篇：类型操纵"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="七、类型操纵"><a href="#七、类型操纵" class="headerlink" title="七、类型操纵"></a>七、类型操纵</h1><h2 id="7-0-从类型中创建类型"><a href="#7-0-从类型中创建类型" class="headerlink" title="7.0 从类型中创建类型"></a>7.0 从类型中创建类型</h2><p>TypeScript的类型系统非常强大，因为它允许用其他类型的术语来表达类型。</p><p>这个想法的最简单的形式是泛型，我们实际上有各种各样的类型操作符可以使用。也可以用我们已经有的值来表达类型。</p><p>通过结合各种类型操作符，我们可以用一种简洁、可维护的方式来表达复杂的操作和值。在本节中，我们将介绍用现有的类型或值来表达一个新类型的方法。</p><ul><li><p>泛型型 - 带参数的类型</p></li><li><p>Keyof 类型操作符- <code>keyof</code> 操作符创建新类型</p></li><li><p>Typeof 类型操作符 - 使用 <code>typeof</code> 操作符来创建新的类型&#96;</p></li><li><p>索引访问类型 - 使用 <code>Type[&#39;a&#39;]</code> 语法来访问一个类型的子集</p></li><li><p>条件类型 - 在类型系统中像if语句一样行事的类型</p></li><li><p>映射类型 - 通过映射现有类型中的每个属性来创建类型</p></li><li><p>模板字面量类型 - 通过模板字面字符串改变属性的映射类型</p></li></ul><h2 id="7-1-泛型"><a href="#7-1-泛型" class="headerlink" title="7.1 泛型"></a>7.1 泛型</h2><p>软件工程的一个主要部分是建立组件，这些组件不仅有定义明确和一致的API，而且还可以重复使用。能够处理今天的数据和明天的数据的组件将为你建立大型软件系统提供最灵活的能力。</p><p>在像C#和Java这样的语言中，创建可重用组件的工具箱中的主要工具之一是泛型，也就是说，能够创建一个在各种类型上工作的组件，而不是单一的类型。这使得用户可以消费这些组件并使用他们自己的类型。</p><h3 id="7-1-1-Hello-World"><a href="#7-1-1-Hello-World" class="headerlink" title="7.1.1 Hello World"></a>7.1.1 Hello World</h3><p>首先，让我们做一下泛型的 “ hello world”：身份函数。身份函数是一个函数，它将返回传入的任何内容。你可以用类似于echo命令的方式来考虑它。</p><p>如果没有泛型，我们将不得不给身份函数一个特定的类型。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">identity</span>(<span class="params">arg: <span class="built_in">number</span></span>): <span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者，我们可以用任意类型来描述身份函数。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">identity</span>(<span class="params">arg: <span class="built_in">any</span></span>): <span class="built_in">any</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>any</code> 当然是通用的，因为它将使函数接受 <code>arg</code>类型的任何和所有的类型，但实际上我们在函数返回时失去了关于该类型的信息。如果我们传入一个数字，我们唯一的信息就是任何类型都可以被返回。</p><p>相反，我们需要一种方法来捕获参数的类型，以便我们也可以用它来表示返回的内容。在这里，我们将使用一个类型变量，这是一种特殊的变量，对类型而不是数值起作用。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> identity&lt;<span class="title class_">Type</span>&gt;(<span class="attr">arg</span>: <span class="title class_">Type</span>): <span class="title class_">Type</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们现在已经在身份函数中添加了一个类型变量 <code>Type</code>。这个 <code>Type</code> 允许我们捕获用户提供的类型（例如数字），这样我们就可以在以后使用这些信息。这里，我们再次使用Type作为返回类型。经过检查，我们现在可以看到参数和返回类型使用的是相同的类型。这使得我们可以将类型信息从函数的一侧输入，然后从另一侧输出。</p><p>我们说这个版本的身份函数是通用的，因为它在一系列的类型上工作。与使用任何类型不同的是，它也和第一个使用数字作为参数和返回类型的身份函数一样精确（即，它不会丢失任何信息）。</p><p>一旦我们写好了通用身份函数，我们就可以用两种方式之一来调用它。第一种方式是将所有的参数，包括类型参数，都传递给函数：</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> output = identity&lt;<span class="built_in">string</span>&gt;(<span class="string">&quot;myString&quot;</span>);</span><br></pre></td></tr></table></figure><p>这里我们明确地将 <code>Type</code> 设置为<code>string</code>，作为函数调用的参数之一，用参数周围的 <code>&lt;&gt;</code> 而不是 <code>()</code> 来表示。</p><p>第二种方式可能也是最常见的。这里我们使用类型参数推理——也就是说，我们希望编译器根据我们传入的参数的类型，自动为我们设置 <code>Type</code> 的值。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> output = <span class="title function_">identity</span>(<span class="string">&quot;myString&quot;</span>);</span><br></pre></td></tr></table></figure><p>注意，我们不必在角括号（&lt;&gt;）中明确地传递类型；编译器只是查看了 “myString “这个值，并将Type设置为其类型。虽然类型参数推断是一个有用的工具，可以使代码更短、更易读，但当编译器不能推断出类型时，你可能需要像我们在前面的例子中那样明确地传入类型参数，这在更复杂的例子中可能发生。</p><h3 id="7-1-2-使用通用类型变量"><a href="#7-1-2-使用通用类型变量" class="headerlink" title="7.1.2 使用通用类型变量"></a>7.1.2 使用通用类型变量</h3><p>当你开始使用泛型时，你会注意到，当你创建像<code>identity</code>这样的泛型函数时，编译器会强制要求你在函数主体中正确使用任何泛型参数。也就是说，你实际上是把这些参数当作是任何和所有的类型。</p><p>让我们来看看我们前面的 <code>identity</code> 函数。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> identity&lt;<span class="title class_">Type</span>&gt;(<span class="attr">arg</span>: <span class="title class_">Type</span>): <span class="title class_">Type</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们想在每次调用时将参数 <code>arg</code> 的长度记录到控制台，该怎么办？我们可能很想这样写：</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> loggingIdentity&lt;<span class="title class_">Type</span>&gt;(<span class="attr">arg</span>: <span class="title class_">Type</span>): <span class="title class_">Type</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(arg.<span class="property">length</span>);</span><br><span class="line">  <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://s2.loli.net/2022/02/22/dqsOFKoSHTPJBMv.png" alt="image-20211127215153933" style="zoom:50%"><p>当我们这样做时，编译器会给我们一个错误，说我们在使用 <code>arg</code> 的 <code>.length</code> 成员，但我们没有说 <code>arg</code> 有这个成员。记住，我们在前面说过，这些类型的变量可以代表任何和所有的类型，所以使用这个函数的人可以传入一个<code>number</code> ，而这个数字没有一个 <code>.length</code> 成员。</p><p>比方说，我们实际上是想让这个函数在 <code>Type</code> 的数组上工作，而不是直接在 <code>Type</code>上工作。既然我们在处理数组，那么<code>.length</code>成员应该是可用的。我们可以像创建其他类型的数组那样来描述它。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> loggingIdentity&lt;<span class="title class_">Type</span>&gt;(<span class="attr">arg</span>: <span class="title class_">Type</span>[]): <span class="title class_">Type</span>[] &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(arg.<span class="property">length</span>);</span><br><span class="line">  <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以把 <code>loggingIdentity</code> 的类型理解为 “通用函数 <code>loggingIdentity</code> 接收一个类型参数 <code>Type</code> 和一个参数 <code>arg</code>，<code>arg</code>是一个<code>Type</code>数组，并返回一个<code>Type</code>数组。” 如果我们传入一个数字数组，我们会得到一个数字数组，因为Type会绑定到数字。这允许我们使用我们的通用类型变量 <code>Type</code> 作为我们正在处理的类型的一部分，而不是整个类型，给我们更大的灵活性。</p><p>我们也可以这样来写这个例子：</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> loggingIdentity&lt;<span class="title class_">Type</span>&gt;(<span class="attr">arg</span>: <span class="title class_">Array</span>&lt;<span class="title class_">Type</span>&gt;): <span class="title class_">Array</span>&lt;<span class="title class_">Type</span>&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(arg.<span class="property">length</span>); <span class="comment">// 数组有一个.length，所以不会再出错了</span></span><br><span class="line">  <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可能已经从其他语言中熟悉了这种类型的风格。在下一节中，我们将介绍如何创建你自己的通用类型，如<code>Array&lt;Type&gt;</code>。</p><h3 id="7-1-3-泛型类型"><a href="#7-1-3-泛型类型" class="headerlink" title="7.1.3 泛型类型"></a>7.1.3 泛型类型</h3><p>在前几节中，我们创建了在一系列类型上工作的通用身份函数。在这一节中，我们将探讨函数本身的类型以及如何创建通用接口。</p><p>泛型函数的类型与非泛型函数的类型一样，类型参数列在前面，与函数声明类似：</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> identity&lt;<span class="title class_">Type</span>&gt;(<span class="attr">arg</span>: <span class="title class_">Type</span>): <span class="title class_">Type</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">myIdentity</span>: &lt;<span class="title class_">Type</span>&gt;<span class="function">(<span class="params">arg: Type</span>) =&gt;</span> <span class="title class_">Type</span> = identity;</span><br></pre></td></tr></table></figure><p>我们也可以为类型中的通用类型参数使用一个不同的名字，只要类型变量的数量和类型变量的使用方式一致。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> identity&lt;<span class="title class_">Type</span>&gt;(<span class="attr">arg</span>: <span class="title class_">Type</span>): <span class="title class_">Type</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">myIdentity</span>: &lt;<span class="title class_">Input</span>&gt;<span class="function">(<span class="params">arg: Input</span>) =&gt;</span> <span class="title class_">Input</span> = identity;</span><br></pre></td></tr></table></figure><p>我们也可以把泛型写成一个对象字面类型的调用签名。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> identity&lt;<span class="title class_">Type</span>&gt;(<span class="attr">arg</span>: <span class="title class_">Type</span>): <span class="title class_">Type</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">myIdentity</span>: &#123; &lt;<span class="title class_">Type</span>&gt;(<span class="attr">arg</span>: <span class="title class_">Type</span>): <span class="title class_">Type</span> &#125; = identity;</span><br></pre></td></tr></table></figure><p>这让我们开始编写我们的第一个泛型接口。让我们把前面例子中的对象字面意思移到一个接口中。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">GenericIdentityFn</span> &#123;</span><br><span class="line">  &lt;<span class="title class_">Type</span>&gt;(<span class="attr">arg</span>: <span class="title class_">Type</span>): <span class="title class_">Type</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> identity&lt;<span class="title class_">Type</span>&gt;(<span class="attr">arg</span>: <span class="title class_">Type</span>): <span class="title class_">Type</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">myIdentity</span>: <span class="title class_">GenericIdentityFn</span> = identity;</span><br></pre></td></tr></table></figure><p>在一个类似的例子中，我们可能想把通用参数移到整个接口的参数上。这可以让我们看到我们的泛型是什么类型（例如，<code>Dictionary&lt;string&gt;</code>而不是仅仅<code>Dictionary</code>）。这使得类型参数对接口的所有其他成员可见。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">GenericIdentityFn</span>&lt;<span class="title class_">Type</span>&gt; &#123;</span><br><span class="line">  (<span class="attr">arg</span>: <span class="title class_">Type</span>): <span class="title class_">Type</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> identity&lt;<span class="title class_">Type</span>&gt;(<span class="attr">arg</span>: <span class="title class_">Type</span>): <span class="title class_">Type</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">myIdentity</span>: <span class="title class_">GenericIdentityFn</span>&lt;<span class="built_in">number</span>&gt; = identity;</span><br></pre></td></tr></table></figure><p>请注意，我们的例子已经改变了，变成了稍微不同的东西。我们现在没有描述一个泛型函数，而是有一个非泛型的函数签名，它是泛型类型的一部分。当我们使用 <code>GenericIdentityFn</code> 时，我们现在还需要指定相应的类型参数（这里是：数字），有效地锁定了底层调用签名将使用什么。了解什么时候把类型参数直接放在调用签名上，什么时候把它放在接口本身，将有助于描述一个类型的哪些方面是通用的。</p><p>除了泛型接口之外，我们还可以创建泛型类。注意，不可能创建泛型枚举和命名空间。</p><h3 id="7-1-4-泛型类"><a href="#7-1-4-泛型类" class="headerlink" title="7.1.4 泛型类"></a>7.1.4 泛型类</h3><p>一个泛型类的形状与泛型接口相似。泛型类在类的名字后面有一个角括号（&lt;&gt;）中的泛型参数列表。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GenericNumber</span>&lt;<span class="title class_">NumType</span>&gt; &#123;</span><br><span class="line">  <span class="attr">zeroValue</span>: <span class="title class_">NumType</span>;</span><br><span class="line">  <span class="attr">add</span>: <span class="function">(<span class="params">x: NumType, y: NumType</span>) =&gt;</span> <span class="title class_">NumType</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myGenericNumber = <span class="keyword">new</span> <span class="title class_">GenericNumber</span>&lt;<span class="built_in">number</span>&gt;();</span><br><span class="line">myGenericNumber.<span class="property">zeroValue</span> = <span class="number">0</span>;</span><br><span class="line">myGenericNumber.<span class="property">add</span> = <span class="keyword">function</span> (<span class="params">x, y</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这是对<code>GenericNumber</code>类相当直白的使用，但你可能已经注意到，没有任何东西限制它只能使用数字类型。我们本可以使用字符串或更复杂的对象。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> stringNumeric = <span class="keyword">new</span> <span class="title class_">GenericNumber</span>&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line">stringNumeric.<span class="property">zeroValue</span> = <span class="string">&quot;&quot;</span>;</span><br><span class="line">stringNumeric.<span class="property">add</span> = <span class="keyword">function</span> (<span class="params">x, y</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringNumeric.<span class="title function_">add</span>(stringNumeric.<span class="property">zeroValue</span>, <span class="string">&quot;test&quot;</span>));</span><br></pre></td></tr></table></figure><p>就像接口一样，把类型参数放在类本身，可以让我们确保类的所有属性都与相同的类型一起工作。</p><p>正如我们在关于类的章节中提到的，一个类的类型有两个方面：静态方面和实例方面。通用类只在其实例侧而非静态侧具有通用性，所以在使用类时，静态成员不能使用类的类型参数。</p><h3 id="7-1-5-泛型约束"><a href="#7-1-5-泛型约束" class="headerlink" title="7.1.5 泛型约束"></a>7.1.5 泛型约束</h3><p>如果你还记得前面的例子，你有时可能想写一个通用函数，在一组类型上工作，而你对这组类型会有什么能力有一定的了解。在我们的 <code>loggingIdentity</code> 例子中，我们希望能够访问 <code>arg.length</code> 属性，但是编译器无法证明每个类型都有一个 <code>.length</code> 属性，所以它警告我们不能做这个假设。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> loggingIdentity&lt;<span class="title class_">Type</span>&gt;(<span class="attr">arg</span>: <span class="title class_">Type</span>): <span class="title class_">Type</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(arg.<span class="property">length</span>);</span><br><span class="line">  <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://s2.loli.net/2022/02/22/gS8VUxOYPyER62K.png" alt="image-20211128095950588" style="zoom:50%"><p>我们希望限制这个函数与 <code>any</code> 和所有类型一起工作，而不是与 <code>any</code> 和所有同时具有 <code>.length</code> 属性的类型一起工作。只要这个类型有这个成员，我们就允许它，但它必须至少有这个成员。要做到这一点，我们必须把我们的要求作为一个约束条件列在 <code>Type</code> 可以是什么。</p><p>为了做到这一点，我们将创建一个接口来描述我们的约束。在这里，我们将创建一个接口，它有一个单一的 <code>.length</code> 属性，然后我们将使用这个接和 <code>extends</code> 关键字来表示我们的约束条件。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Lengthwise</span> &#123;</span><br><span class="line">  <span class="attr">length</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> loggingIdentity&lt;<span class="title class_">Type</span> <span class="keyword">extends</span> <span class="title class_">Lengthwise</span>&gt;(<span class="attr">arg</span>: <span class="title class_">Type</span>): <span class="title class_">Type</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(arg.<span class="property">length</span>); <span class="comment">// 现在我们知道它有一个 .length 属性，所以不再有错误了</span></span><br><span class="line">  <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为泛型函数现在被限制了，它将不再对 <code>any</code> 和 所有的类型起作用。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">loggingIdentity(3);</span><br></pre></td></tr></table></figure><img src="/img/TypeScript/07-03.png" alt="image-20211128102358263" style="zoom:50%"><p>相反，我们需要传入其类型具有所有所需属性的值。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="title function_">loggingIdentity</span>(&#123; <span class="attr">length</span>: <span class="number">10</span>, <span class="attr">value</span>: <span class="number">3</span> &#125;);</span><br></pre></td></tr></table></figure><h3 id="7-1-6-在泛型约束中使用类型参数"><a href="#7-1-6-在泛型约束中使用类型参数" class="headerlink" title="7.1.6 在泛型约束中使用类型参数"></a>7.1.6 在泛型约束中使用类型参数</h3><p>你可以声明一个受另一个类型参数约束的类型参数。例如，在这里我们想从一个给定名称的对象中获取一个属性。我们想确保我们不会意外地获取一个不存在于 <code>obj</code> 上的属性，所以我们要在这两种类型之间放置一个约束条件。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> getProperty&lt;<span class="title class_">Type</span>, <span class="title class_">Key</span> <span class="keyword">extends</span> keyof <span class="title class_">Type</span>&gt;(<span class="attr">obj</span>: <span class="title class_">Type</span>, <span class="attr">key</span>: <span class="title class_">Key</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> obj[key];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> x = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">3</span>, <span class="attr">d</span>: <span class="number">4</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">getProperty</span>(x, <span class="string">&quot;a&quot;</span>);</span><br><span class="line"><span class="title function_">getProperty</span>(x, <span class="string">&quot;m&quot;</span>);</span><br></pre></td></tr></table></figure><img src="https://s2.loli.net/2022/02/22/MrLOcvzYgSbophf.png" alt="image-20211128103719103" style="zoom:50%"><h3 id="7-1-7-在泛型中使用类类型"><a href="#7-1-7-在泛型中使用类类型" class="headerlink" title="7.1.7 在泛型中使用类类型"></a>7.1.7 在泛型中使用类类型</h3><p>在TypeScript中使用泛型创建工厂时，有必要通过其构造函数来引用类的类型。比如说：</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> create&lt;<span class="title class_">Type</span>&gt;(<span class="attr">c</span>: &#123; <span class="keyword">new</span> (): <span class="title class_">Type</span> &#125;): <span class="title class_">Type</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">c</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个更高级的例子，使用原型属性来推断和约束类类型的构造函数和实例方之间的关系。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BeeKeeper</span> &#123;</span><br><span class="line">  <span class="attr">hasMask</span>: <span class="built_in">boolean</span> = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ZooKeeper</span> &#123;</span><br><span class="line">  <span class="attr">nametag</span>: <span class="built_in">string</span> = <span class="string">&quot;Mikle&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="attr">numLegs</span>: <span class="built_in">number</span> = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bee</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;</span><br><span class="line">  <span class="attr">keeper</span>: <span class="title class_">BeeKeeper</span> = <span class="keyword">new</span> <span class="title class_">BeeKeeper</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Lion</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;</span><br><span class="line">  <span class="attr">keeper</span>: <span class="title class_">ZooKeeper</span> = <span class="keyword">new</span> <span class="title class_">ZooKeeper</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> createInstance&lt;A <span class="keyword">extends</span> <span class="title class_">Animal</span>&gt;(<span class="attr">c</span>: <span class="keyword">new</span> () =&gt; A): A &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">c</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">createInstance</span>(<span class="title class_">Lion</span>).<span class="property">keeper</span>.<span class="property">nametag</span>;</span><br><span class="line"><span class="title function_">createInstance</span>(<span class="title class_">Bee</span>).<span class="property">keeper</span>.<span class="property">hasMask</span>;</span><br></pre></td></tr></table></figure><h2 id="7-2-Keyof类型操作符"><a href="#7-2-Keyof类型操作符" class="headerlink" title="7.2 Keyof类型操作符"></a>7.2 <code>Keyof</code>类型操作符</h2><p><code>keyof</code>运算符接收一个对象类型，并产生其键的字符串或数字字面联合。下面的类型P与 “x”|”y “是同一类型。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Point</span> = &#123; <span class="attr">x</span>: <span class="built_in">number</span>; <span class="attr">y</span>: <span class="built_in">number</span> &#125;;</span><br><span class="line"><span class="keyword">type</span> P = keyof <span class="title class_">Point</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">p1</span>: P = <span class="string">&quot;x&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">p2</span>: P = <span class="string">&quot;y&quot;</span>;</span><br></pre></td></tr></table></figure><p>如果该类型有一个字符串或数字索引签名，<code>keyof</code> 将返回这些类型。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Arrayish</span> = &#123; [<span class="attr">n</span>: <span class="built_in">number</span>]: <span class="built_in">unknown</span> &#125;;</span><br><span class="line"><span class="keyword">type</span> A = keyof <span class="title class_">Arrayish</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">a</span>: A = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Mapish</span> = &#123; [<span class="attr">k</span>: <span class="built_in">string</span>]: <span class="built_in">boolean</span> &#125;;</span><br><span class="line"><span class="keyword">type</span> M = keyof <span class="title class_">Mapish</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">m</span>: M = <span class="string">&quot;a&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">m2</span>: M = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>注意，在这个例子中，<code>M</code>是 <code>string|number</code>——这是因为JavaScript对象的键总是被强制为字符串，所以 <code>obj[0]</code>总是与<code>obj[&quot;0&quot;]</code>相同。</p><p><code>keyof</code>类型在与映射类型结合时变得特别有用，我们将在后面进一步了解。</p><h2 id="7-3-Typeof-类型操作符"><a href="#7-3-Typeof-类型操作符" class="headerlink" title="7.3 Typeof 类型操作符"></a>7.3 <code>Typeof</code> 类型操作符</h2><p>JavaScript已经有一个 <code>typeof</code> 操作符，你可以在表达式上下文中使用。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 输出 &quot;string&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="string">&quot;Hello world&quot;</span>);</span><br></pre></td></tr></table></figure><p>TypeScript添加了一个<code>typeof</code>操作符，你可以在类型上下文中使用它来引用一个变量或属性的类型。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">n</span>: <span class="keyword">typeof</span> s;</span><br><span class="line">n = <span class="string">&quot;world&quot;</span>;</span><br><span class="line">n = <span class="number">100</span>;</span><br></pre></td></tr></table></figure><img src="/img/TypeScript/07-05.png" alt="image-20211128110305093" style="zoom:50%"><p>这对基本类型来说不是很有用，但结合其他类型操作符，你可以使用typeof来方便地表达许多模式。举一个例子，让我们先看看预定义的类型<code>ReturnType&lt;T&gt;</code>。它接收一个函数类型并产生其返回类型：</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Predicate</span> = <span class="function">(<span class="params">x: <span class="built_in">unknown</span></span>) =&gt;</span> <span class="built_in">boolean</span>;</span><br><span class="line"><span class="keyword">type</span> K = <span class="title class_">ReturnType</span>&lt;<span class="title class_">Predicate</span>&gt;;</span><br></pre></td></tr></table></figure><p>如果我们试图在一个函数名上使用 <code>ReturnType</code>，我们会看到一个指示性的错误。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">x</span>: <span class="number">10</span>, <span class="attr">y</span>: <span class="number">3</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> P = <span class="title class_">ReturnType</span>&lt;f&gt;;</span><br></pre></td></tr></table></figure><img src="https://s2.loli.net/2022/02/22/foM6iTw7GecalgD.png" alt="image-20211128111022283" style="zoom:50%"><p>请记住，值和类型并不是一回事。为了指代值f的类型，我们使用 <code>typeof</code>。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">x</span>: <span class="number">10</span>, <span class="attr">y</span>: <span class="number">3</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> P = <span class="title class_">ReturnType</span>&lt;<span class="keyword">typeof</span> f&gt;;</span><br></pre></td></tr></table></figure><p>TypeScript 故意限制了你可以使用 typeof 的表达式种类。</p><p>具体来说，只有在标识符（即变量名）或其属性上使用typeof是合法的。这有助于避免混乱的陷阱，即编写你认为是在执行的代码，但其实不是。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 我们认为使用 = ReturnType&lt;typeof msgbox&gt;</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">shouldContinue</span>: <span class="keyword">typeof</span> <span class="title function_">msgbox</span>(<span class="string">&quot;Are you sure you want to continue?&quot;</span>);</span><br></pre></td></tr></table></figure><img src="https://s2.loli.net/2022/02/22/AUnW94tZuiI2fLw.png" alt="image-20211128111627727" style="zoom:50%"><h2 id="7-4-索引访问类型"><a href="#7-4-索引访问类型" class="headerlink" title="7.4 索引访问类型"></a>7.4 索引访问类型</h2><p>我们可以使用一个索引访问类型来查询另一个类型上的特定属性：</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Person</span> = &#123; <span class="attr">age</span>: <span class="built_in">number</span>; <span class="attr">name</span>: <span class="built_in">string</span>; <span class="attr">alive</span>: <span class="built_in">boolean</span> &#125;;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Age</span> = <span class="title class_">Person</span>[<span class="string">&quot;age&quot;</span>];</span><br></pre></td></tr></table></figure><img src="https://s2.loli.net/2022/02/22/vdRnGwYBI6r4Elx.png" alt="image-20211128114411725" style="zoom:50%"><p>索引类型本身就是一个类型，所以我们可以完全使用 unions、<code>keyof</code> 或者其他类型。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">alive</span>: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// type I1 = string | number</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">I1</span> = <span class="title class_">Person</span>[<span class="string">&quot;age&quot;</span> | <span class="string">&quot;name&quot;</span>];</span><br><span class="line"><span class="keyword">const</span> <span class="attr">i11</span>: <span class="variable constant_">I1</span> = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">i12</span>: <span class="variable constant_">I1</span> = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// type I2 = string | number | boolean</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">I2</span> = <span class="title class_">Person</span>[keyof <span class="title class_">Person</span>];</span><br><span class="line"><span class="keyword">const</span> <span class="attr">i21</span>: <span class="variable constant_">I2</span> = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">i22</span>: <span class="variable constant_">I2</span> = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">i23</span>: <span class="variable constant_">I2</span> = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// type I3 = Person[AliveOrName];</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">AliveOrName</span> = <span class="string">&quot;alive&quot;</span> | <span class="string">&quot;name&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">aon1</span>: <span class="title class_">AliveOrName</span> = <span class="string">&quot;alive&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">aon2</span>: <span class="title class_">AliveOrName</span> = <span class="string">&quot;name&quot;</span>;</span><br></pre></td></tr></table></figure><p>如果你试图索引一个不存在的属性，你甚至会看到一个错误：</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="variable constant_">I1</span> = <span class="title class_">Person</span>[<span class="string">&quot;alve&quot;</span>];</span><br></pre></td></tr></table></figure><img src="https://s2.loli.net/2022/02/22/aKBPU27y5pJLQz3.png" alt="image-20211128115726772" style="zoom:50%"><p>另一个使用任意类型进行索引的例子是使用<code>number</code>来获取一个数组元素的类型。我们可以把它和 <code>typeof</code>结合起来，方便地获取一个数组字面的元素类型。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">MyArray</span> = [</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&quot;Alice&quot;</span>, <span class="attr">age</span>: <span class="number">15</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&quot;Bob&quot;</span>, <span class="attr">age</span>: <span class="number">23</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&quot;Eve&quot;</span>, <span class="attr">age</span>: <span class="number">38</span> &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">/* type Person = &#123;</span></span><br><span class="line"><span class="comment">    name: string;</span></span><br><span class="line"><span class="comment">    age: number;</span></span><br><span class="line"><span class="comment">&#125; */</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Person</span> = (<span class="keyword">typeof</span> <span class="title class_">MyArray</span>)[<span class="built_in">number</span>];</span><br><span class="line"><span class="keyword">const</span> <span class="attr">p</span>: <span class="title class_">Person</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;xiaoqian&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">11</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// type Age = number</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Age</span> = (<span class="keyword">typeof</span> <span class="title class_">MyArray</span>)[<span class="built_in">number</span>][<span class="string">&quot;age&quot;</span>];</span><br><span class="line"><span class="keyword">const</span> <span class="attr">age</span>: <span class="title class_">Age</span> = <span class="number">11</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="comment">// type Age2 = number</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Age2</span> = <span class="title class_">Person</span>[<span class="string">&quot;age&quot;</span>];</span><br><span class="line"><span class="keyword">const</span> <span class="attr">age2</span>: <span class="title class_">Age2</span> = <span class="number">11</span>;</span><br></pre></td></tr></table></figure><p>你只能在索引时使用类型，这意味着你不能使用<code>const</code>来做一个变量引用：</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> key = <span class="string">&quot;age&quot;</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Age</span> = <span class="title class_">Person</span>[key];</span><br></pre></td></tr></table></figure><img src="/img/TypeScript/08-03.png" alt="image-20211128122324127" style="zoom:60%"><p>然而，你可以使用类型别名来实现类似的重构风格：</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> key = <span class="string">&quot;age&quot;</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Age</span> = <span class="title class_">Person</span>[key];</span><br></pre></td></tr></table></figure><h2 id="7-5-条件类型"><a href="#7-5-条件类型" class="headerlink" title="7.5 条件类型"></a>7.5 条件类型</h2><p>在大多数有用的程序的核心，我们必须根据输入来做决定。JavaScript程序也不例外，但鉴于数值可以很容易地被内省，这些决定也是基于输入的类型。条件类型有助于描述输入和输出的类型之间的关系。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="title function_">live</span>(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="title function_">woof</span>(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// type Example1 = number</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Example1</span> = <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> ? <span class="built_in">number</span> : <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// type Example2 = string</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Example2</span> = <span class="title class_">RegExp</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> ? <span class="built_in">number</span> : <span class="built_in">string</span>;</span><br></pre></td></tr></table></figure><p>条件类型的形式看起来有点像JavaScript中的条件表达式（<code>condition ? trueExpression : falseExpression</code>）。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="title class_">SomeType</span> <span class="keyword">extends</span> <span class="title class_">OtherType</span> ? <span class="title class_">TrueType</span> : <span class="title class_">FalseType</span>;</span><br></pre></td></tr></table></figure><p>当 <code>extends</code> 左边的类型可以赋值给右边的类型时，那么你将得到第一个分支中的类型（”真 “分支）；否则你将得到后一个分支中的类型（”假 “分支）。</p><p>从上面的例子来看，条件类型可能并不立即显得有用——我们可以告诉自己是否 <code>Dog extends Animal</code>，并选择 <code>number</code>或<code>string</code>！但条件类型的威力来自于它所带来的好处。条件类型的力量来自于将它们与泛型一起使用。</p><p>例如，让我们来看看下面这个 <code>createLabel</code> 函数：</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IdLabel</span> &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="built_in">number</span> <span class="comment">/* 一些字段 */</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">NameLabel</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span> <span class="comment">/* 另一些字段 */</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createLabel</span>(<span class="params">id: <span class="built_in">number</span></span>): <span class="title class_">IdLabel</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createLabel</span>(<span class="params">name: <span class="built_in">string</span></span>): <span class="title class_">NameLabel</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createLabel</span>(<span class="params">nameOrId: <span class="built_in">string</span> | <span class="built_in">number</span></span>): <span class="title class_">IdLabel</span> | <span class="title class_">NameLabel</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createLabel</span>(<span class="params">nameOrId: <span class="built_in">string</span> | <span class="built_in">number</span></span>): <span class="title class_">IdLabel</span> | <span class="title class_">NameLabel</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="string">&quot;unimplemented&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>createLabel</code>的这些重载描述了一个单一的JavaScript函数，该函数根据其输入的类型做出选择。注意一些事情：</p><ul><li>如果一个库必须在其API中反复做出同样的选择，这就会变得很麻烦。</li><li>我们必须创建三个重载：一个用于确定类型的情况（一个用于 <code>string</code>，一个用于 <code>number</code>），一个用于最一般的情况（取一个 <code>string</code>| <code>number</code>）。对于 <code>createLabel</code>所能处理的每一种新类型，重载的数量都会呈指数级增长。</li></ul><p>相反，我们可以在一个条件类型中对该逻辑进行编码：</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">NameOrId</span>&lt;T <span class="keyword">extends</span> <span class="built_in">number</span> | <span class="built_in">string</span>&gt; = T <span class="keyword">extends</span> <span class="built_in">number</span></span><br><span class="line">  ? <span class="title class_">IdLabel</span></span><br><span class="line">  : <span class="title class_">NameLabel</span>;</span><br></pre></td></tr></table></figure><p>然后我们可以使用该条件类型，将我们的重载简化为一个没有重载的单一函数。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IdLabel</span> &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="built_in">number</span> <span class="comment">/* some fields */</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">NameLabel</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span> <span class="comment">/* other fields */</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">NameOrId</span>&lt;T <span class="keyword">extends</span> <span class="built_in">number</span> | <span class="built_in">string</span>&gt; = T <span class="keyword">extends</span> <span class="built_in">number</span></span><br><span class="line">  ? <span class="title class_">IdLabel</span></span><br><span class="line">  : <span class="title class_">NameLabel</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> createLabel&lt;T <span class="keyword">extends</span> <span class="built_in">number</span> | <span class="built_in">string</span>&gt;(<span class="attr">idOrName</span>: T): <span class="title class_">NameOrId</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="string">&quot;unimplemented&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// let a: NameLabel</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="title function_">createLabel</span>(<span class="string">&quot;typescript&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// let b: IdLabel</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="title function_">createLabel</span>(<span class="number">2.8</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// let c: NameLabel | IdLabel</span></span><br><span class="line"><span class="keyword">let</span> c = <span class="title function_">createLabel</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() ? <span class="string">&quot;hello&quot;</span> : <span class="number">42</span>);</span><br></pre></td></tr></table></figure><h3 id="7-5-1-条件类型约束"><a href="#7-5-1-条件类型约束" class="headerlink" title="7.5.1 条件类型约束"></a>7.5.1 条件类型约束</h3><p>通常，条件类型中的检查会给我们提供一些新的信息。就像用类型守卫缩小范围可以给我们一个更具体的类型一样，条件类型的真正分支将通过我们检查的类型进一步约束泛型。</p><p>例如，让我们来看看下面的例子：</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">MessageOf</span>&lt;T&gt; = T[<span class="string">&quot;message&quot;</span>];</span><br></pre></td></tr></table></figure><img src="https://s2.loli.net/2022/02/22/GEXfr1zpLO2ghPw.png" alt="image-20211129092739341" style="zoom:50%"><p>在这个例子中，TypeScript出错是因为 <code>T</code> 不知道有一个叫做 <code>message</code> 的属性。我们可以对 <code>T</code> 进行约束，TypeScript就不会再抱怨。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">MessageOf</span>&lt;T <span class="keyword">extends</span> &#123; <span class="attr">message</span>: <span class="built_in">unknown</span> &#125;&gt; = T[<span class="string">&quot;message&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Email</span> &#123;</span><br><span class="line">  <span class="attr">message</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">EmailMessageContents</span> = <span class="title class_">MessageOf</span>&lt;<span class="title class_">Email</span>&gt;;</span><br></pre></td></tr></table></figure><p>然而，如果我们想让 <code>MessageOf</code> 接受任何类型，并在消息属性不可用的情况下，默认为 <code>never</code>类型呢？我们可以通过将约束条件移出，并引入一个条件类型来做到这一点。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">MessageOf</span>&lt;T&gt; = T <span class="keyword">extends</span> &#123; <span class="attr">message</span>: <span class="built_in">unknown</span> &#125; ? T[<span class="string">&quot;message&quot;</span>] : <span class="built_in">never</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Email</span> &#123;</span><br><span class="line">  <span class="attr">message</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">  <span class="title function_">bark</span>(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// type EmailMessageContents = string</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">EmailMessageContents</span> = <span class="title class_">MessageOf</span>&lt;<span class="title class_">Email</span>&gt;;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">emc</span>: <span class="title class_">EmailMessageContents</span> = <span class="string">&quot;balabala...&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// type DogMessageContents = never</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">DogMessageContents</span> = <span class="title class_">MessageOf</span>&lt;<span class="title class_">Dog</span>&gt;;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">dmc</span>: <span class="title class_">DogMessageContents</span> = <span class="string">&quot;error&quot;</span> <span class="keyword">as</span> <span class="built_in">never</span>;</span><br></pre></td></tr></table></figure><p>在真正的分支中，TypeScript知道 <code>T</code>会有一个消息属性。</p><p>作为另一个例子，我们也可以写一个叫做 <code>Flatten</code> 的类型，将数组类型平铺到它们的元素类型上，但在其他方面则不做处理。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Flatten</span>&lt;T&gt; = T <span class="keyword">extends</span> <span class="built_in">any</span>[] ? T[<span class="built_in">number</span>] : T;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提取出元素类型。</span></span><br><span class="line"><span class="comment">// type Str = string</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Str</span> = <span class="title class_">Flatten</span>&lt;<span class="built_in">string</span>[]&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单独一个类型。</span></span><br><span class="line"><span class="comment">// type Num = number</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Num</span> = <span class="title class_">Flatten</span>&lt;<span class="built_in">number</span>&gt;;</span><br></pre></td></tr></table></figure><p>当 <code>Flatten</code> 被赋予一个数组类型时，它使用一个带有数字的索引访问来获取 <code>string[]</code> 的元素类型。否则，它只是返回它被赋予的类型。</p><h3 id="7-5-2-在条件类型内进行推理"><a href="#7-5-2-在条件类型内进行推理" class="headerlink" title="7.5.2 在条件类型内进行推理"></a>7.5.2 在条件类型内进行推理</h3><p>我们只是发现自己使用条件类型来应用约束条件，然后提取出类型。这最终成为一种常见的操作，而条件类型使它变得更容易。</p><p>条件类型为我们提供了一种方法来推断我们在真实分支中使用 <code>infer</code> 关键字进行对比的类型。例如，我们可以在<code>Flatten</code> 中推断出元素类型，而不是用索引访问类型 “手动 “提取出来。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Flatten</span>&lt;<span class="title class_">Type</span>&gt; = <span class="title class_">Type</span> <span class="keyword">extends</span> <span class="title class_">Array</span>&lt;infer <span class="title class_">Item</span>&gt; ? <span class="title class_">Item</span> : <span class="title class_">Type</span>;</span><br></pre></td></tr></table></figure><p>在这里，我们使用 <code>infer</code> 关键字来声明性地引入一个名为 <code>Item</code> 的新的通用类型变量，而不是指定如何在真实分支中检索 <code>T</code> 的元素类型。这使我们不必考虑如何挖掘和探测我们感兴趣的类型的结构。</p><p>我们可以使用 <code>infer</code> 关键字编写一些有用的辅助类型别名。例如，对于简单的情况，我们可以从函数类型中提取出返回类型。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">GetReturnType</span>&lt;<span class="title class_">Type</span>&gt; = <span class="title class_">Type</span> <span class="keyword">extends</span> (...<span class="attr">args</span>: <span class="built_in">never</span>[]) =&gt; infer <span class="title class_">Return</span></span><br><span class="line">  ? <span class="title class_">Return</span></span><br><span class="line">  : <span class="built_in">never</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// type Num = number</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Num</span> = <span class="title class_">GetReturnType</span>&lt;<span class="function">() =&gt;</span> <span class="built_in">number</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// type Str = string</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Str</span> = <span class="title class_">GetReturnType</span>&lt;<span class="function">(<span class="params">x: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">string</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// type Bools = boolean[]</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Bools</span> = <span class="title class_">GetReturnType</span>&lt;<span class="function">(<span class="params">a: <span class="built_in">boolean</span>, b: <span class="built_in">boolean</span></span>) =&gt;</span> <span class="built_in">boolean</span>[]&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给泛型传入 string 类型，条件类型会返回 never</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Never</span> = <span class="title class_">GetReturnType</span>&lt;<span class="built_in">string</span>&gt;;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">nev</span>: <span class="title class_">Never</span> = <span class="string">&quot;error&quot;</span> <span class="keyword">as</span> <span class="built_in">never</span>;</span><br></pre></td></tr></table></figure><p>当从一个具有多个调用签名的类型（如重载函数的类型）进行推断时，从最后一个签名进行推断（据推测，这是最容许的万能情况）。不可能根据参数类型的列表来执行重载解析。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">function</span> <span class="title function_">stringOrNum</span>(<span class="params">x: <span class="built_in">string</span></span>): <span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">function</span> <span class="title function_">stringOrNum</span>(<span class="params">x: <span class="built_in">number</span></span>): <span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">function</span> <span class="title function_">stringOrNum</span>(<span class="params">x: <span class="built_in">string</span> | <span class="built_in">number</span></span>): <span class="built_in">string</span> | <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// type T1 = string | number</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T1</span> = <span class="title class_">ReturnType</span>&lt;<span class="keyword">typeof</span> stringOrNum&gt;;</span><br></pre></td></tr></table></figure><h3 id="7-5-3-分布式条件类型"><a href="#7-5-3-分布式条件类型" class="headerlink" title="7.5.3 分布式条件类型"></a>7.5.3 分布式条件类型</h3><p>当条件类型作用于一个通用类型时，当给定一个联合类型时，它们就变成了分布式的。例如，以下面的例子为例：</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">ToArray</span>&lt;<span class="title class_">Type</span>&gt; = <span class="title class_">Type</span> <span class="keyword">extends</span> <span class="built_in">any</span> ? <span class="title class_">Type</span>[] : <span class="built_in">never</span>;</span><br></pre></td></tr></table></figure><p>如果我们将一个联合类型插入ToArray，那么条件类型将被应用于该联合的每个成员。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">ToArray</span>&lt;<span class="title class_">Type</span>&gt; = <span class="title class_">Type</span> <span class="keyword">extends</span> <span class="built_in">any</span> ? <span class="title class_">Type</span>[] : <span class="built_in">never</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// type StrArrOrNumArr = string[] | number[]</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">StrArrOrNumArr</span> = <span class="title class_">ToArray</span>&lt;<span class="built_in">string</span> | <span class="built_in">number</span>&gt;;</span><br></pre></td></tr></table></figure><p>这里发生的情况是，StrArrOrNumArr分布在：</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> | <span class="built_in">number</span>;</span><br></pre></td></tr></table></figure><p>并对联合的每个成员类型进行映射，以达到有效的目的：</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="title class_">ToArray</span>&lt;<span class="built_in">string</span>&gt; | <span class="title class_">ToArray</span>&lt;<span class="built_in">number</span>&gt;;</span><br></pre></td></tr></table></figure><p>这给我们留下了：</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span>[] | <span class="built_in">number</span>[];</span><br></pre></td></tr></table></figure><p>通常情况下，分布性是需要的行为。为了避免这种行为，你可以用方括号包围 <code>extends</code>关键字的每一边。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">ToArrayNonDist</span>&lt;<span class="title class_">Type</span>&gt; = [<span class="title class_">Type</span>] <span class="keyword">extends</span> [<span class="built_in">any</span>] ? <span class="title class_">Type</span>[] : <span class="built_in">never</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &#x27;StrArrOrNumArr&#x27;不再是一个联合类型</span></span><br><span class="line"><span class="comment">// type StrArrOrNumArr = (string | number)[]</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">StrArrOrNumArr</span> = <span class="title class_">ToArrayNonDist</span>&lt;<span class="built_in">string</span> | <span class="built_in">number</span>&gt;;</span><br></pre></td></tr></table></figure><h2 id="7-6-映射类型"><a href="#7-6-映射类型" class="headerlink" title="7.6 映射类型"></a>7.6 映射类型</h2><p>当你不想重复定义类型，一个类型可以以另一个类型为基础创建新类型。</p><p>映射类型建立在索引签名的语法上，索引签名用于声明没有被提前声明的属性类型。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">OnlyBoolsAndHorses</span> = &#123;</span><br><span class="line">  [<span class="attr">key</span>: <span class="built_in">string</span>]: <span class="built_in">boolean</span> | <span class="title class_">Horse</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">conforms</span>: <span class="title class_">OnlyBoolsAndHorses</span> = &#123;</span><br><span class="line">  <span class="attr">del</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">rodney</span>: <span class="literal">false</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>映射类型是一种通用类型，它使用 <code>PropertyKeys</code>的联合（经常通过<code>keyof</code>创建）迭代键来创建一个类型。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">OptionsFlags</span>&lt;<span class="title class_">Type</span>&gt; = &#123;</span><br><span class="line">  [<span class="title class_">Property</span> <span class="keyword">in</span> keyof <span class="title class_">Type</span>]: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>OptionsFlags</code>将从<code>Type</code>类型中获取所有属性，并将它们的值改为布尔值。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">FeatureFlags</span> = &#123;</span><br><span class="line">  <span class="attr">darkMode</span>: <span class="function">() =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">  <span class="attr">newUserProfile</span>: <span class="function">() =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">type FeatureOptions = &#123;</span></span><br><span class="line"><span class="comment">    darkMode: boolean;</span></span><br><span class="line"><span class="comment">    newUserProfile: boolean;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">FeatureOptions</span> = <span class="title class_">OptionsFlags</span>&lt;<span class="title class_">FeatureFlags</span>&gt;;</span><br></pre></td></tr></table></figure><h3 id="7-6-1-映射修改器"><a href="#7-6-1-映射修改器" class="headerlink" title="7.6.1 映射修改器"></a>7.6.1 映射修改器</h3><p>在映射过程中，有两个额外的修饰符可以应用：<code>readonly</code>和<code>?</code> ，它们分别影响可变性和可选性。</p><p>你可以通过用<code>-</code>或<code>+</code>作为前缀来删除或添加这些修饰语。如果你不加前缀，那么就假定是<code>+</code>。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">CreateMutable</span>&lt;<span class="title class_">Type</span>&gt; = &#123;</span><br><span class="line">  <span class="comment">// 从一个类型的属性中删除 &quot;readonly&quot;属性</span></span><br><span class="line">  -<span class="keyword">readonly</span> [<span class="title class_">Property</span> <span class="keyword">in</span> keyof <span class="title class_">Type</span>]: <span class="title class_">Type</span>[<span class="title class_">Property</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">LockedAccount</span> = &#123;</span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">id</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">type UnlockedAccount = &#123;</span></span><br><span class="line"><span class="comment">    id: string;</span></span><br><span class="line"><span class="comment">    name: string;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">UnlockedAccount</span> = <span class="title class_">CreateMutable</span>&lt;<span class="title class_">LockedAccount</span>&gt;;</span><br></pre></td></tr></table></figure><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从一个类型的属性中删除 &quot;可选&quot; 属性</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Concrete</span>&lt;<span class="title class_">Type</span>&gt; = &#123;</span><br><span class="line">  [<span class="title class_">Property</span> <span class="keyword">in</span> keyof <span class="title class_">Type</span>]-?: <span class="title class_">Type</span>[<span class="title class_">Property</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">MaybeUser</span> = &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="built_in">string</span>;</span><br><span class="line">  name?: <span class="built_in">string</span>;</span><br><span class="line">  age?: <span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">type User = &#123;</span></span><br><span class="line"><span class="comment">    id: string;</span></span><br><span class="line"><span class="comment">    name: string;</span></span><br><span class="line"><span class="comment">    age: number;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">User</span> = <span class="title class_">Concrete</span>&lt;<span class="title class_">MaybeUser</span>&gt;;</span><br></pre></td></tr></table></figure><h3 id="7-6-2-通过-as-做-key-重映射"><a href="#7-6-2-通过-as-做-key-重映射" class="headerlink" title="7.6.2 通过 as 做 key 重映射"></a>7.6.2 通过 <code>as</code> 做 <code>key</code> 重映射</h3><p>在TypeScript 4.1及以后的版本中，你可以通过映射类型中的as子句重新映射映射类型中的键。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">MappedTypeWithNewProperties</span>&lt;<span class="title class_">Type</span>&gt; = &#123;</span><br><span class="line">  [<span class="title class_">Properties</span> <span class="keyword">in</span> keyof <span class="title class_">Type</span> <span class="keyword">as</span> <span class="title class_">NewKeyType</span>]: <span class="title class_">Type</span>[<span class="title class_">Properties</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>你可以利用<a target="_blank" rel="noopener" href="https://www.typescriptlang.org/docs/handbook/2/template-literal-types.html">模板字面类型</a>等功能，从先前的属性名称中创建新的属性名称。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Getters</span>&lt;<span class="title class_">Type</span>&gt; = &#123;</span><br><span class="line">  [<span class="title class_">Property</span> <span class="keyword">in</span> keyof <span class="title class_">Type</span> <span class="keyword">as</span> <span class="string">`get<span class="subst">$&#123;Capitalize&lt;<span class="built_in">string</span> &amp; Property&gt;&#125;</span>`</span>]: <span class="function">() =&gt;</span> <span class="title class_">Type</span>[<span class="title class_">Property</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">location</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">type LazyPerson = &#123;</span></span><br><span class="line"><span class="comment">  getName: () =&gt; string;</span></span><br><span class="line"><span class="comment">  getAge: () =&gt; number;</span></span><br><span class="line"><span class="comment">  getLocation: () =&gt; string;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">LazyPerson</span> = <span class="title class_">Getters</span>&lt;<span class="title class_">Person</span>&gt;;</span><br></pre></td></tr></table></figure><p>你可以通过条件类型产生<code>never</code>滤掉的键。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 删除 &quot;kind&quot;属性</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">RemoveKindField</span>&lt;<span class="title class_">Type</span>&gt; = &#123;</span><br><span class="line">  [<span class="title class_">Property</span> <span class="keyword">in</span> keyof <span class="title class_">Type</span> <span class="keyword">as</span> <span class="title class_">Exclude</span>&lt;<span class="title class_">Property</span>, <span class="string">&quot;kind&quot;</span>&gt;]: <span class="title class_">Type</span>[<span class="title class_">Property</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">type KindlessCircle = &#123;</span></span><br><span class="line"><span class="comment">    radius: number;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Circle</span> &#123;</span><br><span class="line">  <span class="attr">kind</span>: <span class="string">&quot;circle&quot;</span>;</span><br><span class="line">  <span class="attr">radius</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">KindlessCircle</span> = <span class="title class_">RemoveKindField</span>&lt;<span class="title class_">Circle</span>&gt;;</span><br></pre></td></tr></table></figure><p>你可以映射任意的联合体，不仅仅是<code>string | number | symbol</code>的联合体，还有任何类型的联合体。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">EventConfig</span>&lt;<span class="title class_">Events</span> <span class="keyword">extends</span> &#123; <span class="attr">kind</span>: <span class="built_in">string</span> &#125;&gt; = &#123;</span><br><span class="line">  [E <span class="keyword">in</span> <span class="title class_">Events</span> <span class="keyword">as</span> E[<span class="string">&quot;kind&quot;</span>]]: <span class="function">(<span class="params">event: E</span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">SquareEvent</span> = &#123; <span class="attr">kind</span>: <span class="string">&quot;square&quot;</span>; <span class="attr">x</span>: <span class="built_in">number</span>; <span class="attr">y</span>: <span class="built_in">number</span> &#125;;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">CircleEvent</span> = &#123; <span class="attr">kind</span>: <span class="string">&quot;circle&quot;</span>; <span class="attr">radius</span>: <span class="built_in">number</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">type Config = &#123;</span></span><br><span class="line"><span class="comment">    square: (event: SquareEvent) =&gt; void;</span></span><br><span class="line"><span class="comment">    circle: (event: CircleEvent) =&gt; void;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Config</span> = <span class="title class_">EventConfig</span>&lt;<span class="title class_">SquareEvent</span> | <span class="title class_">CircleEvent</span>&gt;;</span><br></pre></td></tr></table></figure><h3 id="7-6-3-进一步探索"><a href="#7-6-3-进一步探索" class="headerlink" title="7.6.3 进一步探索"></a>7.6.3 进一步探索</h3><p>映射类型与本类型操作部分的其他功能配合得很好，例如，这里有一个<a target="_blank" rel="noopener" href="https://www.typescriptlang.org/docs/handbook/2/conditional-types.html">使用条件类型的映射类型</a> ，它根据一个对象的属性<code>pii</code>是否被设置为字面意义上的 <code>true</code>，返回<code>true</code>或<code>false</code>。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">ExtractPII</span>&lt;<span class="title class_">Type</span>&gt; = &#123;</span><br><span class="line">  [<span class="title class_">Property</span> <span class="keyword">in</span> keyof <span class="title class_">Type</span>]: <span class="title class_">Type</span>[<span class="title class_">Property</span>] <span class="keyword">extends</span> &#123; <span class="attr">pii</span>: <span class="literal">true</span> &#125; ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">type ObjectsNeedingGDPRDeletion = &#123;</span></span><br><span class="line"><span class="comment">  id: false;</span></span><br><span class="line"><span class="comment">  name: true;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">DBFields</span> = &#123;</span><br><span class="line">  <span class="attr">id</span>: &#123; <span class="attr">format</span>: <span class="string">&quot;incrementing&quot;</span> &#125;;</span><br><span class="line">  <span class="attr">name</span>: &#123; <span class="attr">type</span>: <span class="built_in">string</span>; <span class="attr">pii</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">ObjectsNeedingGDPRDeletion</span> = <span class="title class_">ExtractPII</span>&lt;<span class="title class_">DBFields</span>&gt;;</span><br></pre></td></tr></table></figure><h3 id="特别声明-本文转自-古艺散人老师-，如有需要可前往原文预览查看。"><a href="#特别声明-本文转自-古艺散人老师-，如有需要可前往原文预览查看。" class="headerlink" title="特别声明: 本文转自  古艺散人老师 ，如有需要可前往原文预览查看。"></a>特别声明: 本文转自 <a target="_blank" rel="noopener" href="https://github.com/lurongtao/TypeScript">古艺散人老师 </a>，如有需要可前往原文预览查看。</h3></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://maple-214.cn">泽枫</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://maple-214.cn/article/2401/">https://maple-214.cn/article/2401/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://maple-214.cn" target="_blank">澤楓の小屋</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%89%8D%E7%AB%AF/">前端</a><a class="post-meta__tags" href="/tags/TypeScript/">TypeScript</a></div><div class="post_share"><div class="social-share" data-image="/img/cover/cover_03.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/qrCode/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/qrCode/wechat.jpg" alt="wechat"></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/qrCode/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/qrCode/alipay.jpg" alt="alipay"></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/article/55025/" title="1-8、基础篇：类"><img class="cover" src="/img/cover/cover_01.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">1-8、基础篇：类</div></div></a></div><div class="next-post pull-right"><a href="/article/59398/" title="1-6、基础篇：对象类型"><img class="cover" src="/img/cover/cover_03.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">1-6、基础篇：对象类型</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/article/8074/" title="1-1、基础篇：TypeScript介绍"><img class="cover" src="/img/cover/cover_02.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-26</div><div class="title">1-1、基础篇：TypeScript介绍</div></div></a></div><div><a href="/article/19978/" title="1-3、基础篇：常用类型"><img class="cover" src="/img/cover/cover_02.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-26</div><div class="title">1-3、基础篇：常用类型</div></div></a></div><div><a href="/article/20247/" title="1-2、基础篇：TypeScript入门"><img class="cover" src="/img/cover/cover_01.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-26</div><div class="title">1-2、基础篇：TypeScript入门</div></div></a></div><div><a href="/article/23966/" title="1-4、基础篇：类型缩小"><img class="cover" src="/img/cover/cover_03.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-26</div><div class="title">1-4、基础篇：类型缩小</div></div></a></div><div><a href="/article/59398/" title="1-6、基础篇：对象类型"><img class="cover" src="/img/cover/cover_03.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-26</div><div class="title">1-6、基础篇：对象类型</div></div></a></div><div><a href="/article/30791/" title="1-5、基础篇：函数更多"><img class="cover" src="/img/cover/cover_03.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-26</div><div class="title">1-5、基础篇：函数更多</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info__name">泽枫</div><div class="author-info__description">泽枫的小屋|泽枫的博客|maple|Maple|澤楓の博客|澤楓の小屋|前端</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">26</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">3</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E7%B1%BB%E5%9E%8B%E6%93%8D%E7%BA%B5"><span class="toc-number">1.</span> <span class="toc-text">七、类型操纵</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-0-%E4%BB%8E%E7%B1%BB%E5%9E%8B%E4%B8%AD%E5%88%9B%E5%BB%BA%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.1.</span> <span class="toc-text">7.0 从类型中创建类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1-%E6%B3%9B%E5%9E%8B"><span class="toc-number">1.2.</span> <span class="toc-text">7.1 泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-1-Hello-World"><span class="toc-number">1.2.1.</span> <span class="toc-text">7.1.1 Hello World</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-2-%E4%BD%BF%E7%94%A8%E9%80%9A%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%8F%98%E9%87%8F"><span class="toc-number">1.2.2.</span> <span class="toc-text">7.1.2 使用通用类型变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-3-%E6%B3%9B%E5%9E%8B%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.2.3.</span> <span class="toc-text">7.1.3 泛型类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-4-%E6%B3%9B%E5%9E%8B%E7%B1%BB"><span class="toc-number">1.2.4.</span> <span class="toc-text">7.1.4 泛型类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-5-%E6%B3%9B%E5%9E%8B%E7%BA%A6%E6%9D%9F"><span class="toc-number">1.2.5.</span> <span class="toc-text">7.1.5 泛型约束</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-6-%E5%9C%A8%E6%B3%9B%E5%9E%8B%E7%BA%A6%E6%9D%9F%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0"><span class="toc-number">1.2.6.</span> <span class="toc-text">7.1.6 在泛型约束中使用类型参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-7-%E5%9C%A8%E6%B3%9B%E5%9E%8B%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%B1%BB%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.2.7.</span> <span class="toc-text">7.1.7 在泛型中使用类类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-2-Keyof%E7%B1%BB%E5%9E%8B%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">1.3.</span> <span class="toc-text">7.2 Keyof类型操作符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-3-Typeof-%E7%B1%BB%E5%9E%8B%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">1.4.</span> <span class="toc-text">7.3 Typeof 类型操作符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-4-%E7%B4%A2%E5%BC%95%E8%AE%BF%E9%97%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.5.</span> <span class="toc-text">7.4 索引访问类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-5-%E6%9D%A1%E4%BB%B6%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.6.</span> <span class="toc-text">7.5 条件类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-5-1-%E6%9D%A1%E4%BB%B6%E7%B1%BB%E5%9E%8B%E7%BA%A6%E6%9D%9F"><span class="toc-number">1.6.1.</span> <span class="toc-text">7.5.1 条件类型约束</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-5-2-%E5%9C%A8%E6%9D%A1%E4%BB%B6%E7%B1%BB%E5%9E%8B%E5%86%85%E8%BF%9B%E8%A1%8C%E6%8E%A8%E7%90%86"><span class="toc-number">1.6.2.</span> <span class="toc-text">7.5.2 在条件类型内进行推理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-5-3-%E5%88%86%E5%B8%83%E5%BC%8F%E6%9D%A1%E4%BB%B6%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.6.3.</span> <span class="toc-text">7.5.3 分布式条件类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-6-%E6%98%A0%E5%B0%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.7.</span> <span class="toc-text">7.6 映射类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-6-1-%E6%98%A0%E5%B0%84%E4%BF%AE%E6%94%B9%E5%99%A8"><span class="toc-number">1.7.1.</span> <span class="toc-text">7.6.1 映射修改器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-6-2-%E9%80%9A%E8%BF%87-as-%E5%81%9A-key-%E9%87%8D%E6%98%A0%E5%B0%84"><span class="toc-number">1.7.2.</span> <span class="toc-text">7.6.2 通过 as 做 key 重映射</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-6-3-%E8%BF%9B%E4%B8%80%E6%AD%A5%E6%8E%A2%E7%B4%A2"><span class="toc-number">1.7.3.</span> <span class="toc-text">7.6.3 进一步探索</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E5%88%AB%E5%A3%B0%E6%98%8E-%E6%9C%AC%E6%96%87%E8%BD%AC%E8%87%AA-%E5%8F%A4%E8%89%BA%E6%95%A3%E4%BA%BA%E8%80%81%E5%B8%88-%EF%BC%8C%E5%A6%82%E6%9C%89%E9%9C%80%E8%A6%81%E5%8F%AF%E5%89%8D%E5%BE%80%E5%8E%9F%E6%96%87%E9%A2%84%E8%A7%88%E6%9F%A5%E7%9C%8B%E3%80%82"><span class="toc-number">1.7.4.</span> <span class="toc-text">特别声明: 本文转自 古艺散人老师 ，如有需要可前往原文预览查看。</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/article/16495/" title="1-1、CSS中hover时出现抖动的原因和解决方法"><img src="/img/cover/cover_02.jpeg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="1-1、CSS中hover时出现抖动的原因和解决方法"></a><div class="content"><a class="title" href="/article/16495/" title="1-1、CSS中hover时出现抖动的原因和解决方法">1-1、CSS中hover时出现抖动的原因和解决方法</a><time datetime="2024-01-26T12:30:06.000Z" title="发表于 2024-01-26 20:30:06">2024-01-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/article/43000/" title="3-7、高级篇：声明合并"><img src="/img/cover/cover_02.jpeg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="3-7、高级篇：声明合并"></a><div class="content"><a class="title" href="/article/43000/" title="3-7、高级篇：声明合并">3-7、高级篇：声明合并</a><time datetime="2024-01-26T12:24:54.000Z" title="发表于 2024-01-26 20:24:54">2024-01-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/article/19249/" title="3-6、高级篇：命名空间与模块"><img src="/img/cover/cover_02.jpeg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="3-6、高级篇：命名空间与模块"></a><div class="content"><a class="title" href="/article/19249/" title="3-6、高级篇：命名空间与模块">3-6、高级篇：命名空间与模块</a><time datetime="2024-01-26T12:23:45.000Z" title="发表于 2024-01-26 20:23:45">2024-01-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/article/52849/" title="3-5、高级篇：命名空间"><img src="/img/cover/cover_02.jpeg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="3-5、高级篇：命名空间"></a><div class="content"><a class="title" href="/article/52849/" title="3-5、高级篇：命名空间">3-5、高级篇：命名空间</a><time datetime="2024-01-26T12:23:06.000Z" title="发表于 2024-01-26 20:23:06">2024-01-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/article/3652/" title="3-4、高级篇：模块解析"><img src="/img/cover/cover_01.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="3-4、高级篇：模块解析"></a><div class="content"><a class="title" href="/article/3652/" title="3-4、高级篇：模块解析">3-4、高级篇：模块解析</a><time datetime="2024-01-26T12:22:08.000Z" title="发表于 2024-01-26 20:22:08">2024-01-26</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div id="ft"><img class="ft-img" src="/img/favicon.png" alt="" srcset=""></div><div class="copyright">&copy;2020 - 2024 <i id="heartbeat" class="fa fas fa-heartbeat"></i> 泽枫</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简体</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.12.0"></script><script src="/js/main.js?v=4.12.0"></script><script src="/js/tw_cn.js?v=4.12.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.32/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.js"></script><script>function panguFn(){"object"==typeof pangu?pangu.autoSpacingPage():getScript("https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js").then(()=>{pangu.autoSpacingPage()})}function panguInit(){GLOBAL_CONFIG_SITE.isPost&&panguFn()}document.addEventListener("DOMContentLoaded",panguInit)</script><div class="js-pjax"></div><script type="text/javascript" src="/js/src/jquery.js"></script><script type="text/javascript" src="/js/src/vue.js"></script><script type="text/javascript" src="/js/src/vue_js.js"></script><script type="text/javascript" src="/js/src/nav.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/fireworks.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span> 数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.12.0"></script></div></div><script data-pjax>var parent,child;document.getElementById("recent-posts")&&"/"==location.pathname&&(parent=document.getElementById("recent-posts")).insertAdjacentHTML("afterbegin",child='<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms"><div class="blog-slider__img blog-slider__custom_img"><img src="/img/recommend/recommend_06.jpg" alt="/img/recommend/recommend_06.jpg"/></div><div class="blog-slider__content"><span class="blog-slider__code">2024-01-26</span><a class="blog-slider__title" href="article/8074/">1-1、基础篇：TypeScript介绍</a><div class="blog-slider__text">1-1、基础篇：TypeScript介绍</div><a class="blog-slider__button" href="article/8074/">详情</a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms"><div class="blog-slider__img blog-slider__custom_img"><img src="/img/recommend/recommend_05.jpg" alt="/img/recommend/recommend_05.jpg"/></div><div class="blog-slider__content"><span class="blog-slider__code">2024-01-26</span><a class="blog-slider__title" href="article/20247/">1-2、基础篇：TypeScript入门</a><div class="blog-slider__text">1-2、基础篇：TypeScript入门</div><a class="blog-slider__button" href="article/20247/">详情</a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms"><div class="blog-slider__img blog-slider__custom_img"><img src="/img/recommend/recommend_04.jpg" alt="/img/recommend/recommend_04.jpg"/></div><div class="blog-slider__content"><span class="blog-slider__code">2024-01-26</span><a class="blog-slider__title" href="article/19978/">1-3、基础篇：常用类型</a><div class="blog-slider__text">1-3、基础篇：常用类型</div><a class="blog-slider__button" href="article/19978/">详情</a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms"><div class="blog-slider__img blog-slider__custom_img"><img src="/img/recommend/recommend_03.jpg" alt="/img/recommend/recommend_03.jpg"/></div><div class="blog-slider__content"><span class="blog-slider__code">2024-01-26</span><a class="blog-slider__title" href="article/23966/">1-4、基础篇：类型缩小</a><div class="blog-slider__text">1-4、基础篇：类型缩小</div><a class="blog-slider__button" href="article/23966/">详情</a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms"><div class="blog-slider__img blog-slider__custom_img"><img src="/img/recommend/recommend_02.jpg" alt="/img/recommend/recommend_02.jpg"/></div><div class="blog-slider__content"><span class="blog-slider__code">2024-01-26</span><a class="blog-slider__title" href="article/30791/">1-5、基础篇：函数更多</a><div class="blog-slider__text">1-5、基础篇：函数更多</div><a class="blog-slider__button" href="article/30791/">详情</a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms"><div class="blog-slider__img blog-slider__custom_img"><img src="/img/recommend/recommend_01.jpg" alt="/img/recommend/recommend_01.jpg"/></div><div class="blog-slider__content"><span class="blog-slider__code">2024-01-26</span><a class="blog-slider__title" href="article/59398/">1-6、基础篇：对象类型</a><div class="blog-slider__text">1-6、基础篇：对象类型</div><a class="blog-slider__button" href="article/59398/">详情</a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>')</script><script data-pjax src="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-swiper/swiper/swiper.min.js"></script><script data-pjax src="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-swiper@0.18/swiper/swiperindex.js"></script><style></style></body></html>