<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"><title>1-8、基础篇：类 | 澤楓の小屋</title><meta name="author" content="泽枫"><meta name="copyright" content="泽枫"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="八、类TypeScript提供了对ES2015中引入的 class 关键词的完全支持。 与其他JavaScript语言功能一样，TypeScript增加了类型注释和其他语法，允许你表达类和其他类型之间的关系。 8.1 类成员这里有一个最基本的类——一个空的类： class Point &#123;&#125;  这个类还不是很有用，所以我们开始添加一些成员。 8.1.1 类属性在一个类上声明字段，"><meta property="og:type" content="article"><meta property="og:title" content="1-8、基础篇：类"><meta property="og:url" content="https://maple-214.cn/article/55025/index.html"><meta property="og:site_name" content="澤楓の小屋"><meta property="og:description" content="八、类TypeScript提供了对ES2015中引入的 class 关键词的完全支持。 与其他JavaScript语言功能一样，TypeScript增加了类型注释和其他语法，允许你表达类和其他类型之间的关系。 8.1 类成员这里有一个最基本的类——一个空的类： class Point &#123;&#125;  这个类还不是很有用，所以我们开始添加一些成员。 8.1.1 类属性在一个类上声明字段，"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://maple-214.cn/img/cover/cover_02.jpeg"><meta property="article:published_time" content="2024-01-26T12:12:28.000Z"><meta property="article:modified_time" content="2024-01-26T12:25:37.737Z"><meta property="article:author" content="泽枫"><meta property="article:tag" content="前端"><meta property="article:tag" content="TypeScript"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://maple-214.cn/img/cover/cover_02.jpeg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://maple-214.cn/article/55025/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//www.google-analytics.com" crossorigin=""><link rel="preconnect" href="//hm.baidu.com"><link rel="preconnect" href="//busuanzi.ibruce.info"><meta name="google-site-verification" content="OAauFcQX49kS2UGN9SShSqwNxfrsByxSVXRfNyc"><meta name="baidu-site-verification" content="codeva-JddVaE5CKl"><link rel="stylesheet" href="/css/index.css?v=4.12.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.32/dist/fancybox/fancybox.min.css" media="print" onload='this.media="all"'><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(adsbygoogle=window.adsbygoogle||[]).push({google_ad_client:"ca-pub-4229599433514996",enable_page_level_ads:"true"})</script><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script"),t=(e.src="https://hm.baidu.com/hm.js?6df43866b91212ab3dbadbcfd5966f6c",document.getElementsByTagName("script")[0]);t.parentNode.insertBefore(e,t)}()</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-FZNMK725WD"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-FZNMK725WD")</script><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"/search.xml",preload:!0,top_n_per_article:1,unescape:!1,languages:{hits_empty:"找不到您查询的内容：${query}",hits_stats:"共找到 ${hits} 篇文章"}},translate:{defaultEncoding:2,translateDelay:0,msgToTraditionalChinese:"繁体",msgToSimplifiedChinese:"简体"},noticeOutdate:void 0,highlight:{plugin:"highlight.js",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:150},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"",dateSuffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:{limitCount:50,languages:{author:"作者: 泽枫",link:"链接: ",source:"来源: 澤楓の小屋",info:"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},lightbox:"fancybox",Snackbar:{chs_to_cht:"你已切换为繁体中文",cht_to_chs:"你已切换为简体中文",day_to_night:"你已切换为深色模式",night_to_day:"你已切换为浅色模式",bgLight:"#49b1f5",bgDark:"#1f1f1f",position:"bottom-left"},infinitegrid:{js:"https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.0/dist/infinitegrid.min.js",buttonText:"加载更多"},isPhotoFigcaption:!0,islazyload:!1,isAnchor:!1,percent:{toc:!0,rightside:!0},autoDarkmode:!1}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"1-8、基础篇：类",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2024-01-26 20:25:37"}</script><script>(e=>{e.saveToLocal={set:(e,t,a)=>{var o;0!==a&&(o=Date.now(),localStorage.setItem(e,JSON.stringify({value:t,expiry:o+864e5*a})))},get:e=>{var t=localStorage.getItem(e);if(t){t=JSON.parse(t);if(!(Date.now()>t.expiry))return t.value;localStorage.removeItem(e)}}},e.getScript=(o,n={})=>new Promise((t,e)=>{const a=document.createElement("script");a.src=o,a.async=!0,a.onerror=e,a.onload=a.onreadystatechange=function(){var e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(a.onload=a.onreadystatechange=null,t())},Object.keys(n).forEach(e=>{a.setAttribute(e,n[e])}),document.head.appendChild(a)}),e.getCSS=(o,n=!1)=>new Promise((t,e)=>{const a=document.createElement("link");a.rel="stylesheet",a.href=o,n&&(a.id=n),a.onerror=e,a.onload=a.onreadystatechange=function(){var e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(a.onload=a.onreadystatechange=null,t())},document.head.appendChild(a)}),e.activateDarkMode=()=>{document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=()=>{document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};e=saveToLocal.get("theme"),"dark"===e?activateDarkMode():"light"===e&&activateLightMode(),e=saveToLocal.get("aside-status");void 0!==e&&("hide"===e?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"));/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})(window)</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-swiper/swiper/swiper.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-swiper/swiper/swiperstyle.css"><meta name="generator" content="Hexo 7.1.1"><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head><body><script async src="/js/src/sakura.js"></script><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{const d=document.getElementById("loading-box"),e=document.body,n={endLoading:()=>{e.style.overflow="",d.classList.add("loaded")},initLoading:()=>{e.style.overflow="hidden",d.classList.remove("loaded")}};n.initLoading(),window.addEventListener("load",()=>{n.endLoading()}),document.addEventListener("pjax:send",()=>{n.initLoading()}),document.addEventListener("pjax:complete",()=>{n.endLoading()})})()</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">26</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">3</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><hr class="custom-hr"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div></div></div></div><div id="root"><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image:url(/img/cover/cover_02.jpeg)"><nav id="nav"><span id="blog-info"><a href="/" title="澤楓の小屋">澤楓の小屋</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div></div><center id="name-container"><a id="page-name" href="javascript:scrollToTop()">PAGE_NAME</a></center></div><div id="nav-right"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">1-8、基础篇：类</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-01-26T12:12:28.000Z" title="发表于 2024-01-26 20:12:28">2024-01-26</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-01-26T12:25:37.737Z" title="更新于 2024-01-26 20:25:37">2024-01-26</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/TypeScript/">TypeScript</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title="1-8、基础篇：类"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="八、类"><a href="#八、类" class="headerlink" title="八、类"></a>八、类</h1><p>TypeScript提供了对ES2015中引入的 <code>class</code> 关键词的完全支持。</p><p>与其他JavaScript语言功能一样，TypeScript增加了类型注释和其他语法，允许你表达类和其他类型之间的关系。</p><h2 id="8-1-类成员"><a href="#8-1-类成员" class="headerlink" title="8.1 类成员"></a>8.1 类成员</h2><p>这里有一个最基本的类——一个空的类：</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>这个类还不是很有用，所以我们开始添加一些成员。</p><h3 id="8-1-1-类属性"><a href="#8-1-1-类属性" class="headerlink" title="8.1.1 类属性"></a>8.1.1 类属性</h3><p>在一个类上声明字段，创建一个公共的可写属性：A mapped type is a generic type which uses a union of <code>PropertyKey</code>s (frequently created <a target="_blank" rel="noopener" href="https://www.typescriptlang.org/docs/handbook/2/indexed-access-types.html">via a <code>keyof</code></a>) to iterate through keys to create a type:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> pt = <span class="keyword">new</span> <span class="title class_">Point</span>();</span><br><span class="line">pt.<span class="property">x</span> = <span class="number">0</span>;</span><br><span class="line">pt.<span class="property">y</span> = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>与其他位置一样，类型注解是可选的，但如果不指定，将是一个隐含的 <code>any</code> 类型。</p><p>字段也可以有初始化器；这些初始化器将在类被实例化时自动运行。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  x = <span class="number">0</span>;</span><br><span class="line">  y = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> pt = <span class="keyword">new</span> <span class="title class_">Point</span>();</span><br><span class="line"><span class="comment">// Prints 0, 0</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;pt.x&#125;</span>, <span class="subst">$&#123;pt.y&#125;</span>`</span>);</span><br></pre></td></tr></table></figure><p>就像 <code>const</code>、<code>let</code>和<code>var</code>一样，一个类属性的初始化器将被用来推断其类型。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> pt = <span class="keyword">new</span> <span class="title class_">Point</span>();</span><br><span class="line">pt.<span class="property">x</span> = <span class="string">&quot;0&quot;</span>;</span><br></pre></td></tr></table></figure><img src="/img/TypeScript/09-01.png" alt="image-20211129114803786" style="zoom:50%"><ul><li><code>--strictPropertyInitialization</code></li></ul><p><code>strictPropertyInitialization</code>设置控制是否需要在构造函数中初始化类字段。</p><img src="/img/TypeScript/09-02.png" alt="image-20211129115145529" style="zoom:50%"><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BadGreeter</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/img/TypeScript/09-04.png" alt="image-20211129115341214" style="zoom:50%"><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GoodGreeter</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意，该字段需要在构造函数本身中初始化。TypeScript不会分析你从构造函数中调用的方法来检测初始化，因为派生类可能会覆盖这些方法而无法初始化成员。</p><p>如果你打算通过构造函数以外的方式来确定初始化一个字段（例如，也许一个外部库为你填充了你的类的一部分），你可以使用确定的赋值断言操作符 <code>！</code>。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">OKGreeter</span> &#123;</span><br><span class="line">  <span class="comment">// 没有初始化，但没报错。</span></span><br><span class="line">  name!: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-1-2-readonly"><a href="#8-1-2-readonly" class="headerlink" title="8.1.2 readonly"></a>8.1.2 <code>readonly</code></h3><p>字段的前缀可以是 <code>readonly</code> 修饰符。这可以防止在构造函数之外对该字段进行赋值。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Greeter</span> &#123;</span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">name</span>: <span class="built_in">string</span> = <span class="string">&quot;world&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">otherName?: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (otherName !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">name</span> = otherName;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">err</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&quot;not ok&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> g = <span class="keyword">new</span> <span class="title class_">Greeter</span>();</span><br><span class="line">g.<span class="property">name</span> = <span class="string">&quot;also not ok&quot;</span>;</span><br></pre></td></tr></table></figure><img src="/img/TypeScript/09-05.png" alt="image-20211129120222803" style="zoom:50%"><h3 id="8-1-3-构造器"><a href="#8-1-3-构造器" class="headerlink" title="8.1.3 构造器"></a>8.1.3 构造器</h3><p>类构造函数与函数非常相似。你可以添加带有类型注释的参数、默认值和重载：</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 带默认值的正常签名</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">x = <span class="number">0</span>, y = <span class="number">0</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">x</span> = x;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">y</span> = y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  <span class="comment">// 重载</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">string</span></span>);</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">s: <span class="built_in">string</span></span>);</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">xs: <span class="built_in">any</span>, y?: <span class="built_in">any</span></span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类的构造函数签名和函数签名之间只有一些区别：</p><ul><li><p>构造函数不能有类型参数–这属于外层类的声明，我们将在后面学习。</p></li><li><p>构造函数不能有返回类型注释——类的实例类型总是被返回的。</p></li></ul><p><strong>Super 调用</strong></p><p>就像在JavaScript中一样，如果你有一个基类，在使用任何 <code>this.</code>成员之前，你需要在构造器主体中调用<code>super();</code>。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">  k = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Base</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 在ES5中打印一个错误的值；在ES6中抛出异常。</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">k</span>);</span><br><span class="line">    <span class="variable language_">super</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/img/TypeScript/09-06.png" alt="image-20211129135259853" style="zoom:50%"><p>在JavaScript中，忘记调用 <code>super</code> 是一个很容易犯的错误，但TypeScript会在必要时告诉你。</p><h3 id="8-1-4-方法"><a href="#8-1-4-方法" class="headerlink" title="8.1.4 方法"></a>8.1.4 方法</h3><p>一个类上的函数属性被称为方法。方法可以使用与函数和构造函数相同的所有类型注释。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  x = <span class="number">10</span>;</span><br><span class="line">  y = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">scale</span>(<span class="attr">n</span>: <span class="built_in">number</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">x</span> *= n;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">y</span> *= n;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了标准的类型注解，TypeScript并没有为方法添加其他新的东西。</p><p>请注意，在一个方法体中，仍然必须通过<code>this</code>访问字段和其他方法。方法体中的非限定名称将总是指代包围范围内的东西。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">x</span>: <span class="built_in">number</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">string</span> = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">m</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 这是在试图修改第1行的&#x27;x&#x27;，而不是类属性。</span></span><br><span class="line">    x = <span class="string">&quot;world&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-1-5-Getters-Setters"><a href="#8-1-5-Getters-Setters" class="headerlink" title="8.1.5 Getters &#x2F; Setters"></a>8.1.5 Getters &#x2F; Setters</h3><p>类也可以有访问器：</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">  _length = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">length</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_length</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">length</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_length</span> = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>请注意，一个没有额外逻辑的字段支持的<code>get/set</code>对在JavaScript中很少有用。如果你不需要在<code>get/set</code>操作中添加额外的逻辑，暴露公共字段也是可以的。</p></blockquote><p>TypeScript对访问器有一些特殊的推理规则：</p><ul><li><p>如果存在 <code>get</code>，但没有<code>set</code>，则该属性自动是只读的</p></li><li><p>如果没有指定<code>setter</code>参数的类型，它将从<code>getter</code>的返回类型中推断出来</p></li><li><p>访问器和设置器必须有相同的成员可见性</p></li></ul><p>从TypeScript 4.3开始，可以有不同类型的访问器用于获取和设置。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Thing</span> &#123;</span><br><span class="line">  _size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">size</span>(): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_size</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">size</span>(<span class="params">value: <span class="built_in">string</span> | <span class="built_in">number</span> | <span class="built_in">boolean</span></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> num = <span class="title class_">Number</span>(value);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不允许NaN、Infinity等</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="title class_">Number</span>.<span class="built_in">isFinite</span>(num)) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">_size</span> = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_size</span> = num;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-1-6-索引签名"><a href="#8-1-6-索引签名" class="headerlink" title="8.1.6 索引签名"></a>8.1.6 索引签名</h3><p>类可以声明索引签名；这些签名的作用与其他对象类型的索引签名相同。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">  [<span class="attr">s</span>: <span class="built_in">string</span>]: <span class="built_in">boolean</span> | (<span class="function">(<span class="params">s: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">boolean</span>);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">check</span>(<span class="params">s: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>[s] <span class="keyword">as</span> <span class="built_in">boolean</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为索引签名类型需要同时捕获方法的类型，所以要有用地使用这些类型并不容易。一般来说，最好将索引数据存储在另一个地方，而不是在类实例本身。</p><h2 id="8-2-类继承"><a href="#8-2-类继承" class="headerlink" title="8.2 类继承"></a>8.2 类继承</h2><p>像其他具有面向对象特性的语言一样，JavaScript中的类可以继承自基类。</p><h3 id="8-2-1-implements子句"><a href="#8-2-1-implements子句" class="headerlink" title="8.2.1 implements子句"></a>8.2.1 <code>implements</code>子句</h3><p>你可以使用一个 <code>implements</code> 子句来检查一个类，是否满足了一个特定的接口。如果一个类不能正确地实现它，就会发出一个错误。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Pingable</span> &#123;</span><br><span class="line">  <span class="title function_">ping</span>(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sonar</span> <span class="keyword">implements</span> <span class="title class_">Pingable</span> &#123;</span><br><span class="line">  <span class="title function_">ping</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;ping!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Ball</span> <span class="keyword">implements</span> <span class="title class_">Pingable</span> &#123;</span><br><span class="line">  <span class="title function_">pong</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;pong!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/img/TypeScript/09-07.png" alt="image-20211129154149915" style="zoom:50%"><p>类也可以实现多个接口，例如 <code>class C implements A, B &#123;</code></p><p><strong>注意事项</strong></p><p>重要的是要明白， <code>implements</code> 子句只是检查类是否可以被当作接口类型来对待。它根本不会改变类的类型或其方法。一个常见的错误来源是认为 <code>implements</code> 子句会改变类的类型–它不会！它不会。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Checkable</span> &#123;</span><br><span class="line">  <span class="title function_">check</span>(<span class="attr">name</span>: <span class="built_in">string</span>): <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NameChecker</span> <span class="keyword">implements</span> <span class="title class_">Checkable</span> &#123;</span><br><span class="line">  <span class="title function_">check</span>(<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="comment">// any：注意这里没有错误</span></span><br><span class="line">    <span class="keyword">return</span> s.<span class="title function_">toLowercse</span>() === <span class="string">&quot;ok&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/img/TypeScript/09-08.png" alt="image-20211129163841634" style="zoom:50%"><p>在这个例子中，我们也许期望 <code>s</code> 的类型会受到 <code>check</code>的<code>name: string</code>参数的影响。事实并非如此–实现子句并没有改变类主体的检查方式或其类型的推断。</p><p>同样地，实现一个带有可选属性的接口并不能创建该属性。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> A &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">  y?: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> <span class="keyword">implements</span> A &#123;</span><br><span class="line">  x = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> c = <span class="keyword">new</span> <span class="title function_">C</span>();</span><br><span class="line">c.<span class="property">y</span> = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><img src="/img/TypeScript/09-09.png" alt="image-20211129164354121" style="zoom:50%"><h3 id="8-2-2-extends子句"><a href="#8-2-2-extends子句" class="headerlink" title="8.2.2 extends子句"></a>8.2.2 <code>extends</code>子句</h3><p>类可以从基类中扩展出来。派生类拥有其基类的所有属性和方法，也可以定义额外的成员。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="title function_">move</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Moving along!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;</span><br><span class="line">  <span class="title function_">woof</span>(<span class="params">times: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; times; i++) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;woof!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> d = <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line"><span class="comment">// 基类的类方法</span></span><br><span class="line">d.<span class="title function_">move</span>();</span><br><span class="line"><span class="comment">// 派生的类方法</span></span><br><span class="line">d.<span class="title function_">woof</span>(<span class="number">3</span>);</span><br></pre></td></tr></table></figure><h3 id="8-2-3-重写方法"><a href="#8-2-3-重写方法" class="headerlink" title="8.2.3 重写方法"></a>8.2.3 重写方法</h3><p>派生类也可以覆盖基类的一个字段或属性。你可以使用<code>super.</code>语法来访问基类方法。注意，因为JavaScript类是一个简单的查找对象，没有 “超级字段 “的概念。</p><p>TypeScript强制要求派生类总是其基类的一个子类型。</p><p>例如，这里有一个合法的方法来覆盖一个方法。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">  <span class="title function_">greet</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Base</span> &#123;</span><br><span class="line">  <span class="title function_">greet</span>(<span class="params">name?: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (name === <span class="literal">undefined</span>) &#123;</span><br><span class="line">      <span class="variable language_">super</span>.<span class="title function_">greet</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, <span class="subst">$&#123;name.toUpperCase()&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> d = <span class="keyword">new</span> <span class="title class_">Derived</span>();</span><br><span class="line">d.<span class="title function_">greet</span>();</span><br><span class="line">d.<span class="title function_">greet</span>(<span class="string">&quot;reader&quot;</span>);</span><br></pre></td></tr></table></figure><p>派生类遵循其基类契约是很重要的。请记住，通过基类引用来引用派生类实例是非常常见的（而且总是合法的！）。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过基类引用对派生实例进行取别名</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">b</span>: <span class="title class_">Base</span> = d;</span><br><span class="line"><span class="comment">// 没问题</span></span><br><span class="line">b.<span class="title function_">greet</span>();</span><br></pre></td></tr></table></figure><p>如果<code>Derived</code>没有遵守Base的约定怎么办？</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">  <span class="title function_">greet</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Base</span> &#123;</span><br><span class="line">  <span class="comment">// 使这个参数成为必需的</span></span><br><span class="line">  <span class="title function_">greet</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, <span class="subst">$&#123;name.toUpperCase()&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/img/TypeScript/09-10.png" alt="image-20211129191159846" style="zoom:50%"><p>如果我们不顾错误编译这段代码，这个样本就会崩溃：</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">b</span>: <span class="title class_">Base</span> = <span class="keyword">new</span> <span class="title class_">Derived</span>();</span><br><span class="line"><span class="comment">// 崩溃，因为 &quot;名称 &quot;将是 undefined。</span></span><br><span class="line">b.<span class="title function_">greet</span>();</span><br></pre></td></tr></table></figure><img src="/img/TypeScript/09-11.png" alt="image-20211129191741373" style="zoom:50%"><h3 id="8-2-4-初始化顺序"><a href="#8-2-4-初始化顺序" class="headerlink" title="8.2.4 初始化顺序"></a>8.2.4 初始化顺序</h3><p>在某些情况下，JavaScript类的初始化顺序可能会令人惊讶。让我们考虑一下这段代码：</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">  name = <span class="string">&quot;base&quot;</span>;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;My name is &quot;</span> + <span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Base</span> &#123;</span><br><span class="line">  name = <span class="string">&quot;derived&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印 &quot;base&quot;, 而不是 &quot;derived&quot;</span></span><br><span class="line"><span class="keyword">const</span> d = <span class="keyword">new</span> <span class="title class_">Derived</span>();</span><br></pre></td></tr></table></figure><p>这里发生了什么？</p><p>按照JavaScript的定义，类初始化的顺序是：</p><ul><li>基类的字段被初始化</li><li>基类构造函数运行</li><li>派生类的字段被初始化</li><li>派生类构造函数运行</li></ul><p>这意味着基类构造函数在自己的构造函数中看到了自己的name值，因为派生类的字段初始化还没有运行。</p><h3 id="8-2-5-继承内置类型"><a href="#8-2-5-继承内置类型" class="headerlink" title="8.2.5 继承内置类型"></a>8.2.5 继承内置类型</h3><blockquote><p>注意：如果你不打算继承Array、Error、Map等内置类型，或者你的编译目标明确设置为ES6&#x2F;ES2015或以上，你可以跳过本节。</p></blockquote><p>在ES2015中，返回对象的构造函数隐含地替代了<code>super(...)</code>的任何调用者的<code>this</code>的值。生成的构造函数代码有必要捕获<code>super(...)</code>的任何潜在返回值并将其替换为<code>this</code>。</p><p>因此，子类化<code>Error</code>、<code>Array</code>等可能不再像预期那样工作。这是由于<code>Error</code>、<code>Array</code>等的构造函数使用ECMAScript 6的<code>new.target</code>来调整原型链；然而，在ECMAScript 5中调用构造函数时，没有办法确保<code>new.target</code>的值。其他的下级编译器一般默认有同样的限制。</p><p>对于一个像下面这样的子类：</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MsgError</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Error</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">m: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(m);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">sayHello</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello &quot;</span> + <span class="variable language_">this</span>.<span class="property">message</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可能会发现：</p><ul><li>方法在构造这些子类所返回的对象上可能是未定义的，所以调用 <code>sayHello</code> 会导致错误。</li></ul><img src="/img/TypeScript/09-12.png" alt="image-20211129205005544" style="zoom:50%"><ul><li><code>instanceof</code>将在子类的实例和它们的实例之间被打破，所以<code>（new MsgError()）instanceof MsgError</code>将返回<code>false</code>。</li></ul><img src="/img/TypeScript/09-13.png" alt="image-20211129205309009" style="zoom:50%"><p>作为建议，你可以在任何<code>super(...)</code>调用后立即手动调整原型。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MsgError</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Error</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">m: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(m);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 明确地设置原型。</span></span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(<span class="variable language_">this</span>, <span class="title class_">MsgError</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">sayHello</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello &quot;</span> + <span class="variable language_">this</span>.<span class="property">message</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/img/TypeScript/09-14.png" alt="image-20211129205721788" style="zoom:50%"><p>然而，<code>MsgError</code>的任何子类也必须手动设置原型。对于不支持<code>Object.setPrototypeOf</code>的运行时，你可以使用<code>__proto__</code>来代替。</p><p>不幸的是，这些变通方法在<code>Internet Explorer 10</code>和更早的版本上不起作用。我们可以手动将原型中的方法复制到实例本身（例如<code>MsgError.prototype</code>到<code>this</code>），但是原型链本身不能被修复。</p><h2 id="8-2-成员的可见性"><a href="#8-2-成员的可见性" class="headerlink" title="8.2 成员的可见性"></a>8.2 成员的可见性</h2><p>你可以使用TypeScript来控制某些方法或属性对类外的代码是否可见。</p><h3 id="8-2-1-public"><a href="#8-2-1-public" class="headerlink" title="8.2.1 public"></a>8.2.1 <code>public</code></h3><p>类成员的默认可见性是公共(<code>public</code>)的。一个公共(<code>public</code>)成员可以在任何地方被访问。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Greeter</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">greet</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hi!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> g = <span class="keyword">new</span> <span class="title class_">Greeter</span>();</span><br><span class="line">g.<span class="title function_">greet</span>();</span><br></pre></td></tr></table></figure><p>因为<code>public</code>已经是默认的可见性修饰符，所以你永远不需要在类成员上写它，但为了风格&#x2F;可读性的原因，可能会选择这样做。</p><h3 id="8-2-2-protected"><a href="#8-2-2-protected" class="headerlink" title="8.2.2 protected"></a>8.2.2 <code>protected</code></h3><p>受保护的(<code>protected</code>)成员只对它们所声明的类的子类可见。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Greeter</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">greet</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello, &quot;</span> + <span class="variable language_">this</span>.<span class="title function_">getName</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">protected</span> <span class="title function_">getName</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hi&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SpecialGreeter</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Greeter</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">howdy</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 在此可以访问受保护的成员</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Howdy, &quot;</span> + <span class="variable language_">this</span>.<span class="title function_">getName</span>());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> g = <span class="keyword">new</span> <span class="title class_">SpecialGreeter</span>();</span><br><span class="line">g.<span class="title function_">greet</span>(); <span class="comment">// 没有问题</span></span><br><span class="line">g.<span class="title function_">getName</span>(); <span class="comment">// 无权访问</span></span><br></pre></td></tr></table></figure><img src="/img/TypeScript/09-15.png" alt="image-20211130102051422" style="zoom:50%"><ul><li><strong>受保护成员的暴露</strong></li></ul><p>派生类需要遵循它们的基类契约，但可以选择公开具有更多能力的基类的子类型。这包括将受保护的成员变成公开。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">  <span class="keyword">protected</span> m = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Base</span> &#123;</span><br><span class="line">  <span class="comment">// 没有修饰符，所以默认为&#x27;公共&#x27;(&#x27;public&#x27;)</span></span><br><span class="line">  m = <span class="number">15</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> d = <span class="keyword">new</span> <span class="title class_">Derived</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(d.<span class="property">m</span>); <span class="comment">// OK</span></span><br></pre></td></tr></table></figure><h3 id="8-2-3-private"><a href="#8-2-3-private" class="headerlink" title="8.2.3 private"></a>8.2.3 <code>private</code></h3><p><code>private</code>和<code>protected</code>一样，但不允许从子类中访问该成员。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> x = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> b = <span class="keyword">new</span> <span class="title class_">Base</span>();</span><br><span class="line"><span class="comment">// 不能从类外访问</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b.<span class="property">x</span>);</span><br></pre></td></tr></table></figure><img src="/img/TypeScript/09-17.png" alt="image-20211130104530638" style="zoom:50%"><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> x = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> b = <span class="keyword">new</span> <span class="title class_">Base</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Base</span> &#123;</span><br><span class="line">  <span class="title function_">showX</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 不能在子类中访问</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">x</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为私有(<code>private</code>)成员对派生类是不可见的，所以派生类不能增加其可见性。</p><ul><li><strong>跨实例的私有访问</strong></li></ul><p>不同的OOP语言对同一个类的不同实例，是否可以访问对方的私有成员，有不同的处理方法。虽然像Java、C#、C++、Swift和PHP等语言允许这样做，但Ruby不允许。</p><p>TypeScript确实允许跨实例的私有访问：</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> x = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">sameAs</span>(<span class="params">other: A</span>) &#123;</span><br><span class="line">    <span class="comment">// 可以访问</span></span><br><span class="line">    <span class="keyword">return</span> other.<span class="property">x</span> === <span class="variable language_">this</span>.<span class="property">x</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>注意事项</strong></li></ul><p>像TypeScript类型系统的其他方面一样，<code>private</code>和<code>protected</code>只在类型检查中被强制执行。</p><p>这意味着JavaScript的运行时结构，如<code>in</code>或简单的属性查询，仍然可以访问一个私有或保护的成员。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MySafe</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> secretKey = <span class="number">12345</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在JS环境中...</span></span><br><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="title class_">MySafe</span>();</span><br><span class="line"><span class="comment">// 将打印 12345</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s.<span class="property">secretKey</span>);</span><br></pre></td></tr></table></figure><p><code>private</code>也允许在类型检查时使用括号符号进行访问。这使得私有声明的字段可能更容易被单元测试之类的东西所访问，缺点是这些字段是软性私有的，不能严格执行私有特性。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MySafe</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> secretKey = <span class="number">12345</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="title class_">MySafe</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在类型检查期间不允许</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s.<span class="property">secretKey</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s[<span class="string">&quot;secretKey&quot;</span>]);</span><br></pre></td></tr></table></figure><img src="/img/TypeScript/09-19.png" alt="image-20211130135104155" style="zoom:50%"><p>与TypeScript的 <code>private</code>不同，JavaScript的<code>private</code>字段（#）在编译后仍然是<code>private</code>的，并且不提供前面提到的像括号符号访问那样的转义窗口，使其成为硬<code>private</code>。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">  #barkAmount = <span class="number">0</span>;</span><br><span class="line">  personality = <span class="string">&quot;happy&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 0</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.#barkAmount);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dog = <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dog.<span class="property">barkAmount</span>);</span><br></pre></td></tr></table></figure><img src="/img/TypeScript/09-20.png" alt="image-20211130154613004" style="zoom:50%"><p>当编译到ES2021或更少时，TypeScript将使用WeakMaps来代替 <code>#</code>。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> _Dog_barkAmount;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    _Dog_barkAmount.<span class="title function_">set</span>(<span class="variable language_">this</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">personality</span> = <span class="string">&quot;happy&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">_Dog_barkAmount = <span class="keyword">new</span> <span class="title class_">WeakMap</span>();</span><br></pre></td></tr></table></figure><p>如果你需要保护你的类中的值免受恶意行为的影响，你应该使用提供硬运行时隐私的机制，如闭包、<code>WeakMaps</code>或私有字段。请注意，这些在运行时增加的隐私检查可能会影响性能。</p><h2 id="8-3-静态成员"><a href="#8-3-静态成员" class="headerlink" title="8.3 静态成员"></a>8.3 静态成员</h2><p>类可以有静态成员。这些成员并不与类的特定实例相关联。它们可以通过类的构造函数对象本身来访问。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> x = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">printX</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">MyClass</span>.<span class="property">x</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">MyClass</span>.<span class="property">x</span>);</span><br><span class="line"><span class="title class_">MyClass</span>.<span class="title function_">printX</span>();</span><br></pre></td></tr></table></figure><p>静态成员也可以使用相同的<code>public</code>、<code>protected</code>和<code>private</code>可见性修饰符。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> x = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">MyClass</span>.<span class="property">x</span>);</span><br></pre></td></tr></table></figure><img src="/img/TypeScript/09-21.png" alt="image-20211130161046623" style="zoom:50%"><p>静态成员也会被继承。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">getGreeting</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello world&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Base</span> &#123;</span><br><span class="line">  myGreeting = <span class="title class_">Derived</span>.<span class="title function_">getGreeting</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-3-1-特殊静态名称"><a href="#8-3-1-特殊静态名称" class="headerlink" title="8.3.1 特殊静态名称"></a>8.3.1 特殊静态名称</h3><p>一般来说，从函数原型覆盖属性是不安全的&#x2F;不可能的。因为类本身就是可以用<code>new</code>调用的函数，所以某些静态名称不能使用。像<code>name</code>、<code>length</code>和<code>call</code>这样的函数属性，定义为静态成员是无效的。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">S</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> name = <span class="string">&quot;S!&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/img/TypeScript/09-22.png" alt="image-20211203133418242" style="zoom:50%"><h3 id="8-3-2-为什么没有静态类？"><a href="#8-3-2-为什么没有静态类？" class="headerlink" title="8.3.2 为什么没有静态类？"></a>8.3.2 为什么没有静态类？</h3><p>TypeScript（和JavaScript）没有像C#和Java那样有一个叫做静态类的结构。</p><p>这些结构体的存在，只是因为这些语言强制所有的数据和函数都在一个类里面；因为这个限制在TypeScript中不存在，所以不需要它们。一个只有一个实例的类，在JavaScript&#x2F;TypeScript中通常只是表示为一个普通的对象。</p><p>例如，我们不需要TypeScript中的 “静态类 “语法，因为一个普通的对象（甚至是顶级函数）也可以完成这个工作。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不需要 &quot;static&quot; class</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyStaticClass</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">doSomething</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 首选 (备选 1)</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">doSomething</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 首选 (备选 2)</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">MyHelperObject</span> = &#123;</span><br><span class="line">  <span class="title function_">dosomething</span>(<span class="params"></span>) &#123;&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="8-4-类里的-static-区块"><a href="#8-4-类里的-static-区块" class="headerlink" title="8.4 类里的 static 区块"></a>8.4 类里的 <code>static</code>区块</h2><p>静态块允许你写一串有自己作用域的语句，可以访问包含类中的私有字段。这意味着我们可以用写语句的所有能力来写初始化代码，不泄露变量，并能完全访问我们类的内部结构。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> #count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">count</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Foo</span>.#count;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> lastInstances = &#123;</span><br><span class="line">        <span class="attr">length</span>: <span class="number">100</span>,</span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="title class_">Foo</span>.#count += lastInstances.<span class="property">length</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-5-泛型类"><a href="#8-5-泛型类" class="headerlink" title="8.5 泛型类"></a>8.5 泛型类</h2><p>类，和接口一样，可以是泛型的。当一个泛型类用new实例化时，其类型参数的推断方式与函数调用的方式相同。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span>&lt;<span class="title class_">Type</span>&gt; &#123;</span><br><span class="line">  <span class="attr">contents</span>: <span class="title class_">Type</span>;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">value: Type</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">contents</span> = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// const b: Box&lt;string&gt;</span></span><br><span class="line"><span class="keyword">const</span> b = <span class="keyword">new</span> <span class="title class_">Box</span>(<span class="string">&quot;hello!&quot;</span>);</span><br></pre></td></tr></table></figure><p>类可以像接口一样使用通用约束和默认值。</p><ul><li>静态成员中的类型参数</li></ul><p>这段代码是不合法的，可能并不明显，为什么呢？</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span>&lt;<span class="title class_">Type</span>&gt; &#123;</span><br><span class="line">  <span class="comment">// 静态成员不能引用类的类型参数。</span></span><br><span class="line">  <span class="keyword">static</span> <span class="attr">defaultValue</span>: <span class="title class_">Type</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Box&lt;string&gt;.defaultValue = &#x27;hello&#x27;</span></span><br><span class="line"><span class="comment">// console.log(Box&lt;number&gt;.defaultValue)</span></span><br></pre></td></tr></table></figure><p>请记住，类型总是被完全擦除的! 在运行时，只有一个Box.defaultValue属性。这意味着设置Box<string>.defaultValue（如果有可能的话）也会改变Box<number>.defaultValue，这可不是什么好事。一个泛型类的静态成员永远不能引用该类的类型参数。</number></string></p><h2 id="8-6-类运行时中的this"><a href="#8-6-类运行时中的this" class="headerlink" title="8.6 类运行时中的this"></a>8.6 类运行时中的<code>this</code></h2><p>重要的是要记住，TypeScript并没有改变JavaScript的运行时行为，而JavaScript的运行时行为偶尔很奇特。</p><p>比如，JavaScript对这一点的处理确实是不寻常的：</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">  name = <span class="string">&quot;MyClass&quot;</span>;</span><br><span class="line">  <span class="title function_">getName</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> c = <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;obj&quot;</span>,</span><br><span class="line">  <span class="attr">getName</span>: c.<span class="property">getName</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出 &quot;obj&quot;, 而不是 &quot;MyClass&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="title function_">getName</span>());</span><br></pre></td></tr></table></figure><p>长话短说，默认情况下，函数内this的值取决于函数的调用方式。在这个例子中，因为函数是通过obj引用调用的，所以它的this值是obj而不是类实例。</p><p>这很少是你希望发生的事情! TypeScript提供了一些方法来减轻或防止这种错误。</p><p><strong>1、箭头函数</strong></p><p>如果你有一个经常会被调用的函数，失去了它的 <code>this</code> 上下文，那么使用一个箭头函数而不是方法定义是有意义的。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">  name = <span class="string">&quot;MyClass&quot;</span>;</span><br><span class="line">  getName = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> c = <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line"><span class="keyword">const</span> g = c.<span class="property">getName</span>;</span><br><span class="line"><span class="comment">// 输出 &quot;MyClass&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">g</span>());</span><br></pre></td></tr></table></figure><p>这有一些权衡：</p><ul><li><p><code>this</code> 值保证在运行时是正确的，即使是没有经过TypeScript检查的代码也是如此。</p></li><li><p>这将使用更多的内存，因为每个类实例将有它自己的副本，每个函数都是这样定义的。</p></li><li><p>你不能在派生类中使用<code>super.getName</code>，因为在原型链中没有入口可以获取基类方法。</p></li></ul><p><strong>2、<code>this</code> 参数</strong></p><p>在方法或函数定义中，一个名为<code>this</code>的初始参数在TypeScript中具有特殊的意义。这些参数在编译过程中会被删除。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 带有 &quot;this&quot; 参数的 TypeScript 输入</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"><span class="variable language_">this</span>: SomeType, x: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 编译后的JavaScript结果</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">x</span>) &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TypeScript检查调用带有<code>this</code>参数的函数，是否在正确的上下文中进行。我们可以不使用箭头函数，而是在方法定义中添加一个<code>this</code>参数，以静态地确保方法被正确调用。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">  name = <span class="string">&quot;MyClass&quot;</span>;</span><br><span class="line">  <span class="title function_">getName</span>(<span class="params"><span class="variable language_">this</span>: MyClass</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> c = <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line">c.<span class="title function_">getName</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误</span></span><br><span class="line"><span class="keyword">const</span> g = c.<span class="property">getName</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">g</span>());</span><br></pre></td></tr></table></figure><img src="/img/TypeScript/09-23.png" alt="image-20211210093534818" style="zoom:67%"><p>这种方法做出了与箭头函数方法相反的取舍：</p><ul><li>JavaScript调用者仍然可能在不知不觉中错误地使用类方法</li><li>每个类定义只有一个函数被分配，而不是每个类实例一个函数</li><li>基类方法定义仍然可以通过 <code>super</code>调用。</li></ul><h2 id="8-7-this类型"><a href="#8-7-this类型" class="headerlink" title="8.7 this类型"></a>8.7 <code>this</code>类型</h2><p>在类中，一个叫做 <code>this</code>的特殊类型动态地指向当前类的类型。让我们来看看这有什么用：</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span> &#123;</span><br><span class="line">  <span class="attr">contents</span>: <span class="built_in">string</span> = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="comment">// (method) Box.set(value: string): this</span></span><br><span class="line">  <span class="title function_">set</span>(<span class="params">value: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">contents</span> = value;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里，TypeScript推断出 <code>set</code>的返回类型是<code>this</code>，而不是<code>Box</code>。现在让我们做一个Box的子类：</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ClearableBox</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Box</span> &#123;</span><br><span class="line">  <span class="title function_">clear</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">contents</span> = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> <span class="title class_">ClearableBox</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// const b: ClearableBox</span></span><br><span class="line"><span class="keyword">const</span> b = a.<span class="title function_">set</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b);</span><br></pre></td></tr></table></figure><img src="/img/TypeScript/09-24.png" alt="image-20211210095241472" style="zoom:50%" align="left"><p>你也可以在参数类型注释中使用 <code>this</code>：</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span> &#123;</span><br><span class="line">  <span class="attr">content</span>: <span class="built_in">string</span> = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="title function_">sameAs</span>(<span class="params">other: <span class="variable language_">this</span></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> other.<span class="property">content</span> === <span class="variable language_">this</span>.<span class="property">content</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> box = <span class="keyword">new</span> <span class="title class_">Box</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(box.<span class="title function_">sameAs</span>(box));</span><br></pre></td></tr></table></figure><p>这与其他写法不同：Box，如果你有一个派生类，它的 <code>sameAs</code> 方法现在只接受该同一派生类的其他实例。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span> &#123;</span><br><span class="line">  <span class="attr">content</span>: <span class="built_in">string</span> = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="title function_">sameAs</span>(<span class="params">other: <span class="variable language_">this</span></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> other.<span class="property">content</span> === <span class="variable language_">this</span>.<span class="property">content</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DerivedBox</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Box</span> &#123;</span><br><span class="line">  <span class="attr">otherContent</span>: <span class="built_in">string</span> = <span class="string">&quot;?&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> base = <span class="keyword">new</span> <span class="title class_">Box</span>();</span><br><span class="line"><span class="keyword">const</span> derived = <span class="keyword">new</span> <span class="title class_">DerivedBox</span>();</span><br><span class="line">derived.<span class="title function_">sameAs</span>(base);</span><br></pre></td></tr></table></figure><img src="/img/TypeScript/09-25.png" alt="image-20211210102234118" style="zoom:50%"><h2 id="8-8-基于类型守卫的this"><a href="#8-8-基于类型守卫的this" class="headerlink" title="8.8 基于类型守卫的this"></a>8.8 基于类型守卫的<code>this</code></h2><p>你可以在类和接口的方法的返回位置使用 <code>this is Type</code> 。当与类型缩小混合时（例如if语句），目标对象的类型将被缩小到指定的Type。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FileSystemObject</span> &#123;</span><br><span class="line">  <span class="title function_">isFile</span>(): <span class="variable language_">this</span> is <span class="title class_">FileRep</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span> <span class="keyword">instanceof</span> <span class="title class_">FileRep</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">isDirectory</span>(): <span class="variable language_">this</span> is <span class="title class_">Directory</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span> <span class="keyword">instanceof</span> <span class="title class_">Directory</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">isNetworked</span>(): <span class="variable language_">this</span> is <span class="title class_">Networked</span> &amp; <span class="variable language_">this</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">networked</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span></span><br><span class="line"><span class="params">    <span class="keyword">public</span> path: <span class="built_in">string</span>,</span></span><br><span class="line"><span class="params">    <span class="keyword">private</span> networked: <span class="built_in">boolean</span>,</span></span><br><span class="line"><span class="params">  </span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FileRep</span> <span class="keyword">extends</span> <span class="title class_ inherited__">FileSystemObject</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span></span><br><span class="line"><span class="params">    path: <span class="built_in">string</span>,</span></span><br><span class="line"><span class="params">    <span class="keyword">public</span> content: <span class="built_in">string</span>,</span></span><br><span class="line"><span class="params">  </span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(path, <span class="literal">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Directory</span> <span class="keyword">extends</span> <span class="title class_ inherited__">FileSystemObject</span> &#123;</span><br><span class="line">  <span class="attr">children</span>: <span class="title class_">FileSystemObject</span>[];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Networked</span> &#123;</span><br><span class="line">  <span class="attr">host</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">fso</span>: <span class="title class_">FileSystemObject</span> = <span class="keyword">new</span> <span class="title class_">FileRep</span>(<span class="string">&quot;foo/bar.txt&quot;</span>, <span class="string">&quot;foo&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (fso.<span class="title function_">isFile</span>()) &#123;</span><br><span class="line">  <span class="comment">// const fso: FileRep</span></span><br><span class="line">  fso.<span class="property">content</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (fso.<span class="title function_">isDirectory</span>()) &#123;</span><br><span class="line">  <span class="comment">// const fso: Directory</span></span><br><span class="line">  fso.<span class="property">children</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (fso.<span class="title function_">isNetworked</span>()) &#123;</span><br><span class="line">  <span class="comment">// const fso: Networked &amp; FileSystemObject</span></span><br><span class="line">  fso.<span class="property">host</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基于 <code>this</code> 的类型保护的一个常见用例，是允许对一个特定字段进行懒惰验证。例如，这种情况下，当 <code>hasValue</code>被验证为真时，就会从框内持有的值中删除一个未定义值。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span>&lt;T&gt; &#123;</span><br><span class="line">  value?: T;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">hasValue</span>(): <span class="variable language_">this</span> is &#123; <span class="attr">value</span>: T &#125; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">value</span> !== <span class="literal">undefined</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> box = <span class="keyword">new</span> <span class="title class_">Box</span>();</span><br><span class="line">box.<span class="property">value</span> = <span class="string">&quot;Gameboy&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (property) Box&lt;unknown&gt;.value?: unknownbox.value;</span></span><br><span class="line"><span class="keyword">if</span> (box.<span class="title function_">hasValue</span>()) &#123;</span><br><span class="line">  <span class="comment">// (property) value: unknown</span></span><br><span class="line">  box.<span class="property">value</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-9-参数属性"><a href="#8-9-参数属性" class="headerlink" title="8.9 参数属性"></a>8.9 参数属性</h2><p>TypeScript提供了特殊的语法，可以将构造函数参数变成具有相同名称和值的类属性。这些被称为参数属性，通过在构造函数参数前加上可见性修饰符 <code>public</code>、<code>private</code>、<code>protected</code>或<code>readonly</code>中的一个来创建。由此产生的字段会得到这些修饰符。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Params</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span></span><br><span class="line"><span class="params">    <span class="keyword">public</span> <span class="keyword">readonly</span> x: <span class="built_in">number</span>,</span></span><br><span class="line"><span class="params">    <span class="keyword">protected</span> y: <span class="built_in">number</span>,</span></span><br><span class="line"><span class="params">    <span class="keyword">private</span> z: <span class="built_in">number</span>,</span></span><br><span class="line"><span class="params">  </span>) &#123;</span><br><span class="line">    <span class="comment">// No body necessary</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> <span class="title class_">Params</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// (property) Params.x: number</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="property">x</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="property">z</span>);</span><br></pre></td></tr></table></figure><img src="/img/TypeScript/10-01.png" alt="image-20211214162348578" style="zoom:60%"><h2 id="8-10-类表达式"><a href="#8-10-类表达式" class="headerlink" title="8.10 类表达式"></a>8.10 类表达式</h2><p>类表达式与类声明非常相似。唯一真正的区别是，类表达式不需要一个名字，尽管我们可以通过它们最终绑定的任何标识符来引用它们。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> someClass = <span class="keyword">class</span>&lt;<span class="title class_">Type</span>&gt; &#123;</span><br><span class="line">  <span class="attr">content</span>: <span class="title class_">Type</span>;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">value: Type</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">content</span> = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// const m: someClass&lt;string&gt;</span></span><br><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="title function_">someClass</span>(<span class="string">&quot;Hello, world&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="8-11-抽象类和成员"><a href="#8-11-抽象类和成员" class="headerlink" title="8.11 抽象类和成员"></a>8.11 抽象类和成员</h2><p>TypeScript中的类、方法和字段可以是抽象的。</p><p>一个抽象的方法或抽象的字段是一个没有提供实现的方法或字段。这些成员必须存在于一个抽象类中，不能直接实例化。</p><p>抽象类的作用是作为子类的基类，实现所有的抽象成员。当一个类没有任何抽象成员时，我们就说它是具体的。</p><p>让我们看一个例子：</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">  <span class="keyword">abstract</span> <span class="title function_">getName</span>(): <span class="built_in">string</span>;</span><br><span class="line">  <span class="title function_">printName</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello, &quot;</span> + <span class="variable language_">this</span>.<span class="title function_">getName</span>());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> b = <span class="keyword">new</span> <span class="title class_">Base</span>();</span><br></pre></td></tr></table></figure><img src="/img/TypeScript/10-02.png" alt="image-20211219063509036" style="zoom:60%"><p>我们不能用 <code>new</code>来实例化<code>Base</code>，因为它是抽象的。相反，我们需要创建一个派生类并实现抽象成员。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Base</span> &#123;</span><br><span class="line">  <span class="title function_">getName</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;world&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> d = <span class="keyword">new</span> <span class="title class_">Derived</span>();</span><br><span class="line">d.<span class="title function_">printName</span>();</span><br></pre></td></tr></table></figure><img src="/img/TypeScript/10-03.png" alt="image-20211219064030984" style="zoom:60%"><ul><li><strong>抽象构造签名</strong></li></ul><p>有时你想接受一些类的构造函数，产生一个从某些抽象类派生出来的类的实例。</p><p>例如，你可能想写这样的代码：</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">greet</span>(<span class="params">ctor: <span class="keyword">typeof</span> Base</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> instance = <span class="keyword">new</span> <span class="title function_">ctor</span>();</span><br><span class="line">  instance.<span class="title function_">printName</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/img/TypeScript/10-04.png" alt="image-20211219064506944" style="zoom:67%"><p>TypeScript正确地告诉你，你正试图实例化一个抽象类。毕竟，鉴于greet的定义，写这段代码是完全合法的，它最终会构造一个抽象类。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 槽糕</span></span><br><span class="line"><span class="title function_">greet</span>(<span class="title class_">Base</span>);</span><br></pre></td></tr></table></figure><p>相反，你想写一个函数，接受具有结构化签名的东西：</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">greet</span>(<span class="params">ctor: <span class="keyword">new</span> () =&gt; Base</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> instance = <span class="keyword">new</span> <span class="title function_">ctor</span>();</span><br><span class="line">  instance.<span class="title function_">printName</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">greet</span>(<span class="title class_">Derived</span>);</span><br><span class="line"><span class="title function_">greet</span>(<span class="title class_">Base</span>);</span><br></pre></td></tr></table></figure><img src="/img/TypeScript/10-05.png" alt="image-20211219065154437" style="zoom:67%"><p>现在TypeScript正确地告诉你哪些类的构造函数可以被调用：<code>Derived</code>可以，因为它是具体的，但<code>Base</code>不能。</p><h2 id="8-12-类之间的关系"><a href="#8-12-类之间的关系" class="headerlink" title="8.12 类之间的关系"></a>8.12 类之间的关系</h2><p>在大多数情况下，TypeScript中的类在结构上与其他类型相同，是可以比较的。</p><p>例如，这两个类可以互相替代使用，因为它们是相同的：</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point1</span> &#123;</span><br><span class="line">  x = <span class="number">0</span>;</span><br><span class="line">  y = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point2</span> &#123;</span><br><span class="line">  x = <span class="number">0</span>;</span><br><span class="line">  y = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">p</span>: <span class="title class_">Point1</span> = <span class="keyword">new</span> <span class="title class_">Point2</span>();</span><br></pre></td></tr></table></figure><p>同样地，即使没有明确的继承，类之间的子类型关系也是存在的：</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">salary</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">p</span>: <span class="title class_">Person</span> = <span class="keyword">new</span> <span class="title class_">Employee</span>();</span><br></pre></td></tr></table></figure><p>这听起来很简单，但有几种情况似乎比其他情况更奇怪。</p><p>空的类没有成员。在一个结构化类型系统中，一个没有成员的类型通常是其他任何东西的超类型。所以如果你写了一个空类（不要！），任何东西都可以用来代替它。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Empty</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">x: Empty</span>) &#123;</span><br><span class="line">  <span class="comment">// 不能用&#x27;x&#x27;做任何事</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下调用均可</span></span><br><span class="line">!<span class="title function_">fn</span>(<span class="variable language_">window</span>);</span><br><span class="line"><span class="title function_">fn</span>(&#123;&#125;);</span><br><span class="line"><span class="title function_">fn</span>(fn);</span><br></pre></td></tr></table></figure><h3 id="特别声明-本文转自-古艺散人老师-，如有需要可前往原文预览查看。"><a href="#特别声明-本文转自-古艺散人老师-，如有需要可前往原文预览查看。" class="headerlink" title="特别声明: 本文转自  古艺散人老师 ，如有需要可前往原文预览查看。"></a>特别声明: 本文转自 <a target="_blank" rel="noopener" href="https://github.com/lurongtao/TypeScript">古艺散人老师 </a>，如有需要可前往原文预览查看。</h3></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://maple-214.cn">泽枫</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://maple-214.cn/article/55025/">https://maple-214.cn/article/55025/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://maple-214.cn" target="_blank">澤楓の小屋</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%89%8D%E7%AB%AF/">前端</a><a class="post-meta__tags" href="/tags/TypeScript/">TypeScript</a></div><div class="post_share"><div class="social-share" data-image="/img/cover/cover_02.jpeg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/qrCode/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/qrCode/wechat.jpg" alt="wechat"></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/qrCode/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/qrCode/alipay.jpg" alt="alipay"></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/article/40444/" title="1-9、基础篇：模块"><img class="cover" src="/img/cover/cover_02.jpeg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">1-9、基础篇：模块</div></div></a></div><div class="next-post pull-right"><a href="/article/2401/" title="1-7、基础篇：类型操纵"><img class="cover" src="/img/cover/cover_02.jpeg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">1-7、基础篇：类型操纵</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/article/8074/" title="1-1、基础篇：TypeScript介绍"><img class="cover" src="/img/cover/cover_03.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-26</div><div class="title">1-1、基础篇：TypeScript介绍</div></div></a></div><div><a href="/article/20247/" title="1-2、基础篇：TypeScript入门"><img class="cover" src="/img/cover/cover_02.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-26</div><div class="title">1-2、基础篇：TypeScript入门</div></div></a></div><div><a href="/article/19978/" title="1-3、基础篇：常用类型"><img class="cover" src="/img/cover/cover_01.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-26</div><div class="title">1-3、基础篇：常用类型</div></div></a></div><div><a href="/article/23966/" title="1-4、基础篇：类型缩小"><img class="cover" src="/img/cover/cover_02.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-26</div><div class="title">1-4、基础篇：类型缩小</div></div></a></div><div><a href="/article/30791/" title="1-5、基础篇：函数更多"><img class="cover" src="/img/cover/cover_02.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-26</div><div class="title">1-5、基础篇：函数更多</div></div></a></div><div><a href="/article/59398/" title="1-6、基础篇：对象类型"><img class="cover" src="/img/cover/cover_02.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-26</div><div class="title">1-6、基础篇：对象类型</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info__name">泽枫</div><div class="author-info__description">牛奶会有的，面包也会有的。</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">26</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">3</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><a id="card-info-btn"><i class="fab fa-github"></i><span>我是一个按钮</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">明天会更好。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E7%B1%BB"><span class="toc-number">1.</span> <span class="toc-text">八、类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#8-1-%E7%B1%BB%E6%88%90%E5%91%98"><span class="toc-number">1.1.</span> <span class="toc-text">8.1 类成员</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-1-%E7%B1%BB%E5%B1%9E%E6%80%A7"><span class="toc-number">1.1.1.</span> <span class="toc-text">8.1.1 类属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-2-readonly"><span class="toc-number">1.1.2.</span> <span class="toc-text">8.1.2 readonly</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-3-%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-number">1.1.3.</span> <span class="toc-text">8.1.3 构造器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-4-%E6%96%B9%E6%B3%95"><span class="toc-number">1.1.4.</span> <span class="toc-text">8.1.4 方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-5-Getters-Setters"><span class="toc-number">1.1.5.</span> <span class="toc-text">8.1.5 Getters &#x2F; Setters</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-6-%E7%B4%A2%E5%BC%95%E7%AD%BE%E5%90%8D"><span class="toc-number">1.1.6.</span> <span class="toc-text">8.1.6 索引签名</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-2-%E7%B1%BB%E7%BB%A7%E6%89%BF"><span class="toc-number">1.2.</span> <span class="toc-text">8.2 类继承</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-1-implements%E5%AD%90%E5%8F%A5"><span class="toc-number">1.2.1.</span> <span class="toc-text">8.2.1 implements子句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-2-extends%E5%AD%90%E5%8F%A5"><span class="toc-number">1.2.2.</span> <span class="toc-text">8.2.2 extends子句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-3-%E9%87%8D%E5%86%99%E6%96%B9%E6%B3%95"><span class="toc-number">1.2.3.</span> <span class="toc-text">8.2.3 重写方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-4-%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F"><span class="toc-number">1.2.4.</span> <span class="toc-text">8.2.4 初始化顺序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-5-%E7%BB%A7%E6%89%BF%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.2.5.</span> <span class="toc-text">8.2.5 继承内置类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-2-%E6%88%90%E5%91%98%E7%9A%84%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="toc-number">1.3.</span> <span class="toc-text">8.2 成员的可见性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-1-public"><span class="toc-number">1.3.1.</span> <span class="toc-text">8.2.1 public</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-2-protected"><span class="toc-number">1.3.2.</span> <span class="toc-text">8.2.2 protected</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-3-private"><span class="toc-number">1.3.3.</span> <span class="toc-text">8.2.3 private</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-3-%E9%9D%99%E6%80%81%E6%88%90%E5%91%98"><span class="toc-number">1.4.</span> <span class="toc-text">8.3 静态成员</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-1-%E7%89%B9%E6%AE%8A%E9%9D%99%E6%80%81%E5%90%8D%E7%A7%B0"><span class="toc-number">1.4.1.</span> <span class="toc-text">8.3.1 特殊静态名称</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-2-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%B2%A1%E6%9C%89%E9%9D%99%E6%80%81%E7%B1%BB%EF%BC%9F"><span class="toc-number">1.4.2.</span> <span class="toc-text">8.3.2 为什么没有静态类？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-4-%E7%B1%BB%E9%87%8C%E7%9A%84-static-%E5%8C%BA%E5%9D%97"><span class="toc-number">1.5.</span> <span class="toc-text">8.4 类里的 static 区块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-5-%E6%B3%9B%E5%9E%8B%E7%B1%BB"><span class="toc-number">1.6.</span> <span class="toc-text">8.5 泛型类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-6-%E7%B1%BB%E8%BF%90%E8%A1%8C%E6%97%B6%E4%B8%AD%E7%9A%84this"><span class="toc-number">1.7.</span> <span class="toc-text">8.6 类运行时中的this</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-7-this%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.8.</span> <span class="toc-text">8.7 this类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-8-%E5%9F%BA%E4%BA%8E%E7%B1%BB%E5%9E%8B%E5%AE%88%E5%8D%AB%E7%9A%84this"><span class="toc-number">1.9.</span> <span class="toc-text">8.8 基于类型守卫的this</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-9-%E5%8F%82%E6%95%B0%E5%B1%9E%E6%80%A7"><span class="toc-number">1.10.</span> <span class="toc-text">8.9 参数属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-10-%E7%B1%BB%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">1.11.</span> <span class="toc-text">8.10 类表达式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-11-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%88%90%E5%91%98"><span class="toc-number">1.12.</span> <span class="toc-text">8.11 抽象类和成员</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-12-%E7%B1%BB%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">1.13.</span> <span class="toc-text">8.12 类之间的关系</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E5%88%AB%E5%A3%B0%E6%98%8E-%E6%9C%AC%E6%96%87%E8%BD%AC%E8%87%AA-%E5%8F%A4%E8%89%BA%E6%95%A3%E4%BA%BA%E8%80%81%E5%B8%88-%EF%BC%8C%E5%A6%82%E6%9C%89%E9%9C%80%E8%A6%81%E5%8F%AF%E5%89%8D%E5%BE%80%E5%8E%9F%E6%96%87%E9%A2%84%E8%A7%88%E6%9F%A5%E7%9C%8B%E3%80%82"><span class="toc-number">1.13.1.</span> <span class="toc-text">特别声明: 本文转自 古艺散人老师 ，如有需要可前往原文预览查看。</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/article/16495/" title="1-1、CSS中hover时出现抖动的原因和解决方法"><img src="/img/cover/cover_03.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="1-1、CSS中hover时出现抖动的原因和解决方法"></a><div class="content"><a class="title" href="/article/16495/" title="1-1、CSS中hover时出现抖动的原因和解决方法">1-1、CSS中hover时出现抖动的原因和解决方法</a><time datetime="2024-01-26T12:30:06.000Z" title="发表于 2024-01-26 20:30:06">2024-01-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/article/43000/" title="3-7、高级篇：声明合并"><img src="/img/cover/cover_02.jpeg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="3-7、高级篇：声明合并"></a><div class="content"><a class="title" href="/article/43000/" title="3-7、高级篇：声明合并">3-7、高级篇：声明合并</a><time datetime="2024-01-26T12:24:54.000Z" title="发表于 2024-01-26 20:24:54">2024-01-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/article/19249/" title="3-6、高级篇：命名空间与模块"><img src="/img/cover/cover_01.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="3-6、高级篇：命名空间与模块"></a><div class="content"><a class="title" href="/article/19249/" title="3-6、高级篇：命名空间与模块">3-6、高级篇：命名空间与模块</a><time datetime="2024-01-26T12:23:45.000Z" title="发表于 2024-01-26 20:23:45">2024-01-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/article/52849/" title="3-5、高级篇：命名空间"><img src="/img/cover/cover_03.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="3-5、高级篇：命名空间"></a><div class="content"><a class="title" href="/article/52849/" title="3-5、高级篇：命名空间">3-5、高级篇：命名空间</a><time datetime="2024-01-26T12:23:06.000Z" title="发表于 2024-01-26 20:23:06">2024-01-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/article/3652/" title="3-4、高级篇：模块解析"><img src="/img/cover/cover_02.jpeg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="3-4、高级篇：模块解析"></a><div class="content"><a class="title" href="/article/3652/" title="3-4、高级篇：模块解析">3-4、高级篇：模块解析</a><time datetime="2024-01-26T12:22:08.000Z" title="发表于 2024-01-26 20:22:08">2024-01-26</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div id="ft"><img class="ft-img" src="/img/favicon.png" alt="" srcset=""></div><div class="copyright">&copy;2020 - 2024 <i id="heartbeat" class="fa fas fa-heartbeat"></i> 泽枫</div></div></footer></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简体</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.12.0"></script><script src="/js/main.js?v=4.12.0"></script><script src="/js/tw_cn.js?v=4.12.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.32/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.js"></script><script>function panguFn(){"object"==typeof pangu?pangu.autoSpacingPage():getScript("https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js").then(()=>{pangu.autoSpacingPage()})}function panguInit(){GLOBAL_CONFIG_SITE.isPost&&panguFn()}document.addEventListener("DOMContentLoaded",panguInit)</script><div class="js-pjax"></div><script type="text/javascript" src="/js/src/jquery.js"></script><script type="text/javascript" src="/js/src/vue.js"></script><script type="text/javascript" src="/js/src/vue_js.js"></script><script type="text/javascript" src="/js/src/nav.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/fireworks.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors=["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"];var pjax=new Pjax({elements:'a:not([target="_blank"])',selectors:pjaxSelectors,cacheBust:!1,analytics:!0,scrollRestoration:!1});document.addEventListener("pjax:send",function(){if(btf.removeGlobalFnEvent("pjax"),btf.removeGlobalFnEvent("themeChange"),document.getElementById("rightside").classList.remove("rightside-show"),window.aplayers)for(let e=0;e<window.aplayers.length;e++)window.aplayers[e].options.fixed||window.aplayers[e].destroy();"object"==typeof typed&&typed.destroy();var e=document.body.classList;e.contains("read-mode")&&e.remove("read-mode"),"object"==typeof disqusjs&&disqusjs.destroy()}),document.addEventListener("pjax:complete",function(){window.refreshFn(),document.querySelectorAll("script[data-pjax]").forEach(e=>{const t=document.createElement("script");var a=e.text||e.textContent||e.innerHTML||"";Array.from(e.attributes).forEach(e=>t.setAttribute(e.name,e.value)),t.appendChild(document.createTextNode(a)),e.parentNode.replaceChild(t,e)}),GLOBAL_CONFIG.islazyload&&window.lazyLoadInstance.update(),"function"==typeof panguInit&&panguInit(),"function"==typeof gtag&&gtag("config","G-FZNMK725WD",{page_path:window.location.pathname}),"object"==typeof _hmt&&_hmt.push(["_trackPageview",window.location.pathname]),"function"==typeof loadMeting&&document.getElementsByClassName("aplayer").length&&loadMeting(),"object"==typeof Prism&&Prism.highlightAll()}),document.addEventListener("pjax:error",e=>{404===e.request.status&&pjax.loadUrl("/404.html")})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span> 数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.12.0"></script></div></div><script data-pjax>var parent,child;document.getElementById("recent-posts")&&"/"==location.pathname&&(parent=document.getElementById("recent-posts")).insertAdjacentHTML("afterbegin",child='<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms"><div class="blog-slider__img blog-slider__custom_img"><img src="/img/recommend/recommend_06.jpg" alt="/img/recommend/recommend_06.jpg"/></div><div class="blog-slider__content"><span class="blog-slider__code">2024-01-26</span><a class="blog-slider__title" href="article/8074/">1-1、基础篇：TypeScript介绍</a><div class="blog-slider__text">1-1、基础篇：TypeScript介绍</div><a class="blog-slider__button" href="article/8074/">详情</a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms"><div class="blog-slider__img blog-slider__custom_img"><img src="/img/recommend/recommend_05.jpg" alt="/img/recommend/recommend_05.jpg"/></div><div class="blog-slider__content"><span class="blog-slider__code">2024-01-26</span><a class="blog-slider__title" href="article/20247/">1-2、基础篇：TypeScript入门</a><div class="blog-slider__text">1-2、基础篇：TypeScript入门</div><a class="blog-slider__button" href="article/20247/">详情</a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms"><div class="blog-slider__img blog-slider__custom_img"><img src="/img/recommend/recommend_04.jpg" alt="/img/recommend/recommend_04.jpg"/></div><div class="blog-slider__content"><span class="blog-slider__code">2024-01-26</span><a class="blog-slider__title" href="article/19978/">1-3、基础篇：常用类型</a><div class="blog-slider__text">1-3、基础篇：常用类型</div><a class="blog-slider__button" href="article/19978/">详情</a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms"><div class="blog-slider__img blog-slider__custom_img"><img src="/img/recommend/recommend_03.jpg" alt="/img/recommend/recommend_03.jpg"/></div><div class="blog-slider__content"><span class="blog-slider__code">2024-01-26</span><a class="blog-slider__title" href="article/23966/">1-4、基础篇：类型缩小</a><div class="blog-slider__text">1-4、基础篇：类型缩小</div><a class="blog-slider__button" href="article/23966/">详情</a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms"><div class="blog-slider__img blog-slider__custom_img"><img src="/img/recommend/recommend_02.jpg" alt="/img/recommend/recommend_02.jpg"/></div><div class="blog-slider__content"><span class="blog-slider__code">2024-01-26</span><a class="blog-slider__title" href="article/30791/">1-5、基础篇：函数更多</a><div class="blog-slider__text">1-5、基础篇：函数更多</div><a class="blog-slider__button" href="article/30791/">详情</a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms"><div class="blog-slider__img blog-slider__custom_img"><img src="/img/recommend/recommend_01.jpg" alt="/img/recommend/recommend_01.jpg"/></div><div class="blog-slider__content"><span class="blog-slider__code">2024-01-26</span><a class="blog-slider__title" href="article/59398/">1-6、基础篇：对象类型</a><div class="blog-slider__text">1-6、基础篇：对象类型</div><a class="blog-slider__button" href="article/59398/">详情</a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>')</script><script data-pjax src="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-swiper/swiper/swiper.min.js"></script><script data-pjax src="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-swiper@0.18/swiper/swiperindex.js"></script><style></style></body></html>